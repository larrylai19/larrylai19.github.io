<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Data Mining with Kaggle YouTube Videos and Channels Metadata</title>
    <url>/Data-Mining-with-Kaggle-YouTube-Videos-and-Channels-Metadata/</url>
    <content><![CDATA[<h2 id="Github-Link"><a href="#Github-Link" class="headerlink" title="Github Link"></a>Github Link</h2><p><a href="https://github.com/larrylai19/Data-Mining-with-Kaggle-YouTube-Videos-and-Channels-Metadata">Data-Mining-with-Kaggle-YouTube-Videos-and-Channels-Metadata</a></p>
<h2 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h2><p><a href="https://www.kaggle.com/datasets/thedevastator/revealing-insights-from-youtube-video-and-channe">YouTube Videos and Channels Metadata</a></p>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><h3 id="1-Create-Enviroments"><a href="#1-Create-Enviroments" class="headerlink" title="1. Create Enviroments"></a>1. Create Enviroments</h3><ul>
<li><p>Windows</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m venv venv</span><br><span class="line">venv\Scripts\activate</span><br><span class="line">pip install -r requirements.txt</span><br><span class="line">jupyter lab</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-Download-Dataset"><a href="#2-Download-Dataset" class="headerlink" title="2. Download Dataset"></a>2. Download Dataset</h3><ul>
<li>Download dataset from <a href="https://www.kaggle.com/datasets/thedevastator/revealing-insights-from-youtube-video-and-channe">YouTube Videos and Channels Metadata</a></li>
<li>Put <code>YouTubeDataset_withChannelElapsed.csv</code> under source folder</li>
</ul>
<h3 id="3-Open-data-mining-ipynb-On-Jupyter"><a href="#3-Open-data-mining-ipynb-On-Jupyter" class="headerlink" title="3. Open data-mining.ipynb On Jupyter"></a>3. Open <code>data-mining.ipynb</code> On Jupyter</h3><h2 id="Processing"><a href="#Processing" class="headerlink" title="Processing"></a>Processing</h2><h3 id="1-Data-Preprocessing"><a href="#1-Data-Preprocessing" class="headerlink" title="1. Data Preprocessing"></a>1. Data Preprocessing</h3><ul>
<li><p><strong>Unique: Set videoID to index and Drop duplicate data</strong></p>
<ul>
<li>Delete attributes [‘index’, ‘likes/dislikes’, ‘channelId’]</li>
</ul>
</li>
<li><p><strong>DropNA: Drop all null and meaningless values</strong></p>
<ul>
<li>Delete by row if attributes’ value is -1 in data</li>
</ul>
</li>
<li><p><strong>TimeStamp: Transfer time format to timestamp</strong></p>
<ul>
<li>2012-01-19T18:38:28.000Z -&gt; 1326902400</li>
</ul>
</li>
</ul>
<p><img src="../imgs/Data-Mining-with-Kaggle-YouTube-Videos-and-Channels-Metadata/dataPreprocessing.png" alt="dataPreprocessing.png"></p>
<h3 id="2-Calculate-Correlation"><a href="#2-Calculate-Correlation" class="headerlink" title="2. Calculate Correlation"></a>2. Calculate Correlation</h3><ul>
<li><p>Use min-max scaling to normalization</p>
</li>
<li><p>Calculate Pearson correlation coefficient correlations</p>
</li>
<li><p><strong>Correlation</strong><br>  <img src="../imgs/Data-Mining-with-Kaggle-YouTube-Videos-and-Channels-Metadata/correlation.png" alt="correlation.png"></p>
<!-- + #### Correlation Heatmap
  ![correlation_heatmap.png](images/correlation_heatmap.png) -->
</li>
<li><p><strong>Correlation Heatmap With Annotation</strong><br>  <img src="../imgs/Data-Mining-with-Kaggle-YouTube-Videos-and-Channels-Metadata/correlation_heatmap_annot.png" alt="correlation_heatmap_annot.png"></p>
</li>
</ul>
<h3 id="3-Scatter-Plot-Between-Two-Attributes"><a href="#3-Scatter-Plot-Between-Two-Attributes" class="headerlink" title="3. Scatter Plot Between Two Attributes"></a>3. Scatter Plot Between Two Attributes</h3><!-- + #### VideoViewCount and SubscriberCount
    ![videoViewCount_subscriberCount_scatter_s=5.png](images/videoViewCount_subscriberCount_scatter_s=5.png) -->

<ul>
<li><p><strong>ChannelViewCount and SubscriberCount</strong><br>  <img src="../imgs/Data-Mining-with-Kaggle-YouTube-Videos-and-Channels-Metadata/channelViewCount_subscriberCount_scatter_s=5.png" alt="channelViewCount_subscriberCount_scatter_s=5.png"></p>
<!-- + #### VideoViewCount and SubscriberCount With Correlation
  ![videoViewCount_subscriberCount_scatter_withCorr.png](images/videoViewCount_subscriberCount_scatter_withCorr.png) -->
</li>
<li><p><strong>ChannelViewCount and SubscriberCount With Correlation</strong><br>  <img src="../imgs/Data-Mining-with-Kaggle-YouTube-Videos-and-Channels-Metadata/channelViewCount_subscriberCount_scatter_withCorr.png" alt="channelViewCount_subscriberCount_scatter_withCorr.png"></p>
</li>
</ul>
<h3 id="4-Analysis-by-VideoCategory-and-Bar-Chart"><a href="#4-Analysis-by-VideoCategory-and-Bar-Chart" class="headerlink" title="4. Analysis by VideoCategory and Bar Chart"></a>4. Analysis by VideoCategory and Bar Chart</h3><ul>
<li><p>Add attribute ‘videoCategory’ by ‘videoCategoryID’</p>
</li>
<li><p>Group by VideoCategory</p>
</li>
<li><p><strong>SubscriberCount</strong><br>  <img src="../imgs/Data-Mining-with-Kaggle-YouTube-Videos-and-Channels-Metadata/subscriberCount_bar.png" alt="subscriberCount_bar.png"></p>
</li>
<li><p><strong>VideoCount</strong><br>  <img src="../imgs/Data-Mining-with-Kaggle-YouTube-Videos-and-Channels-Metadata/videoCount_bar.png" alt="videoCount_bar.png"></p>
</li>
<li><p><strong>Views/Subscribers</strong><br>  <img src="../imgs/Data-Mining-with-Kaggle-YouTube-Videos-and-Channels-Metadata/views_subscribers_bar.png" alt="views_subscribers_bar.png"></p>
</li>
<li><p><strong>SubscriberCount and VideoViewCount</strong><br>  <img src="../imgs/Data-Mining-with-Kaggle-YouTube-Videos-and-Channels-Metadata/subscriberCount_videoViewCount_bar_75.png" alt="subscriberCount_videoViewCount_bar_75.png"></p>
</li>
<li><p><strong>SubscriberCount and VideoCommentCount</strong><br>  <img src="../imgs/Data-Mining-with-Kaggle-YouTube-Videos-and-Channels-Metadata/subscriberCount_videoCommentCount_bar_75.png" alt="subscriberCount_videoCommentCount_bar_75.png"></p>
</li>
</ul>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><ul>
<li><p><strong>Draw Heatmap</strong></p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_heatmap</span>(<span class="params">data</span>):</span></span><br><span class="line">  <span class="comment"># Use minmax to normalize (value between 0 ~ 1)</span></span><br><span class="line">  normalizedDF_minmax = (data - data.<span class="built_in">min</span>()) / (data.<span class="built_in">max</span>() - data.<span class="built_in">min</span>())</span><br><span class="line">  normalizedDF_correlation = normalizedDF_minmax.corr()</span><br><span class="line">  plt.figure(figsize=(<span class="number">30</span>, <span class="number">24</span>))</span><br><span class="line">  sns.heatmap(normalizedDF_correlation, cmap=<span class="string">&#x27;RdBu_r&#x27;</span>, linewidths=<span class="number">0.5</span>, vmin=-<span class="number">1</span>, vmax=<span class="number">1</span>, annot=<span class="literal">True</span>)</span><br><span class="line">  plt.show()</span><br><span class="line"></span><br><span class="line">draw_heatmap(data)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Draw Scatter Plot</strong></p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_scatter</span>(<span class="params">data, attributeName1, attributeName2</span>):</span></span><br><span class="line">  <span class="comment"># Use minmax to normalize (value between 0 ~ 1)</span></span><br><span class="line">  attribute1_minmax = (data[attributeName1] - data[attributeName1].<span class="built_in">min</span>()) / (data[attributeName1].<span class="built_in">max</span>() - data[attributeName1].<span class="built_in">min</span>())</span><br><span class="line">  attribute2_minmax = (data[attributeName2] - data[attributeName2].<span class="built_in">min</span>()) / (data[attributeName2].<span class="built_in">max</span>() - data[attributeName2].<span class="built_in">min</span>())</span><br><span class="line">  plt.scatter(<span class="built_in">list</span>(attribute1_minmax), <span class="built_in">list</span>(attribute2_minmax), s=<span class="number">3</span>, c=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">  plt.xlabel(attributeName1)</span><br><span class="line">  plt.ylabel(attributeName2)</span><br><span class="line">  plt.show()</span><br><span class="line"></span><br><span class="line">draw_scatter(data, <span class="string">&#x27;channelViewCount&#x27;</span>, <span class="string">&#x27;subscriberCount&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Draw Scatter With Line</strong></p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_scatter_with_line</span>(<span class="params">data, attributeName1, attributeName2, x, y</span>):</span></span><br><span class="line">  <span class="comment"># Use minmax to normalize (value between 0 ~ 1)</span></span><br><span class="line">  attribute1_minmax = (data[attributeName1] - data[attributeName1].<span class="built_in">min</span>()) / (data[attributeName1].<span class="built_in">max</span>() - data[attributeName1].<span class="built_in">min</span>())</span><br><span class="line">  attribute2_minmax = (data[attributeName2] - data[attributeName2].<span class="built_in">min</span>()) / (data[attributeName2].<span class="built_in">max</span>() - data[attributeName2].<span class="built_in">min</span>())</span><br><span class="line">  plt.scatter(<span class="built_in">list</span>(attribute1_minmax), <span class="built_in">list</span>(attribute2_minmax), s=<span class="number">3</span>, c=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">  plt.plot(x, y)</span><br><span class="line">  plt.xlabel(attributeName1)</span><br><span class="line">  plt.ylabel(attributeName2)</span><br><span class="line">  plt.show()</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">1</span>); y = x</span><br><span class="line">draw_scatter_with_line(data, <span class="string">&#x27;channelViewCount&#x27;</span>, <span class="string">&#x27;subscriberCount&#x27;</span>, x, y)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Draw Scatter With Correlation</strong></p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_scatter_with_correlation</span>(<span class="params">data, attributeName1, attributeName2</span>):</span></span><br><span class="line">  <span class="comment"># Use minmax to normalize (value between 0 ~ 1)</span></span><br><span class="line">  attribute1_minmax = (data[attributeName1] - data[attributeName1].<span class="built_in">min</span>()) / (data[attributeName1].<span class="built_in">max</span>() - data[attributeName1].<span class="built_in">min</span>())</span><br><span class="line">  attribute2_minmax = (data[attributeName2] - data[attributeName2].<span class="built_in">min</span>()) / (data[attributeName2].<span class="built_in">max</span>() - data[attributeName2].<span class="built_in">min</span>())</span><br><span class="line">  df = pd.DataFrame(&#123;</span><br><span class="line">              attributeName1: <span class="built_in">list</span>(attribute1_minmax),</span><br><span class="line">              attributeName2: <span class="built_in">list</span>(attribute2_minmax)</span><br><span class="line">          &#125;)</span><br><span class="line">  sns.lmplot(x=attributeName1, y=attributeName2, data=df, line_kws=&#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;red&#x27;</span>&#125;)</span><br><span class="line">  plt.xlabel(attributeName1)</span><br><span class="line">  plt.ylabel(attributeName2)</span><br><span class="line">  plt.show()</span><br><span class="line"></span><br><span class="line">draw_scatter_with_correlation(data, <span class="string">&#x27;channelViewCount&#x27;</span>, <span class="string">&#x27;subscriberCount&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Data Mining</category>
      </categories>
      <tags>
        <tag>Data Mining</tag>
        <tag>Python</tag>
        <tag>Kaggle</tag>
        <tag>Youtube</tag>
      </tags>
  </entry>
  <entry>
    <title>內聚性與耦合性</title>
    <url>/Cohesion&amp;Coupling/</url>
    <content><![CDATA[<p>在做軟體開發時，常常會聽到<code>內聚性 (Cohesion)</code> 及<code>耦合性 (Coupling)</code>，這兩個詞，這也是在設計軟體架構常常要考慮到的事情，該如何在這兩個特性中各自取得平衡，是非常重要的一件事。</p>
<h3 id="內聚性"><a href="#內聚性" class="headerlink" title="內聚性"></a>內聚性</h3><p>內聚性簡單來說，就是在程式中，功能類似的東西或是相同用途的資料等等…，是否有放在相近的地方，和 OOP 中封裝的概念相似，一般會使用高內聚性、低內聚性來表示。比方說，將一些功能類似的函式打包成一個 class，就是一種高內聚性的表現。</p>
<p>通常會希望程式能夠有高內聚性，因為<strong>高內聚性和許多理想的軟體特性有關</strong>，包括 Robustness、Reliability、Reusability、Understandability 等等。</p>
<h3 id="耦合性"><a href="#耦合性" class="headerlink" title="耦合性"></a>耦合性</h3><p>耦合性簡單來說，就是兩個東西之間的相依性，比如兩個 class、兩個 function 等等，兩者的關係越大，耦合性就越高，一般來說，會希望兩個東西越獨立越好，因為若兩者耦合性越高，則改變其中一個對另一個造成的影響可能就越大，所以一般來說會希望<strong>在保有相同的特性下，耦合性越低越好</strong>。</p>
<h3 id="平衡與取捨"><a href="#平衡與取捨" class="headerlink" title="平衡與取捨"></a>平衡與取捨</h3><p>通常會希望整體保持高內聚、低耦合，但有時為了程式簡潔，或是設計方便，<strong>適時地降低內聚性或提高耦合性是有必要並且可以接受的</strong>。</p>
<p>比方說，一段程式碼可能在一些 functions 中都存在，可以把它拉出來獨立成一個 function，雖然這樣可能會導致 function 變的 impure，並且也會降低內聚性，但可以增加可讀性。</p>
<p>另一個例子，在某些時候為了方便會定義一些 global variable，雖然不是好習慣，可能產生沒預期的 side effect，耦合性也相對提高，但如果在可控的情況下，使用 global variable 還是會帶來一些好處。</p>
<h3 id="軟體架構的重要性"><a href="#軟體架構的重要性" class="headerlink" title="軟體架構的重要性"></a>軟體架構的重要性</h3><p>在軟體開發前先設計軟體架構非常重要，好處也非常多，以我自己的例子來說，</p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://zh.m.wikipedia.org/zh-tw/%E5%85%A7%E8%81%9A%E6%80%A7_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">内聚性（電腦科學） - 維基百科，自由的百科全書</a></p>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>還沒想好標題</title>
    <url>/Sofrware-Architecture/</url>
    <content><![CDATA[<h3 id="軟體架構"><a href="#軟體架構" class="headerlink" title="軟體架構"></a>軟體架構</h3><p>通常要開發具有一定規模或比較複雜的軟體時，都會先根據需求或規格設計架構。<br>以個人的角度而言，可以讓自己在開發時有更明確的方向，選擇框架時能考慮更全面，也會降低排除 BUG 的困難。<br>以團隊的角度而言，好的架構設計可把軟體拆分成數個可獨立運作的部分，在開發上提升效率。常見的例子是有前後端的軟體，在設計架構時可先決定資料交互的形式、API 接口等等…，接著同步開發，最後花費一些時間整合即可。</p>
<p>設計好架構後記錄的方式有很多，架構圖加上文字說明是最詳盡，只有架構圖也可以接受，若不記錄可能會產生一些問題。</p>
<h3 id="個人經驗"><a href="#個人經驗" class="headerlink" title="個人經驗"></a>個人經驗</h3><p>我自己是不喜歡記錄的，一來麻煩，再者，思考單位如果是實體，思考速度會大幅下降，同時也限縮了很多可能性，<br>就像是黏土一樣，黏土硬掉後要重新塑型比較困難，雖然可以用新的土把原本的蓋掉，但體積也會變大。</p>
<p>話雖如此，我最近卻深刻體會到沒有記錄帶來的後果。<br>現在手上有一個開發週期挺長的專案，初期程式碼規模還比較小的時候沒有體會到這個問題，但到後面規模相對大的時候，突然意識到嚴重性，<br>這個專案的需求都非常細微，因此一開始接手時無法完整的釐清所有需求及規格，都是邊開發邊修改，而我開發的時間又很間斷，一週只會開發三天，就這樣累積到中期，規模越來越大，使我在新一週開始時都會忘記想好的架構，我又懶，所以就依據新得到的需求重新思考部分架構硬寫，而每次重新思考都會有小部分差異，所以有時程式碼會隱藏一些問題，而這些問題不會在當下就表現出來，但到了某個時間就會一起爆發出來，又要花時間去修正，實在是很頭大。</p>
<p>除此之外，因為每次思考都會有一些差異，到後期架構已經變得很不清晰，這個專案程式碼撰寫的工作大部分是我，就算我自己隔一段時間來看都要花很多時間，<br>目前這個專案已經在測試階段，有時會有一些比較緊急需要修改的部分，如果我不在的話學長需要幫忙修改，學長看這支程式應該會覺得很痛苦，想想就覺得不好意思<span style='font-size:20px;'>&#128549;</span></p>
<p>如果開發週期較短而且只有自己一個人開發的話不記錄還是可以的，畢竟很省事，但如果是開發週期較長的專案還是好好記錄比較好，對自己有好處也減少給別人造成的麻煩。</p>
<p>我也不知道為什麼會想寫這篇，可能是希望自己記取教訓，但我覺得最後惰性還是會戰勝</p>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Software Architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>英雄聯盟自動輸入邀請碼程式</title>
    <url>/LOLAnniversary/</url>
    <content><![CDATA[<p><strong>我認為被鎖的機率非常非常低，但是使用這類工具還是會有一定的風險，任何後果請自行承擔，若真的很擔心建議不要使用。</strong></p>
<p>這次的英雄聯盟 8.8 週年慶活動，有輸入邀請碼可以獲得氣球兌換獎勵的活動，逛巴哈的時候看到有大神做自動輸入的程式，就也嘗試做了一個順便學習一下沒用過的套件。程式會比較大是因為用 Python 寫的，用 pyinstaller 打包。</p>
<!-- 雖然有方法可以縮小打包後的大小，但是也懶的用了。 -->

<h3 id="補充"><a href="#補充" class="headerlink" title="補充"></a>補充</h3><p>程式一開始設計時為了效率所以只從集中串的最後一頁開始爬邀請碼，執行完第一輪後其實都是在等新貼的邀請碼，一有人貼就會馬上搶，若這個資源有比較多人在搶就會導致效率變很差，如果有更好的資源來源，可以自行修改一下爬蟲的網址，由於是用正則表達式來取出邀請碼，所以只要直接抓網頁的原始碼即可，也可以不爬蟲，直接全選複製 Garena 的新聞，用一個變數儲存，取代掉第 65 行的 <code>req.text</code> 即可。</p>
<p><strong>2021/08/02 更新：</strong></p>
<p>由於一些朋友有自己貼上邀請碼的需求，所以更新了一下，新的檔案為 <a href="https://github.com/larrylai19/LOLAnniversary/releases/download/v1.0/v3.1.zip">v3.1.zip</a>，新增了選擇自己貼上邀請碼或爬蟲的選項，若要自己貼邀請碼只要在 “invitations.txt” 貼上任意包含邀請碼的文字即可。沒有號了所以沒有測試，若有問題可以留言告訴我。</p>
<h3 id="程式說明"><a href="#程式說明" class="headerlink" title="程式說明"></a>程式說明</h3><p>程式一開始會先從螢幕中搜尋圖片定位，定位時不可操作鍵盤及滑鼠，等待定位完成後就會在後台操作，可以切換到別的視窗做其他事情，但要注意不可以從工具列縮小 LOL，否則操作會卡住，直接點擊其他視窗覆蓋掉 LOL 即可。程式正常運行時工具列 LOL 的圖標會閃金色，若沒有閃表示剛才從工具列縮小 LOL 了，把 LOL 的視窗點開即可，若無法恢復則重新執行程式。</p>
<p>程式剛執行時會先去 <a href="https://forum.gamer.com.tw/C.php?bsn=17532&snA=674866&tnum=15409">這篇文章</a> 的最後一頁抓取頁面所有的邀請碼，包括文章及留言的部分，接著一一輸入，做完第一輪後會繼續抓取最後一頁的邀請碼，若之前輸入過的則不會再輸入。</p>
<p>會這樣做主要是通常前面的邀請碼都被別人輸完了，最後一頁比較有機會可以拿到氣球，第一輪做完後只會等到有新的邀請碼才會繼續輸入，由於是別人剛發上來的，通常都可以拿到氣球。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li>下載 <a href="https://drive.google.com/file/d/1oBqRLqib2ITSuvJQnCR8HXkNbE-DjPJ8/view?usp=sharing">v3.zip</a> 並解壓縮，確保程式及兩張圖片在同一個資料夾中</li>
<li>右鍵點擊 <strong>v3.exe</strong> 並選 <strong>以管理員身分執行</strong></li>
<li>開啟 LOL 並進入活動的畫面</li>
<li>等程式跳出文字後輸入延遲，可根據自己的電腦來斟酌，建議輸入 0.3 以上，若執行時有問題表示電腦無法負荷，將延遲調高即可</li>
<li>若跳出找不到圖片的錯誤則參考影片的做法截圖按鈕的圖片即可，這是由於解析度不同導致的</li>
<li>程式運行時不要從工具列縮小 LOL</li>
</ol>
<div class="video-container"><iframe src="https://www.youtube.com/embed/hkajTqx-Mu4" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<h3 id="程式流程"><a href="#程式流程" class="headerlink" title="程式流程"></a>程式流程</h3><ol>
<li>使用 pyautogui 搜圖定位按鈕的位置</li>
<li>抓取 LOL 的視窗並找出 LOL 的座標</li>
<li>從步驟 1 找到的座標及步驟 2 的座標算出按鈕的相對座標</li>
<li>抓取文章的最後一頁所有的邀請碼，並且將沒有輸入過的邀請碼儲存</li>
<li>傳送點擊及輸入的消息到 LOL 的視窗實現後台操作</li>
</ol>
<h3 id="程式原始碼"><a href="#程式原始碼" class="headerlink" title="程式原始碼"></a>程式原始碼</h3><p><a href="https://github.com/larrylai19/LOLAnniversary"><i class="fab fa-github fa-4x"></i></a></p>
<p>v1.py 為前台版，執行方式和上面差不多<br>v3.py 為後台版，也是本文章介紹的版本<br>v3.1.py 為更新後的版本，新增了可以選擇自己貼上邀請碼或是爬蟲的功能</p>
<p>沒有花時間整理程式碼，所以有一點亂。建議使用 anaconda 建一個新環境，直接執行看有缺甚麼再自己裝一下，若要修改的話用 jupyter notebook 還蠻方便的，安裝 anaconda 建好環境後會自動建立。</p>
<!-- ### 感言

會做這個腳本純粹是因為太閒，還有要收集氣球。這是一個很簡單的腳本，前台版一小時就完成了，本來用一用很快就可以了，後來想說做一下後台的順便多學習一點，找了很多資料，一開始卡在抓到 LOL 視窗後點擊的指令無法正常執行，後來將所有子句柄都嘗試發送，最後終於找到正確的句柄。

點擊完成後，輸入邀請碼的部分也花了很多心力，因為不能抓 LOL 輸入邀請碼的句柄，但後台又無法直接發送輸入字串，最後找了很多資料後決定用發送點擊鍵盤的方式來完成邀請碼的輸入。 -->

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://yanwei-liu.medium.com/pyautogui-%E4%BD%BF%E7%94%A8python%E6%93%8D%E6%8E%A7%E9%9B%BB%E8%85%A6-662cc3b18b80">PyAutoGUI : 使用Python控制電腦. 全自動化Python | by Yanwei Liu | Medium</a><br><a href="https://vimsky.com/zh-tw/examples/detail/python-method-win32gui.PostMessage.html">Python win32gui.PostMessage方法代碼示例 - 純淨天空</a><br><a href="https://www.itread01.com/content/1548550107.html">Python使用Windows剪下板 - IT閱讀</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Lightsplit 最少轉帳次數研究實作</title>
    <url>/Lightsplit/</url>
    <content><![CDATA[<p>最近和朋友使用 Lightsplit 分帳覺得很方便，其中一個功能是使用者只須在裡面以筆為單位新增所有帳務，程式就會自動計算出每個人的結餘以及最少的轉帳次數及轉帳方式。<br>一開始覺得這個功能並沒有很難，但仔細想想後發現其實不容易，閒著沒事嘗試自己研究一下並記錄此篇文章。</p>
<div class="note flat danger flat"><p>實作時偷懶只想了一些簡單測資，不保證功能完全正確</p>
</div>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p><strong>無論有多少筆帳，每個人最後的結餘只會有一個數字</strong></p>
<p> 綜觀來看，每個人都會有一個付出的金額(先付的金額總和)，以及得到的金額價值(讓別人先幫自己付)，相減即是結餘，<strong>為正表應該收到別人的轉帳，為負則應該轉帳給別人</strong></p>
</li>
<li><p><strong>使用 Minimum Cost Maximum Flow (MCMF) 找出最小轉帳次數及方式</strong></p>
<p> 想到之前上課學過 MCMF 演算法，利用結餘建立 edge，每個 edge 之 cost 表轉帳次數，感覺可以解決這個問題，便建立 MCMF 資料模型嘗試得出正確結果</p>
</li>
</ol>
<h3 id="資料轉換"><a href="#資料轉換" class="headerlink" title="資料轉換"></a>資料轉換</h3><p>以使用 Lightsplit 時做的設定可得到的資料模擬測資</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 1000 1 2 3 4</span><br><span class="line">2 500 1 2</span><br><span class="line">3 70 2 3</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一個數字 4 表群組中共有 4 人 (編號 1 ~ 4)</p>
</li>
<li><p>每筆帳務會有先付的人與金額以及平攤給誰，第二行開始以行為單位為所有帳務<br>  ex: 第一筆帳務 <code>1 1000 1 2 3 4</code> 表示 1 號先付 1000 元並平攤給 1, 2, 3, 4 號 (情境可能是 4 個人一起吃飯，其中一位先付款)</p>
</li>
</ul>
<p>總和每筆帳務可得到</p>
<table>
<thead>
<tr>
<th>人</th>
<th>付出的金額</th>
<th>得到的金額價值</th>
<th>結餘</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1000</td>
<td>500</td>
<td>500</td>
</tr>
<tr>
<td>2</td>
<td>500</td>
<td>535</td>
<td>-35</td>
</tr>
<tr>
<td>3</td>
<td>70</td>
<td>215</td>
<td>-215</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>250</td>
<td>-250</td>
</tr>
</tbody></table>
<p>建立 MCMF 的 Capacity 模型並新增 super source 及 sink，以此測資為例分別為 0 與 9 號 node<br>為了方便建邊，將每位使用者視為兩個 node 放在中間</p>
<p><img src="../imgs/Lightsplit/capacity.png" alt="capacity"></p>
<ul>
<li>若結餘為負則在 2 ~ 3 排 nodes 間建邊，表可以轉帳的金額 (如 2 號需付 35 元，則它最多可以轉給 1, 3, 4 號 35 元)</li>
<li>若結餘為正表可以收到的金額，則在 3 ~ 4 排 nodes 建邊 (如 1 號可收到 500 元)</li>
</ul>
<p>顯而易見地，也許會發生一個問題，如 2 號可能同時轉給 1 號 35 元又轉給 3 號 35 元，因此調整 super source 至使用者的 capacity 避免此問題</p>
<p><img src="../imgs/Lightsplit/fixedCapacity.png" alt="fixedCapacity"></p>
<p>將資料轉換後將其視為 MCMF 的問題去解即可</p>
<p>執行以下程式可得出結果</p>
<p><img src="../imgs/Lightsplit/result.png" alt="result"></p>
<h3 id="簡單實作"><a href="#簡單實作" class="headerlink" title="簡單實作"></a>簡單實作</h3><p>將情況簡化成每筆金額都可整除，依照以上思路簡單實作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一行為所有人數</span></span><br><span class="line"><span class="comment"># 之後每一行: 付錢的人 付錢金額 平攤給...(人編號從 1 開始)</span></span><br><span class="line"><span class="comment"># ex: 1 1000 2 3 4 -&gt; 1 先付 1000 平攤給 1, 2, 3, 4(一人 250)</span></span><br><span class="line">TEST_DATA = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">1 1000 1 2 3 4</span></span><br><span class="line"><span class="string">2 500 1 2</span></span><br><span class="line"><span class="string">3 70 2 3</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">IS_PRINT_DETAIL = <span class="literal">False</span></span><br><span class="line">PRINT_SPACE = <span class="number">9</span></span><br><span class="line">INF = <span class="built_in">int</span>(<span class="number">1e10</span>)</span><br><span class="line"></span><br><span class="line">sink = <span class="number">0</span></span><br><span class="line">totalPeople = <span class="number">0</span></span><br><span class="line">edges = []</span><br><span class="line">capacity = []</span><br><span class="line">flow = []</span><br><span class="line">cost = []</span><br><span class="line">distance = []</span><br><span class="line">parents = []</span><br><span class="line">inQueue = []</span><br><span class="line"></span><br><span class="line">balance = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_data</span>(<span class="params">totalPeople</span>):</span></span><br><span class="line">    <span class="comment"># 0: super source</span></span><br><span class="line">    <span class="comment"># totalPeople * 2 + 1: sink</span></span><br><span class="line">    arraySize = totalPeople * <span class="number">2</span> + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> edges, capacity, flow, cost, distance, parents, inQueue</span><br><span class="line">    edges = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(arraySize)]</span><br><span class="line">    capacity = [[<span class="number">0</span>] * arraySize <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(arraySize)]</span><br><span class="line">    flow = [[<span class="number">0</span>] * arraySize <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(arraySize)]</span><br><span class="line">    cost = [[<span class="number">0</span>] * arraySize <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(arraySize)]</span><br><span class="line">    distance = [<span class="number">0</span>] * arraySize</span><br><span class="line">    parents = [<span class="number">0</span>] * arraySize</span><br><span class="line">    inQueue = [<span class="literal">False</span>] * arraySize</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_input</span>(<span class="params">inputData</span>):</span></span><br><span class="line">    <span class="keyword">global</span> sink, edges, capacity, flow, cost, distance, parents, inQueue</span><br><span class="line">    <span class="keyword">global</span> totalPeople, balance</span><br><span class="line"></span><br><span class="line">    inputDataSplit = inputData.strip().split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    totalPeople = <span class="built_in">int</span>(inputDataSplit[<span class="number">0</span>])</span><br><span class="line">    sink = totalPeople * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    balance = [<span class="number">0</span>] * (totalPeople + <span class="number">1</span>)  <span class="comment"># 值為正: 最後應收回多少錢, 值為負: 最後應付出多少錢</span></span><br><span class="line">    init_data(totalPeople)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 連接 super source 至各節點</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, totalPeople + <span class="number">1</span>):</span><br><span class="line">        capacity[<span class="number">0</span>][i] = INF</span><br><span class="line"></span><br><span class="line">    <span class="comment"># cost 紀錄轉帳次數</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, totalPeople + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(totalPeople + <span class="number">1</span>, totalPeople * <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">            cost[i][j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    pay = [<span class="number">0</span>] * (totalPeople + <span class="number">1</span>)  <span class="comment"># 先付多少錢</span></span><br><span class="line">    get = [<span class="number">0</span>] * (totalPeople + <span class="number">1</span>)  <span class="comment"># 獲得價值多少錢</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> inputDataSplit[<span class="number">1</span>:]:</span><br><span class="line">        lst = line.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        p1 = <span class="built_in">int</span>(lst[<span class="number">0</span>])  <span class="comment"># 先付的人</span></span><br><span class="line">        money = <span class="built_in">int</span>(lst[<span class="number">1</span>])  <span class="comment"># 先付的金額</span></span><br><span class="line">        splitMoney = <span class="built_in">int</span>(money / (<span class="built_in">len</span>(lst) - <span class="number">2</span>))  <span class="comment"># 平攤後每個人獲得的價值(整數)</span></span><br><span class="line">        people = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, lst[<span class="number">2</span>:]))  <span class="comment"># 平攤給</span></span><br><span class="line"></span><br><span class="line">        pay[p1] += money</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> people:</span><br><span class="line">            get[p] += splitMoney</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 應收: 先付 - 獲得</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(balance)):</span><br><span class="line">        balance[i] = pay[i] - get[i]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 調整 super source 至各節點的 capacity</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, totalPeople + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> balance[i] &lt; <span class="number">0</span>:</span><br><span class="line">            capacity[<span class="number">0</span>][i] = -balance[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> IS_PRINT_DETAIL:</span><br><span class="line">        print(<span class="string">f&#x27;<span class="subst">&#123;<span class="string">&quot;pay:&quot;</span>:&gt;&#123;PRINT_SPACE&#125;</span>&#125;&#x27;</span>, pay)</span><br><span class="line">        print(<span class="string">f&#x27;<span class="subst">&#123;<span class="string">&quot;get:&quot;</span>:&gt;&#123;PRINT_SPACE&#125;</span>&#125;&#x27;</span>, get)</span><br><span class="line">        print(<span class="string">f&#x27;<span class="subst">&#123;<span class="string">&quot;balance:&quot;</span>:&gt;&#123;PRINT_SPACE&#125;</span>&#125;&#x27;</span>, balance)</span><br><span class="line">        print()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 建邊</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, totalPeople + <span class="number">1</span>):</span><br><span class="line">        edges[<span class="number">0</span>].append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> balance[i] &gt;= <span class="number">0</span>:</span><br><span class="line">            edges[i + totalPeople].append(sink)</span><br><span class="line">            capacity[i + totalPeople][sink] = balance[i]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(totalPeople + <span class="number">1</span>, totalPeople * <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i + totalPeople != j:</span><br><span class="line">                edges[i].append(j)</span><br><span class="line">                capacity[i][j] = -balance[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> IS_PRINT_DETAIL:</span><br><span class="line">        print(<span class="string">f&#x27;<span class="subst">&#123;<span class="string">&quot;capacity:&quot;</span>:&gt;&#123;PRINT_SPACE&#125;</span>&#125;&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> capacity:</span><br><span class="line">            print(<span class="string">&#x27; &#x27;</span> * PRINT_SPACE, i)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">f&#x27;<span class="subst">&#123;<span class="string">&quot;edges:&quot;</span>:&gt;&#123;PRINT_SPACE&#125;</span>&#125;&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> edges:</span><br><span class="line">            print(<span class="string">&#x27; &#x27;</span> * PRINT_SPACE, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SPFA</span>():</span></span><br><span class="line">    <span class="keyword">global</span> sink, edges, capacity, flow, cost, distance, parents, inQueue</span><br><span class="line"></span><br><span class="line">    distance = [INF] * <span class="built_in">len</span>(distance)</span><br><span class="line">    distance[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    inQueue = [<span class="literal">False</span>] * <span class="built_in">len</span>(inQueue)</span><br><span class="line"></span><br><span class="line">    que = [<span class="number">0</span>]</span><br><span class="line">    inQueue[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> que:</span><br><span class="line">        u = que.pop(<span class="number">0</span>)</span><br><span class="line">        inQueue[u] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> edges[u]:</span><br><span class="line">            <span class="keyword">if</span> capacity[u][v] &gt; flow[u][v] <span class="keyword">and</span> distance[u] + cost[u][v] &lt; distance[v]:</span><br><span class="line">                distance[v] = distance[u] + cost[u][v]</span><br><span class="line">                parents[v] = u</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> inQueue[v]:</span><br><span class="line">                    que.append(v)</span><br><span class="line">                    inQueue[v] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> flow[v][u] &gt; <span class="number">0</span> <span class="keyword">and</span> distance[u] + (-cost[v][u] &lt; distance[v]):</span><br><span class="line">                distance[v] = distance[u] + (-cost[v][u])</span><br><span class="line">                parents[v] = u</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> inQueue[v]:</span><br><span class="line">                    que.append(v)</span><br><span class="line">                    inQueue[v] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> distance[sink] != INF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">augment</span>(<span class="params">u, v, bottleNeck</span>):</span></span><br><span class="line">    <span class="keyword">global</span> parents, capacity, flow</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> v == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> bottleNeck</span><br><span class="line">    bottleNeck = augment(parents[u], u, <span class="built_in">min</span>(capacity[u][v] - flow[u][v], bottleNeck))</span><br><span class="line">    flow[u][v] += bottleNeck</span><br><span class="line">    flow[v][u] -= bottleNeck</span><br><span class="line">    <span class="keyword">return</span> bottleNeck</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MCMF</span>():</span></span><br><span class="line">    <span class="keyword">global</span> edges, capacity, flow, cost, distance, parents, inQueue, sink</span><br><span class="line">    <span class="keyword">global</span> totalPeople, balance</span><br><span class="line"></span><br><span class="line">    times = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> SPFA():</span><br><span class="line">        augment(parents[sink], sink, INF)</span><br><span class="line">        times += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, bal <span class="keyword">in</span> <span class="built_in">enumerate</span>(balance[<span class="number">1</span>:]):</span><br><span class="line">        pay, get = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> bal &lt; <span class="number">0</span>:</span><br><span class="line">            pay = -bal</span><br><span class="line">        <span class="keyword">elif</span> bal &gt; <span class="number">0</span>:</span><br><span class="line">            get = bal</span><br><span class="line">        print(<span class="string">f&#x27;<span class="subst">&#123;i + <span class="number">1</span>:<span class="number">2</span>&#125;</span> 號應付 <span class="subst">&#123;pay:<span class="number">4</span>&#125;</span> 元，應得 <span class="subst">&#123;get:<span class="number">4</span>&#125;</span> 元&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;\n最少轉帳次數:&#x27;</span>, times)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(totalPeople + <span class="number">1</span>, totalPeople * <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, totalPeople + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> flow[i][j] &lt; <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">f&#x27;<span class="subst">&#123;j:<span class="number">2</span>&#125;</span> 號需給 <span class="subst">&#123;i - totalPeople:<span class="number">2</span>&#125;</span> 號 <span class="subst">&#123;-flow[i][j]:<span class="number">4</span>&#125;</span> 元&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    process_input(TEST_DATA)</span><br><span class="line">    MCMF()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Lightsplit</tag>
      </tags>
  </entry>
  <entry>
    <title>貓毛</title>
    <url>/MaoMao/</url>
    <content><![CDATA[<p>真的貓毛了</p>
]]></content>
  </entry>
  <entry>
    <title>PUPC 2022 心得</title>
    <url>/PUPC2022/</url>
    <content><![CDATA[<p>PUPC 全名是全國私立大專校院程式競賽，英文名常常換來換去<br>比賽三人一組，每組一台電腦，入場可攜帶十張 A4 紙，可提前在單面作筆記</p>
<p>一組只有一台電腦，所以分工勢必為一人打 Code，另外兩人看題目，因為我英文能力極差，看題目效率很低，因此我們這組由我負責打 Code，但我前一天失眠，教室又很熱，整個人昏昏沉沉的，我也不知道我在寫什麼，想到什麼寫什麼</p>
<p>比賽過程和 CPE 差不多，難度我覺得比 CPE 簡單一些，可能是有隊友協助看題目，考 CPE 都得看 IO 猜題意，這次隊友把題目看得很仔細，寫起來感覺簡單不少，但有些題目還得用猜的，猜對了超開心</p>
<p>如果想增加一些個人經歷的話還蠻推薦參加這個比賽的，難度不會太高，我們沒有特別準備，拿到不錯的成績，若是有準備甚至有特別練習解題的人參加應該可以取得很厲害的成績</p>
<p>這次的台中之旅很愉快，前一天吃燒肉，一起聊天耍廢到凌晨，但我們住的旅館熱到睡不著，我們前一天只睡了兩小時左右，進了主辦學校也超熱，比賽時又熱又累不知道自己在幹嘛，結束比賽後也十分狼狽，突然下暴雨，我們都沒帶傘，又得淋雨坐車，整個人都快沒了</p>
<p>整體來說，很慶幸當時沒有嫌麻煩不參加，和朋友一起旅遊，比賽時大家都盡自己最大的努力，和朋友一起努力的過程真的很開心，謝謝大家願意陪我來，謝謝隊友 Carry 我</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>PUPC</tag>
        <tag>全國私立大專校院程式競賽</tag>
      </tags>
  </entry>
  <entry>
    <title>PyInstaller -D 檔案雜亂</title>
    <url>/PyInstaller/</url>
    <content><![CDATA[<p>在專案完成後為了方便部屬有時會有將專案打包的需求，以 Python 來說目前常用的工具為 PyInstaller。</p>
<p>PyInstaller 主要會有兩個問題，一是它會將該環境所有套件打包，造成體積龐大，這點可透過創建新的虛擬環境解決。</p>
<p>另一點，為了簡潔，一般會帶參數 <code>-F</code> 使其打包後僅為一個執行檔，但由於它會將所有套件打包在一起，造成該執行檔體積龐大，執行緩慢，所以有時會改用 <code>-D</code> 這個參數使其打包後為一個目錄，又由於它會將所有套件打包在一起，所以檔案看起來會很雜亂。</p>
<p>以目前的小專案為例，打包成一個執行檔後會長這樣</p>
<p><img src="../imgs/PyInstaller/1.png" alt="1"></p>
<p>不到千行的專案卻有 60MB</p>
<p>若打包為一個目錄的話會長這樣</p>
<p><img src="../imgs/PyInstaller/2.png" alt="2"></p>
<p>執行檔本身雖然縮小為 5MB，但整個目錄略顯雜亂，要透過設定檔調整程式時也不易直接看出。</p>
<h3 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h3><p>從 Shell Script 得到靈感，在原本的目錄加一層上級目錄，用 bat 執行原本打包好的程式，使其執行時加入變數的目錄為上級目錄，如此便可將設定檔與一些產出檔案和原程式區隔開，最後將 bat 轉為 exe 檔案即可。</p>
<p>最終看起來會像這樣，app 內放的為打包成目錄的程式</p>
<p><img src="../imgs/PyInstaller/3.png" alt="3"></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PyInstaller</tag>
      </tags>
  </entry>
  <entry>
    <title>一輩子受用無窮的三句話</title>
    <url>/3Sentences/</url>
    <content><![CDATA[<p><img src="../imgs/3sentences.jpg" alt="3sentences"></p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>是個傢伙</title>
    <url>/AGuy/</url>
    <content><![CDATA[<p><img src="../imgs/aguy.jpg" alt="wolf"></p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>馬德里不思議</title>
    <url>/AHorse/</url>
    <content><![CDATA[<p><img src="../imgs/horse.png" alt="horse"></p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>還好我不是律師</title>
    <url>/ALowyer/</url>
    <content><![CDATA[<p><img src="../imgs/alowyer.jpg" alt="ALowyer"></p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>明阿載架擱來</title>
    <url>/DeleteTomorrow/</url>
    <content><![CDATA[<p><img src="../imgs/deletetomorrow.jpg" alt="deletetomorrow"></p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>你快樂嗎？</title>
    <url>/AreYouHappy/</url>
    <content><![CDATA[<p><a href="https://ppt.cc/ft5V4x"><img src="../imgs/areyouhappy.jpg" alt="AreYouHappy"></a></p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>Do You Remember</title>
    <url>/DoYouRemember/</url>
    <content><![CDATA[<p><img src="../imgs/douremember.jpg" alt="douremember"></p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>一袋米要扛幾樓</title>
    <url>/Pain/</url>
    <content><![CDATA[<p><img src="../imgs/pain.jpg" alt="pain"></p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>絕隊無敵的傳說</title>
    <url>/Wolf/</url>
    <content><![CDATA[<p><img src="../imgs/wolf.jpg" alt="wolf"></p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>壓縮工業的極致</title>
    <url>/Zip/</url>
    <content><![CDATA[<p><img src="../imgs/zip.jpg" alt="zip"></p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>YOLOv7 on Windows (一) 建立環境與執行</title>
    <url>/YOLOv7_1/</url>
    <content><![CDATA[<h3 id="建立環境"><a href="#建立環境" class="headerlink" title="建立環境"></a>建立環境</h3><p>先用 Anaconda 建立一個乾淨的新環境</p>
<p><code>conda create --name torch python=3.9</code></p>
<p>名稱及版本都可以更改，我這邊是用 3.9</p>
<hr>
<p>接著進入環境安裝 GPU 版本的 PyTorch，也可以用 CPU 版本的，但速度慢非常多</p>
<p>安裝前先檢查 GPU 的驅動版本，可以在終端中使用 <code>nvidia-smi</code> 指令來查看驅動版本</p>
<p><img src="../imgs/YOLOv7_1/1.png" alt="nvidia-smi"></p>
<p>之後到<a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html">這個網站</a>查看符合的 CUDA 版本<br>YOLOv7 支持的 PyTorch 版本為 1.7.0 ~ 1.11.0 所以到<a href="https://pytorch.org/get-started/previous-versions/">這個網站</a>挑選適合的安裝<br>我安裝的是 1.11.0 + CUDA 11.3</p>
<p><img src="../imgs/YOLOv7_1/2.png" alt="PyTorch"></p>
<p>安裝 1.12.0 也可以執行，但是在引入模型時會有問題<br>PyTorch 比較大，需要一點時間下載<br>安裝完後在終端直接執行 Python 檢查有沒有安裝成功</p>
<p><img src="../imgs/YOLOv7_1/3.png" alt="PyTorch"></p>
<p>有看到自己的 GPU 就是成功了</p>
<hr>
<p>安裝完後就可以 clone YOLOv7<br><code>git clone https://github.com/WongKinYiu/yolov7.git</code><br>clone 完後進入資料夾，因為我們已經裝好 PyTorch 了，所以修改一下 requirements.txt<br>將 11 及 12 行註解</p>
<p><img src="../imgs/YOLOv7_1/4.png" alt="requirements"></p>
<p>之後安裝需要的套件<br><code>pip install -r requirements.txt</code></p>
<p>到這裡環境就準備好了</p>
<h3 id="執行-YOLO"><a href="#執行-YOLO" class="headerlink" title="執行 YOLO"></a>執行 YOLO</h3><p>直接執行 <code>python detect.py</code></p>
<p><img src="../imgs/YOLOv7_1/5.png" alt="run"></p>
<p>第一次執行會下載預訓練好的模型，下載好會預測放在 <code>.\inference\images</code> 的圖片，可以在 <code>.\runs\detect\exp</code> 看到預測結果</p>
<p><img src="../imgs/YOLOv7_1/6.jpg" alt="horses"></p>
<p>也可以用 –source 指定要預測的圖片或影片<br><code>python detect.py --source 圖片或影片的路徑</code></p>
<p>到這邊就算是建立好環境了，下一篇文章將會記錄如何訓練自己的資料集並進行預測</p>
]]></content>
      <categories>
        <category>YOLOv7</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>AI</tag>
        <tag>YOLOv7</tag>
        <tag>Deep Learning</tag>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>十萬火急</title>
    <url>/veryhurry/</url>
    <content><![CDATA[<p>ㄌㄩㄝ˙</p>
]]></content>
      <categories>
        <category>daily</category>
      </categories>
  </entry>
  <entry>
    <title>YOLOv7 on Windows (二) 訓練自己的資料集</title>
    <url>/YOLOv7_2/</url>
    <content><![CDATA[<h3 id="準備資料集"><a href="#準備資料集" class="headerlink" title="準備資料集"></a>準備資料集</h3><p>將標註好的資料集放在一個資料夾內並取名為 all，資料集需為 YOLO 的格式，YOLO 格式為一張圖片搭配一個 txt 檔，如果是用 labelImg 標註應該還會有一個 classes.txt 的檔案，裡面放的就是你標註的 class 名稱，我準備了 60 張圖片，只有一個 class，整個看起來會像這樣</p>
<p><img src="../imgs/YOLOv7_2/1.png" alt="folder"><br><img src="../imgs/YOLOv7_2/2.png" alt="class"></p>
<p>在 yolov7 的資料夾內建立一個資料夾取名為 mydataset，並將資料集放到裡面，<br>由於將資料分割的步驟比較繁雜，我寫了一隻程式來分割，下載<a download href="../files/splitFile.py">這隻程式</a>並放到 mydataset 的資料夾內<br>做完這一步看起來會像這樣</p>
<p><img src="../imgs/YOLOv7_2/3.png" alt="folder"></p>
<p><strong>需要注意的是資料夾的名稱必須為 all，並且裡面要有 classes.txt，若沒有請自行新增，並打上自己標註的 class 名稱</strong><br>之後直接執行並帶入要作為 validation set 的圖片數量，程式會隨機取出</p>
<p>以我來說我想要 10 張圖片作為 validation set</p>
<p><code>python splitFile.py 10</code></p>
<p>執行完後會像這樣</p>
<p><img src="../imgs/YOLOv7_2/4.png" alt="folder"></p>
<p>到這裡就完成資料集的準備了 (我這邊沒有準備 test set，如果想要的話按照格式新增即可)</p>
<h3 id="建立配置檔"><a href="#建立配置檔" class="headerlink" title="建立配置檔"></a>建立配置檔</h3><p>我們已經將資料準備好了，接下來要建立一些配置檔讓 YOLO 知道我們的資料在哪裡</p>
<p>先到 <code>.\cfg\training\</code>，複製 yolov7.yaml 並改名為 yolov7_custom.yaml (這裡複製 yolov7.yaml 是因為準備用 yolov7.pt 作為預訓練的模型，如果選擇其他模型就複製那個 yaml)<br>開啟 yolov7_custom.yaml 並將第二行的 80 改為你資料集的 class 數量，以我的來說是 1</p>
<p><img src="../imgs/YOLOv7_2/5.png" alt="yolov7_custom.yaml"></p>
<p>接著到 <code>.\data\</code> 新增一個文字檔並改名為 mydata.yaml，並貼上下面的內容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># train and val data as 1) directory: path&#x2F;images&#x2F;, 2) file: path&#x2F;images.txt, or 3) list: [path1&#x2F;images&#x2F;, path2&#x2F;images&#x2F;]</span><br><span class="line">train: .&#x2F;mydataset&#x2F;train.txt</span><br><span class="line">val: .&#x2F;mydataset&#x2F;val.txt</span><br><span class="line">test:</span><br><span class="line"></span><br><span class="line"># number of classes</span><br><span class="line">nc: 1</span><br><span class="line"></span><br><span class="line"># class names</span><br><span class="line">names: [ &#39;ball&#39; ]</span><br></pre></td></tr></table></figure>

<p>如果你前面和我的命名都相同，只要修改 nc 及 names 即可，nc 一樣為你資料集的 class 數量，names 為你 class 對應的名稱 (若有多個 class 需注意順序)，否則 train 跟 val 的路徑請修改成你的路徑，若有準備 test set 也記得輸入路徑</p>
<p>到這裡所有的準備就都完成了，可以開始訓練模型了!</p>
<h3 id="訓練模型"><a href="#訓練模型" class="headerlink" title="訓練模型"></a>訓練模型</h3><p>回到 yolov7 的路徑下</p>
<p><code>python train.py --workers 8 --device 0 --batch-size 8 --data .\data\mydata.yaml --img 640 640 --cfg .\cfg\training\yolov7_custom.yaml --hyp .\data\hyp.scratch.p5.yaml --weights .\yolov7.pt</code></p>
<ul>
<li>batch-size: 根據顯卡的內存來設置，一般為 8 的倍數，數值越大佔用內存越多</li>
<li>img: 兩個數字，依序代表訓練時壓縮圖片的 size 和預測時壓縮圖片的 size，簡單來說它會將你的圖片壓成該 size 並做訓練/預測</li>
<li>data: 指定剛剛配置的檔案</li>
<li>cfg: 指定剛剛配置的檔案</li>
<li>weights: 指定預訓練的模型 (也可換成其他官方提供的模型)</li>
</ul>
<p>根據自己的需求修改參數，若有修改其他參數的需求可執行 <code>python train.py help</code> 查看</p>
<p><img src="../imgs/YOLOv7_2/6.png" alt="help"></p>
<p>修改完後直接執行就開始訓練了，訓練時間受電腦性能及資料集大小影響，我 60 張照片，300 epochs 差不多訓練 20 分鐘左右</p>
<p>訓練完成後可到 <code>.\runs\train\exp</code> 查看訓練的成果，這裡會記錄訓練過程</p>
<p><img src="../imgs/YOLOv7_2/7.png" alt="folder"></p>
<p>一般來說看 results.png 即可</p>
<p><img src="../imgs/YOLOv7_2/8.png" alt="result"></p>
<p>若有正常訓練的話 Precision 應該會越來越高</p>
<p>到這裡就訓練成功了，訓練好的權重位於 <code>.\runs\train\exp\weights\best.pt</code></p>
<h3 id="測試模型"><a href="#測試模型" class="headerlink" title="測試模型"></a>測試模型</h3><p>回到 yolov7 的路徑下執行</p>
<p><code>python detect.py --weights 權重路徑 --source 要偵測的圖片或影片</code></p>
<p><img src="../imgs/YOLOv7_2/9.png" alt="detect"></p>
<p>預測的結果一樣會在 <code>.\runs\detect\exp</code> (若執行過預測的話 exp 會帶一個數字，數字最大的就是最新的結果)</p>
<p><img src="../imgs/YOLOv7_2/10.png" alt="result"></p>
<p>可以看出雖然只有 50 張圖片做訓練，效果還是很不錯的，但也是因為場景較單純</p>
<p>下一篇文章將討論深度學習物件偵測與 FPS 遊戲的關係，這也是為甚麼我準備 aimlab 的資料來做訓練的原因</p>
]]></content>
      <categories>
        <category>YOLOv7</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>AI</tag>
        <tag>YOLOv7</tag>
        <tag>Deep Learning</tag>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>YOLOv7 on Windows (四) 引用模型與自瞄實現代碼</title>
    <url>/YOLOv7_4/</url>
    <content><![CDATA[<p>要將訓練好的模型實現自瞄我分為以下步驟</p>
<ol>
<li>引入模型</li>
<li>擷取螢幕截圖</li>
<li>預測物體位置並取得中心座標</li>
<li>取得鼠標移動 offset</li>
<li>微調 offset</li>
<li>移動鼠標並射擊</li>
</ol>
<p>以下將以 Aimlab Gridshot 為例實作</p>
<h3 id="前置準備"><a href="#前置準備" class="headerlink" title="前置準備"></a>前置準備</h3><p>想要引入模型須先準備一些依賴</p>
<ul>
<li><p>hubconf.py<br>  引入模型的依賴文件，可於<a href="https://github.com/WongKinYiu/yolov7/blob/main/hubconf.py">這裡</a>下載，似乎也可直接在線調用</p>
</li>
<li><p>models、utils<br>  直接複製 YOLOv7 目錄中的 models、utils 兩個資料夾即可</p>
</li>
<li><p>訓練好的模型</p>
</li>
</ul>
<p>所有檔案放入同一目錄</p>
<p><img src="../imgs/YOLOv7_4/1.png" alt="folder"></p>
<p>best.pt 為訓練好的模型，以下將解釋實現步驟</p>
<h3 id="import-與設定參數"><a href="#import-與設定參數" class="headerlink" title="import 與設定參數"></a>import 與設定參數</h3><p>根據自己的配置設定參數，延遲根據電腦配置設定，可實際執行不斷調整至合適的延遲</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> win32api</span><br><span class="line"><span class="keyword">import</span> win32con</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># data setting</span></span><br><span class="line">GAME_WIDTH = <span class="number">1920</span></span><br><span class="line">GAME_HEIGHT = <span class="number">1080</span></span><br><span class="line"></span><br><span class="line">IMG_PATH = <span class="string">&#x27;screenshot.bmp&#x27;</span></span><br><span class="line"></span><br><span class="line">HUBCONF_FOLDER_PATH = <span class="string">r&#x27;.&#x27;</span></span><br><span class="line">MODEL_PATH = <span class="string">&#x27;best.pt&#x27;</span></span><br><span class="line">CONFIDENCE_THRESHOLD = <span class="number">0.4</span></span><br><span class="line"></span><br><span class="line">MOVE_DELAY1 = <span class="number">0.049</span></span><br><span class="line">MOVE_DELAY2 = <span class="number">0.033</span></span><br><span class="line">ONE_SHOT_DELAY = <span class="number">0.001</span></span><br></pre></td></tr></table></figure>

<h3 id="引入模型"><a href="#引入模型" class="headerlink" title="引入模型"></a>引入模型</h3><p>使用 torch.hub.load 引入模型，須搭配 hubconf.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># init model</span></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line">model = torch.hub.load(HUBCONF_FOLDER_PATH, <span class="string">&#x27;custom&#x27;</span>, MODEL_PATH,</span><br><span class="line">                       source=<span class="string">&#x27;local&#x27;</span>, force_reload=<span class="literal">False</span>)</span><br><span class="line">model = model.to(device)</span><br></pre></td></tr></table></figure>

<h3 id="擷取螢幕截圖"><a href="#擷取螢幕截圖" class="headerlink" title="擷取螢幕截圖"></a>擷取螢幕截圖</h3><p>在 Windows 下利用 PyQt 截圖是最快的，因此使用 PyQt 擷取螢幕</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">screenshot</span>(<span class="params">screen, img_path</span>):</span></span><br><span class="line">    img = screen.grabWindow(<span class="number">0</span>).toImage()</span><br><span class="line">    img.save(img_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># init PyQt</span></span><br><span class="line">app = QApplication(sys.argv)</span><br><span class="line">screen = QApplication.primaryScreen()</span><br><span class="line"></span><br><span class="line">screenshot(screen, IMG_PATH)</span><br></pre></td></tr></table></figure>

<h3 id="預測物體位置並取得中心座標"><a href="#預測物體位置並取得中心座標" class="headerlink" title="預測物體位置並取得中心座標"></a>預測物體位置並取得中心座標</h3><p>將圖片送入模型，取得預測的四點座標及信心值<br>再根據設定的閾值將信心值較低的預測排除<br>最後以四點座標算出中心座標</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inference_by_image</span>(<span class="params">model, img_path</span>):</span></span><br><span class="line">    results = model(img_path)</span><br><span class="line">    results_pandas = results.pandas()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># box coordinates</span></span><br><span class="line">    x_mins = results_pandas.xyxy[<span class="number">0</span>][<span class="string">&#x27;xmin&#x27;</span>]</span><br><span class="line">    x_maxs = results_pandas.xyxy[<span class="number">0</span>][<span class="string">&#x27;xmax&#x27;</span>]</span><br><span class="line">    y_mins = results_pandas.xyxy[<span class="number">0</span>][<span class="string">&#x27;ymin&#x27;</span>]</span><br><span class="line">    y_maxs = results_pandas.xyxy[<span class="number">0</span>][<span class="string">&#x27;ymax&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    confidences = results_pandas.xyxy[<span class="number">0</span>][<span class="string">&#x27;confidence&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x_mins, x_maxs, y_mins, y_maxs, confidences</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_points_by_threshold</span>(<span class="params">zip_object, threshold</span>):</span></span><br><span class="line">    points = []</span><br><span class="line">    <span class="keyword">for</span> x_min, x_max, y_min, y_max, conf <span class="keyword">in</span> zip_object:</span><br><span class="line">        <span class="keyword">if</span> conf &gt; threshold:</span><br><span class="line">            points.append([<span class="built_in">int</span>(x_min), <span class="built_in">int</span>(x_max), <span class="built_in">int</span>(y_min), <span class="built_in">int</span>(y_max)])</span><br><span class="line">    <span class="keyword">return</span> points</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_center_pos</span>(<span class="params">points</span>):</span></span><br><span class="line">    center_pos = []</span><br><span class="line">    <span class="keyword">for</span> point <span class="keyword">in</span> points:</span><br><span class="line">        x_center = <span class="built_in">int</span>(point[<span class="number">1</span>] - (point[<span class="number">1</span>] - point[<span class="number">0</span>]) // <span class="number">2</span>)</span><br><span class="line">        y_center = <span class="built_in">int</span>(point[<span class="number">3</span>] - (point[<span class="number">3</span>] - point[<span class="number">2</span>]) // <span class="number">2</span>)</span><br><span class="line">        center_pos.append([x_center, y_center])</span><br><span class="line">    <span class="keyword">return</span> center_pos</span><br></pre></td></tr></table></figure>

<h3 id="取得鼠標移動-offset"><a href="#取得鼠標移動-offset" class="headerlink" title="取得鼠標移動 offset"></a>取得鼠標移動 offset</h3><p>根據遊戲解析度算出鼠標從螢幕中心到物體中心需要移動的 offset</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_move_offsets</span>(<span class="params">center_pos, game_width, game_height</span>):</span></span><br><span class="line">    move_offsets = []</span><br><span class="line">    <span class="keyword">for</span> center <span class="keyword">in</span> center_pos:</span><br><span class="line">        x_offset = <span class="built_in">int</span>(center[<span class="number">0</span>] - game_width // <span class="number">2</span>)</span><br><span class="line">        y_offset = <span class="built_in">int</span>(center[<span class="number">1</span>] - game_height // <span class="number">2</span>)</span><br><span class="line">        move_offsets.append([x_offset, y_offset])</span><br><span class="line">    <span class="keyword">return</span> move_offsets</span><br></pre></td></tr></table></figure>

<h3 id="微調-offset"><a href="#微調-offset" class="headerlink" title="微調 offset"></a>微調 offset</h3><p>依據遊戲解析度、滑鼠靈敏度微調 offset<br>以下是根據我的設備來調整，每個人須做的調整可能不一</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fine_tuning</span>(<span class="params">x_offset, y_offset</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x_offset &gt; <span class="number">0</span>:</span><br><span class="line">        x_offset += <span class="number">43</span></span><br><span class="line">    <span class="keyword">if</span> y_offset &gt; <span class="number">0</span>:</span><br><span class="line">        y_offset += <span class="number">44</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> x_offset &lt; <span class="number">0</span>:</span><br><span class="line">        x_offset -= <span class="number">37</span></span><br><span class="line">    <span class="keyword">if</span> y_offset &lt; <span class="number">0</span>:</span><br><span class="line">        y_offset -= <span class="number">44</span></span><br><span class="line">    <span class="keyword">if</span> y_offset &lt; -<span class="number">200</span>:</span><br><span class="line">        y_offset -= <span class="number">45</span></span><br><span class="line">    <span class="keyword">elif</span> y_offset &lt; -<span class="number">150</span>:</span><br><span class="line">        y_offset -= <span class="number">30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x_offset, y_offset</span><br></pre></td></tr></table></figure>

<h3 id="移動鼠標並射擊"><a href="#移動鼠標並射擊" class="headerlink" title="移動鼠標並射擊"></a>移動鼠標並射擊</h3><p>調用 win32api 實現<br>移動 -&gt; 射擊 -&gt; 回到原本位置<br>須加入延遲否則會造成未移動或未射擊等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move_and_click_by_offsets</span>(<span class="params">x_offset, y_offset, move_delay1, move_delay2</span>):</span></span><br><span class="line">    win32api.mouse_event(win32con.MOUSEEVENTF_MOVE, x_offset, y_offset, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    time.sleep(move_delay1)</span><br><span class="line">    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    time.sleep(move_delay2)</span><br><span class="line">    win32api.mouse_event(win32con.MOUSEEVENTF_MOVE, -x_offset, -y_offset, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="完整程式碼"><a href="#完整程式碼" class="headerlink" title="完整程式碼"></a>完整程式碼</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> win32api</span><br><span class="line"><span class="keyword">import</span> win32con</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># data setting</span></span><br><span class="line">GAME_WIDTH = <span class="number">1920</span></span><br><span class="line">GAME_HEIGHT = <span class="number">1080</span></span><br><span class="line"></span><br><span class="line">IMG_PATH = <span class="string">&#x27;screenshot.bmp&#x27;</span></span><br><span class="line"></span><br><span class="line">HUBCONF_FOLDER_PATH = <span class="string">r&#x27;.&#x27;</span></span><br><span class="line">MODEL_PATH = <span class="string">&#x27;best.pt&#x27;</span></span><br><span class="line">CONFIDENCE_THRESHOLD = <span class="number">0.4</span></span><br><span class="line"></span><br><span class="line">MOVE_DELAY1 = <span class="number">0.049</span></span><br><span class="line">MOVE_DELAY2 = <span class="number">0.033</span></span><br><span class="line">ONE_SHOT_DELAY = <span class="number">0.001</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">screenshot</span>(<span class="params">screen, img_path</span>):</span></span><br><span class="line">    img = screen.grabWindow(<span class="number">0</span>).toImage()</span><br><span class="line">    img.save(img_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inference_by_image</span>(<span class="params">model, img_path</span>):</span></span><br><span class="line">    results = model(img_path)</span><br><span class="line">    results_pandas = results.pandas()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># box coordinates</span></span><br><span class="line">    x_mins = results_pandas.xyxy[<span class="number">0</span>][<span class="string">&#x27;xmin&#x27;</span>]</span><br><span class="line">    x_maxs = results_pandas.xyxy[<span class="number">0</span>][<span class="string">&#x27;xmax&#x27;</span>]</span><br><span class="line">    y_mins = results_pandas.xyxy[<span class="number">0</span>][<span class="string">&#x27;ymin&#x27;</span>]</span><br><span class="line">    y_maxs = results_pandas.xyxy[<span class="number">0</span>][<span class="string">&#x27;ymax&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    confidences = results_pandas.xyxy[<span class="number">0</span>][<span class="string">&#x27;confidence&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x_mins, x_maxs, y_mins, y_maxs, confidences</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_points_by_threshold</span>(<span class="params">zip_object, threshold</span>):</span></span><br><span class="line">    points = []</span><br><span class="line">    <span class="keyword">for</span> x_min, x_max, y_min, y_max, conf <span class="keyword">in</span> zip_object:</span><br><span class="line">        <span class="keyword">if</span> conf &gt; threshold:</span><br><span class="line">            points.append([<span class="built_in">int</span>(x_min), <span class="built_in">int</span>(x_max), <span class="built_in">int</span>(y_min), <span class="built_in">int</span>(y_max)])</span><br><span class="line">    <span class="keyword">return</span> points</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_center_pos</span>(<span class="params">points</span>):</span></span><br><span class="line">    center_pos = []</span><br><span class="line">    <span class="keyword">for</span> point <span class="keyword">in</span> points:</span><br><span class="line">        x_center = <span class="built_in">int</span>(point[<span class="number">1</span>] - (point[<span class="number">1</span>] - point[<span class="number">0</span>]) // <span class="number">2</span>)</span><br><span class="line">        y_center = <span class="built_in">int</span>(point[<span class="number">3</span>] - (point[<span class="number">3</span>] - point[<span class="number">2</span>]) // <span class="number">2</span>)</span><br><span class="line">        center_pos.append([x_center, y_center])</span><br><span class="line">    <span class="keyword">return</span> center_pos</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_move_offsets</span>(<span class="params">center_pos, game_width, game_height</span>):</span></span><br><span class="line">    move_offsets = []</span><br><span class="line">    <span class="keyword">for</span> center <span class="keyword">in</span> center_pos:</span><br><span class="line">        x_offset = <span class="built_in">int</span>(center[<span class="number">0</span>] - game_width // <span class="number">2</span>)</span><br><span class="line">        y_offset = <span class="built_in">int</span>(center[<span class="number">1</span>] - game_height // <span class="number">2</span>)</span><br><span class="line">        move_offsets.append([x_offset, y_offset])</span><br><span class="line">    <span class="keyword">return</span> move_offsets</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fine_tuning</span>(<span class="params">x_offset, y_offset</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x_offset &gt; <span class="number">0</span>:</span><br><span class="line">        x_offset += <span class="number">43</span></span><br><span class="line">    <span class="keyword">if</span> y_offset &gt; <span class="number">0</span>:</span><br><span class="line">        y_offset += <span class="number">44</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> x_offset &lt; <span class="number">0</span>:</span><br><span class="line">        x_offset -= <span class="number">37</span></span><br><span class="line">    <span class="keyword">if</span> y_offset &lt; <span class="number">0</span>:</span><br><span class="line">        y_offset -= <span class="number">44</span></span><br><span class="line">    <span class="keyword">if</span> y_offset &lt; -<span class="number">200</span>:</span><br><span class="line">        y_offset -= <span class="number">45</span></span><br><span class="line">    <span class="keyword">elif</span> y_offset &lt; -<span class="number">150</span>:</span><br><span class="line">        y_offset -= <span class="number">30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x_offset, y_offset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move_and_click_by_offsets</span>(<span class="params">x_offset, y_offset, move_delay1, move_delay2</span>):</span></span><br><span class="line">    win32api.mouse_event(win32con.MOUSEEVENTF_MOVE, x_offset, y_offset, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    time.sleep(move_delay1)</span><br><span class="line">    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    time.sleep(move_delay2)</span><br><span class="line">    win32api.mouse_event(win32con.MOUSEEVENTF_MOVE, -x_offset, -y_offset, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># init model</span></span><br><span class="line">    device = torch.device(<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line">    model = torch.hub.load(HUBCONF_FOLDER_PATH, <span class="string">&#x27;custom&#x27;</span>, MODEL_PATH,</span><br><span class="line">                           source=<span class="string">&#x27;local&#x27;</span>, force_reload=<span class="literal">False</span>)</span><br><span class="line">    model = model.to(device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># init PyQt</span></span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    screen = QApplication.primaryScreen()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># inference and move to shot</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        screenshot(screen, IMG_PATH)</span><br><span class="line">        x_mins, x_maxs, y_mins, y_maxs, confidences = inference_by_image(model, IMG_PATH)</span><br><span class="line">        points = get_points_by_threshold(<span class="built_in">zip</span>(x_mins, x_maxs, y_mins, y_maxs, confidences),</span><br><span class="line">                                         CONFIDENCE_THRESHOLD)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(points) == <span class="number">3</span>:</span><br><span class="line">            center_pos = get_center_pos(points)</span><br><span class="line">            move_offsets = get_move_offsets(center_pos, GAME_WIDTH, GAME_HEIGHT)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> x_offset, y_offset <span class="keyword">in</span> move_offsets:</span><br><span class="line">                x_offset, y_offset = fine_tuning(x_offset, y_offset)</span><br><span class="line">                move_and_click_by_offsets(x_offset, y_offset, MOVE_DELAY1, MOVE_DELAY2)</span><br><span class="line">                time.sleep(ONE_SHOT_DELAY)   </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h3><p>任何預測物體點擊的任務都可依此方法實現，在可使用絕對移動的情況下會更容易，可省去微調座標的步驟，鼠標移動改調用絕對移動即可</p>
]]></content>
      <categories>
        <category>YOLOv7</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>AI</tag>
        <tag>YOLOv7</tag>
        <tag>Deep Learning</tag>
        <tag>Anaconda</tag>
        <tag>FPS</tag>
      </tags>
  </entry>
  <entry>
    <title>YOLOv7 on Windows (三) AI 自瞄實現原理與危害</title>
    <url>/YOLOv7_3/</url>
    <content><![CDATA[<p>隨著硬體計算能力和演算法的進步，AI 自瞄漸漸浮現出來，我第一次聽到這個詞是在去年，正好前幾天看到 YOLOv7 推出的消息，就很好奇像我這種沒有自己訓練過模型，對於深度學習也沒什麼概念的人，多久時間能做出來。雖然製作過程中踩了不少坑，成果還是很令我滿意的。</p>
<h3 id="外掛原理"><a href="#外掛原理" class="headerlink" title="外掛原理"></a>外掛原理</h3><p>在繼續今天的主題前，先解釋一下大部分遊戲外掛運作的原理</p>
<p>程式在執行時都會被載入到記憶體中，遊戲也不例外，當遊戲執行時，遊戲中出現的各種數據都以二進制的方式儲存在記憶體中，包含程式碼也是<br>因此，讀取記憶體並修改內容是大部分遊戲外掛的原理，通常會有幾個 base address，將其值加上不同的偏移量便可得到各種數據，當然，程式每次被載入時在記憶體中的位置是不固定的，但目前都是採用虛擬記憶體的技術，使得 base address 是固定的，如果遊戲沒有更新的話，基本上找到的 base address 都不會變</p>
<p>手法上來說，一般會挑選一些較固定可控的數據，透過其 address 往上找 base address，大部分 address 都是 base address 的值經過好幾次偏移得到的，這非常考驗能力和經驗，對於組合語言也要有一定的認識，逆向工程本就不是容易的事</p>
<p>找到 base address 及各種數據的偏移後，能做的事情就非常多了，可以直接讀寫數據，更進階的話，觀察遊戲內的一些觸發事件，找到處理事件的組合語言，利用工具修改就可以達到許多不可思議的功能</p>
<p>舉例來說，敵對子彈打到角色上會觸發事件，在該事件使人物扣血，那就可以利用血量的 address，找到哪裡改變了這個 address 的值，進而找到該部分的組合語言，又如前述，程式碼也是在記憶體中的，修改組合語言後程式碼在記憶體內的值也會修改，因此在遊戲執行時直接修改該位置的值即可達成修改組合語言的目的，比方說可以讓子彈打到角色身上不扣血等等，基本上大部分想的到的功能都可依此想法實做出來</p>
<p>而基於這種方式實現的自瞄比較單純，只要取得敵人位置，計算相對位置後模擬滑鼠訊號移動射擊即可</p>
<h3 id="AI-自瞄"><a href="#AI-自瞄" class="headerlink" title="AI 自瞄"></a>AI 自瞄</h3><p>AI 自瞄的原理基本上和傳統自瞄原理是相同的，只是原本透過讀取記憶體取得敵人位置的步驟改成辨識圖片來定位敵人<br>雖然看起來只取代了一個步驟，但其實省去很多麻煩，就算先不考慮後續過偵測的問題，光是要找 address 就要花很大的力氣，並且通常隨遊戲更新，address 也會改變，更別說讀寫記憶體是很容易被偵測出來的，遊戲常常會崩潰，帳號很容易被鎖<br>而 AI 自瞄就很好的避免掉這些困難，而且訓練好的模型也不太需要更新</p>
<p>接下來先看一下基於 YOLOv7 實現的自瞄效果如何</p>
<h3 id="基於-YOLOv7-自瞄-Demo"><a href="#基於-YOLOv7-自瞄-Demo" class="headerlink" title="基於 YOLOv7 自瞄 Demo"></a>基於 YOLOv7 自瞄 Demo</h3><div class="note flat danger flat"><p>是在離線模式下 Demo 的，分數並不會上排行榜<br>這系列文章僅供學習研究之用，用於其他用途，任何後果請自行承擔</p>
</div>

<div class="video-container"><iframe src="https://www.youtube.com/embed/WW09virndjs" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<p>以我看到的數據，高手差不多 7 ~ 10 萬，職業選手差不多 11 ~ 13 萬左右，也有特意練習的人能打出更高的分數，可以看出效果是非常好的<br>並且受限於我的硬體性能和保持影片觀看性，我加了一些延遲，相信如果優化一下還能取得更高的分數</p>
<h3 id="製作過程"><a href="#製作過程" class="headerlink" title="製作過程"></a>製作過程</h3><p>上面展示的成果，研究加實作的時間不到兩天，只使用 50 張圖片做訓練，相較於傳統逆向開發的外掛，利用 AI 完成自瞄難度是非常低的，我會將實現的方式分為幾個步驟</p>
<ul>
<li><p><strong>製作模型</strong><br>  基本上製作模型是沒有任何難度的，花一些時間了解參數的意義及影響，標註好圖片，就可以直接產出模型了，並且訓練好後除非遊戲新增人物或多了一些影響判斷的東西，否則是不需要更改的</p>
<p>  甚至若沒有要求的話，用官方提供的模型就可以辨識出人物了，而一些場景較單純的遊戲，只需要極少的資料就可以有不錯的預測效果，像我這次選擇的遊戲，在標註好 10 張圖片時我有先訓練測試，效果其實和目前 50 張圖片訓練出來的相差無幾</p>
</li>
<li><p><strong>引入模型並預測</strong><br>  製作好模型後，就可以在程式中載入自己的模型，遊戲過程中利用螢幕截圖的方式將圖片送進模型預測，就可以取得畫面上敵人的位置了</p>
</li>
<li><p><strong>移動滑鼠射擊</strong><br>  這步驟也是最困難的，雖然已經取得了敵人的位置，但在 FPS 遊戲中是不支持絕對移動的，只能使用相對移動<br>  使用相對移動的話要考慮的事情就非常多了，圖片和遊戲解析度、遊戲滑鼠靈敏度、系統靈敏度等等<br>  這也在我這次開發過程中佔用最多時間，需要不斷嘗試，微調移動參數才能達到好的效果</p>
</li>
</ul>
<h3 id="對於-FPS-遊戲的危害"><a href="#對於-FPS-遊戲的危害" class="headerlink" title="對於 FPS 遊戲的危害"></a>對於 FPS 遊戲的危害</h3><p>如前述，傳統遊戲外掛大部分都要讀取記憶體，而目前也有許多不錯的應對方法，但基於物件偵測的自瞄不需要對遊戲本身動任何手腳，這就使得要用非人工的方法反制變得非常困難，如果加入一些不穩定因素，人工辨別也會有一點難度。更極端一點，將遊戲畫面擷取下來，在其他主機做計算，並透過物理方式移動滑鼠，要偵測外掛的難度又更高，連透過特徵碼判斷的方式也會失效。並且根據我的經驗，逆向開發的外掛花費的時間得是好幾倍以上，更別說模型訓練好後在一些遊戲是可以共用的</p>
<p>AI 自瞄的缺點應該就是標註圖片比較花時間及性能要求較高，除此之外優點很大程度上大過缺點，對於 FPS 遊戲的危害絕對是非常大的</p>
]]></content>
      <categories>
        <category>YOLOv7</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>AI</tag>
        <tag>YOLOv7</tag>
        <tag>Deep Learning</tag>
        <tag>Anaconda</tag>
        <tag>FPS</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10003 解題紀錄</title>
    <url>/UVa-10003/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=944">UVa - 10003 - Cutting Sticks</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>有一個可以切割木頭的工作台，若切割長度為 l 的木頭則需要消耗成本 l，且只能切割一個點，給一個木頭的長度及一些切割點，求將所有切割點都切割所需要的最小總成本。</p>
<span id="more"></span>

<p><strong>Input：</strong> 每組測資第一個整數為 <code>l</code>，為要切割的木頭總長度，若為 0 表結束。後面一個整數 <code>n</code>，表有 <code>n</code> 個切割點，後面 <code>n</code> 個整數為切割點距離起始點的長度。</p>
<p><strong>Output：</strong> 輸出將所有切割點都切割後的最小成本。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p><strong>我國文不太好，這題不知道怎麼用文字解釋，其實我也看不懂我在寫啥，建議直接看<a href="https://ppt.cc/fZFwfx">這篇</a>比較快。</strong></p>
<p>動態規劃題。</p>
<p>先讀取測資，使用 <code>cut</code> 數組儲存所有切割點，並將 <code>l</code> 放在最後面，0 放在最前面，為了方便，先在這裡將 <code>n + 1</code>。</p>
<p>定義 <code>dp[i][j]</code> 表切割 <code>切割點 i ( cut[i] )</code> 及 <code>切割點 j ( cut[j] )</code> 中所有切割點的最小花費。</p>
<p>核心概念為，先從最小塊的木頭開始切割，找出最小塊的木頭需要消耗的成本，以此來算出大塊的木頭需要消耗的成本，將程式碼具體化來說，以 Sample I/O 的第一組測資舉例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line">3</span><br><span class="line">25 50 75</span><br><span class="line">cut[] &#x3D; &#123; 0, 25, 50, 75, 100 &#125;</span><br></pre></td></tr></table></figure>

<p>一開始木頭的長度為 100，成本為 100，若第一刀在 50 的地方切割，則</p>
<ul>
<li><p><strong>總成本 = ( 0 ~ 50 的木頭完全切割需要的最小成本 ) + ( 50 ~ 100 的木頭完全切割需要的最小成本 ) + ( 100 - 0 )</strong><br>dp[0][4] = dp[0][2] + dp[2][4] + ( cut[4] - cut[0] )</p>
</li>
<li><p><strong>0 ~ 50 的木頭完全切割需要的最小成本 = ( 0 ~ 25 的木頭完全切割需要的最小成本 ) + ( 25 ~ 50 的木頭完全切割需要的最小成本 ) + ( 50 - 0 )</strong><br>dp[0][2] = dp[0][1] + dp[1][2] + ( cut[2] - cut[0] )</p>
</li>
<li><p><strong>50 ~ 100 的木頭完全切割需要的最小成本 = ( 0 ~ 25 的木頭完全切割需要的最小成本 ) + ( 25 ~ 50 的木頭完全切割需要的最小成本 ) + ( 100 - 50 )</strong><br>dp[2][4] = dp[2][3] + dp[3][4] + ( cut[4] - cut[2] )</p>
</li>
<li><p><strong>0 ~ 25 的木頭完全切割需要的最小成本 = 0</strong></p>
</li>
<li><p><strong>25 ~ 50 的木頭完全切割需要的最小成本 = 0</strong></p>
</li>
</ul>
<p>雖然想法是從上往下，但實際計算的時候需要從下往上計算，簡單來說，就是從小塊的木頭開始枚舉需要的成本，之後推到大塊的木頭，剩下的就看程式碼吧。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fZFwfx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l, n;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">52</span>][<span class="number">52</span>]; <span class="comment">// dp[i][j] 表切割 i 及 j 中所有切割點的最小花費</span></span><br><span class="line"><span class="keyword">int</span> cut[<span class="number">52</span>];    <span class="comment">// 木頭切割點</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    cut[++n] = l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="built_in">cin</span> &gt;&gt; cut[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// args:</span></span><br><span class="line">    <span class="comment">// w -&gt; wide  枚舉的區間寬度</span></span><br><span class="line">    <span class="comment">// l -&gt; left  左端點</span></span><br><span class="line">    <span class="comment">// r -&gt; right 右端點</span></span><br><span class="line">    <span class="comment">// m -&gt; mid   中間</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">2</span>; w &lt;= n; ++w) <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; n - <span class="number">1</span>; ++l)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> r = l + w;</span><br><span class="line">        <span class="keyword">if</span> (r &gt; n) <span class="keyword">break</span>;</span><br><span class="line">        dp[l][r] = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = l + <span class="number">1</span>; m &lt; r; ++m)</span><br><span class="line">            dp[l][r] = min(dp[l][m] + dp[m][r] + cut[r] - cut[l], dp[l][r]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The minimum cutting is &quot;</span> &lt;&lt; dp[<span class="number">0</span>][n] &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; l &amp;&amp; l)</span><br><span class="line">    &#123;</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fZFwfx">萌萌萌萌的筆記: UVA 10003 Cutting Sticks (DP)</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10035 解題紀錄</title>
    <url>/UVa-10035/</url>
    <content><![CDATA[<p>題目： <a href="https://zerojudge.tw/ShowProblem?problemid=c014">UVa - 10035 - Primary Arithmetic</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>每筆測資會有兩個數字，計算這兩個數字相加時做進位的次數。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用兩個 String 讀取測資，利用一個 int 做 Carry，重複將 Carry 加上兩數最後一位數字的和，若大於等於 10 表示有做進位，最後再將 Carry 除以 10，並將兩者都 <code>pop_back()</code> 刪除最後一位，直到其中一者做完為止。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> num1, num2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; num1 &gt;&gt; num2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num1 == <span class="string">&quot;0&quot;</span> &amp;&amp; num2 == <span class="string">&quot;0&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>, carryNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (num1.size() &gt; <span class="number">0</span> &amp;&amp; num2.size() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            carry += (num1.back() - <span class="string">&#x27;0&#x27;</span>) + (num2.back() - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (carry &gt;= <span class="number">10</span>)</span><br><span class="line">                ++carryNum;</span><br><span class="line">            num1.pop_back(), num2.pop_back();</span><br><span class="line">            carry /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num1.size() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (carry + (num1.back() - <span class="string">&#x27;0&#x27;</span>) &gt;= <span class="number">10</span>)</span><br><span class="line">                ++carryNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num2.size() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (carry + (num2.back() - <span class="string">&#x27;0&#x27;</span>) &gt;= <span class="number">10</span>)</span><br><span class="line">                ++carryNum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (carryNum)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No carry operation.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1 carry operation.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; carryNum &lt;&lt; <span class="string">&quot; carry operations.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/10035.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10050 解題紀錄</title>
    <url>/UVa-10050/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=991">UVa - 10050 - Hartals</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給某個天數及一些團體罷工的週期，從週日開始，週五及週六不算，求在這些天數中，罷工的天數為多少 ( 只要任意團體在該天罷工則該天視為罷工 )。</p>
<span id="more"></span>

<p><strong>Input：</strong> 第一個整數 <code>T</code>，表示有 <code>T</code> 組測資，後面兩個整數 <code>N</code>、<code>P</code>，分別代表天數及團體的數量，後面 <code>P</code> 個整數表示各團體罷工的週期。</p>
<p><strong>Output：</strong> 輸出罷工的天數。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先讀取測資，之後根據題意模擬即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fgtWRx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> P;</span><br><span class="line"><span class="keyword">int</span> hartalCycles[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; P; ++i) <span class="built_in">cin</span> &gt;&gt; hartalCycles[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hartal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 跳過星期五和六</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">7</span> == <span class="number">6</span>) &#123; ++i; <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; P; ++j)</span><br><span class="line">            <span class="keyword">if</span> (i % hartalCycles[j] == <span class="number">0</span>) &#123; ++hartal; <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hartal &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fgtWRx">Programming學習筆記: UVa 10050 Hartals</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>CPE - 2020/10/20</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10082 解題紀錄</title>
    <url>/UVa-10082/</url>
    <content><![CDATA[<p>題目： <a href="https://zerojudge.tw/ShowProblem?problemid=c054">UVa - 10082 - WERTYU</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>每筆測資為一個對於鍵盤而言向右偏移一個字的字串，需要輸出原本未偏移的字串。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>利用 String 讀取測資，使用 <code>unordered_map&lt;char, char&gt;</code> 建表，並根據字串內容輸出即可。<br>建表資料參考：<a href="https://zerojudge.tw/ShowThread?postid=21510&reply=0">#21510: 建立map表</a><br>須注意空白也必須加入表中，雖然自己測試時沒加入也會輸出空白，但是繳交執行時不會。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="built_in">unordered_map</span>&lt; <span class="keyword">char</span>, <span class="keyword">char</span>&gt;&amp; table)</span></span>; <span class="comment">// 建表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> data;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt; <span class="keyword">char</span>, <span class="keyword">char</span>&gt; dict;</span><br><span class="line">    build(dict);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, data))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : data)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; dict[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="built_in">unordered_map</span>&lt; <span class="keyword">char</span>, <span class="keyword">char</span>&gt;&amp; table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    table[<span class="string">&#x27;1&#x27;</span>] = <span class="string">&#x27;`&#x27;</span>, table[<span class="string">&#x27;2&#x27;</span>] = <span class="string">&#x27;1&#x27;</span>, table[<span class="string">&#x27;3&#x27;</span>] = <span class="string">&#x27;2&#x27;</span>, table[<span class="string">&#x27;4&#x27;</span>] = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">    table[<span class="string">&#x27;5&#x27;</span>] = <span class="string">&#x27;4&#x27;</span>, table[<span class="string">&#x27;6&#x27;</span>] = <span class="string">&#x27;5&#x27;</span>, table[<span class="string">&#x27;7&#x27;</span>] = <span class="string">&#x27;6&#x27;</span>, table[<span class="string">&#x27;8&#x27;</span>] = <span class="string">&#x27;7&#x27;</span>;</span><br><span class="line">    table[<span class="string">&#x27;9&#x27;</span>] = <span class="string">&#x27;8&#x27;</span>, table[<span class="string">&#x27;0&#x27;</span>] = <span class="string">&#x27;9&#x27;</span>, table[<span class="string">&#x27;-&#x27;</span>] = <span class="string">&#x27;0&#x27;</span>, table[<span class="string">&#x27;=&#x27;</span>] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    table[<span class="string">&#x27;W&#x27;</span>] = <span class="string">&#x27;Q&#x27;</span>, table[<span class="string">&#x27;E&#x27;</span>] = <span class="string">&#x27;W&#x27;</span>, table[<span class="string">&#x27;R&#x27;</span>] = <span class="string">&#x27;E&#x27;</span>, table[<span class="string">&#x27;T&#x27;</span>] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">    table[<span class="string">&#x27;Y&#x27;</span>] = <span class="string">&#x27;T&#x27;</span>, table[<span class="string">&#x27;U&#x27;</span>] = <span class="string">&#x27;Y&#x27;</span>, table[<span class="string">&#x27;I&#x27;</span>] = <span class="string">&#x27;U&#x27;</span>, table[<span class="string">&#x27;O&#x27;</span>] = <span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">    table[<span class="string">&#x27;P&#x27;</span>] = <span class="string">&#x27;O&#x27;</span>, table[<span class="string">&#x27;[&#x27;</span>] = <span class="string">&#x27;P&#x27;</span>, table[<span class="string">&#x27;]&#x27;</span>] = <span class="string">&#x27;[&#x27;</span>, table[<span class="number">92</span>] = <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">    table[<span class="string">&#x27;S&#x27;</span>] = <span class="string">&#x27;A&#x27;</span>, table[<span class="string">&#x27;D&#x27;</span>] = <span class="string">&#x27;S&#x27;</span>, table[<span class="string">&#x27;F&#x27;</span>] = <span class="string">&#x27;D&#x27;</span>, table[<span class="string">&#x27;G&#x27;</span>] = <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">    table[<span class="string">&#x27;H&#x27;</span>] = <span class="string">&#x27;G&#x27;</span>, table[<span class="string">&#x27;J&#x27;</span>] = <span class="string">&#x27;H&#x27;</span>, table[<span class="string">&#x27;K&#x27;</span>] = <span class="string">&#x27;J&#x27;</span>, table[<span class="string">&#x27;L&#x27;</span>] = <span class="string">&#x27;K&#x27;</span>;</span><br><span class="line">    table[<span class="string">&#x27;;&#x27;</span>] = <span class="string">&#x27;L&#x27;</span>, table[<span class="number">39</span>] = <span class="string">&#x27;;&#x27;</span>, table[<span class="string">&#x27;X&#x27;</span>] = <span class="string">&#x27;Z&#x27;</span>, table[<span class="string">&#x27;C&#x27;</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    table[<span class="string">&#x27;V&#x27;</span>] = <span class="string">&#x27;C&#x27;</span>, table[<span class="string">&#x27;B&#x27;</span>] = <span class="string">&#x27;V&#x27;</span>, table[<span class="string">&#x27;N&#x27;</span>] = <span class="string">&#x27;B&#x27;</span>, table[<span class="string">&#x27;M&#x27;</span>] = <span class="string">&#x27;N&#x27;</span>;</span><br><span class="line">    table[<span class="string">&#x27;,&#x27;</span>] = <span class="string">&#x27;M&#x27;</span>, table[<span class="string">&#x27;.&#x27;</span>] = <span class="string">&#x27;,&#x27;</span>, table[<span class="string">&#x27;/&#x27;</span>] = <span class="string">&#x27;.&#x27;</span>, table[<span class="number">32</span>] = <span class="number">32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/10082.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
        <tag>Unordered_map</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10171 解題紀錄</title>
    <url>/UVa-10171/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1112">UVa - 10171 - Meeting Prof. Miguel…</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個圖 <code>M</code>、<code>Y</code>，圖上的點相同，但相通的邊不同，每條邊都有各自的 cost，兩個人各自在圖上走，各自給一個起點，求兩者可相遇且兩人的 cost 總和最小的 cost 及相遇的點，若最小 cost 的點有多個需要全部輸出。</p>
<p><strong>Input：</strong> 每組測資第一個數字 <code>m</code>，表示有 <code>m</code> 行資料，每行資料為四個字符及一個數字組成，依序為 <code>a</code>、<code>b</code>、<code>u</code>、<code>v</code>、<code>w</code>，<code>a</code> 表示該行測資是哪個圖上的，<code>b</code> 表示該邊為單向或雙向 ( B 為雙向 )，u、v、w 依序為邊上兩點及 cost。</p>
<p><strong>Output：</strong> 輸出兩者可相遇且兩人的 cost 總和最小的 cost 及相遇的點，若最小 cost 的點有多個需要全部輸出。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>All Pair Shortest Path 題，讀測資並做 Floyd-Warshall Algorithm 求解即可。需要注意的是測資給的邊可能有重複，此時取 cost 較小者。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> G1[<span class="number">26</span>][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> G2[<span class="number">26</span>][<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j) G1[i][j] = G2[i][j] = INF;</span><br><span class="line">        G1[i][i] = G2[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">char</span> a, b, u, v;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">auto</span> ptr = (a == <span class="string">&#x27;Y&#x27;</span>) ? G1 : G2;</span><br><span class="line">        </span><br><span class="line">        u -= <span class="string">&#x27;A&#x27;</span>, v -= <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        ptr[u][v] = min(w, ptr[u][v]);</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="string">&#x27;B&#x27;</span>) ptr[v][u] = min(w, ptr[v][u]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FloydWarshall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            G1[i][j] = min(G1[i][k] + G1[k][j], G1[i][j]);</span><br><span class="line">            G2[i][j] = min(G2[i][k] + G2[k][j], G2[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    a -= <span class="string">&#x27;A&#x27;</span>, b -= <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mn = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; ++k) mn = min(G1[a][k] + G2[b][k], mn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mn == INF) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;You will never meet.\n&quot;</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mn;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; ++k) <span class="keyword">if</span> (G1[a][k] + G2[b][k] == mn)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="keyword">char</span>(k + <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; m &amp;&amp; m)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        FloydWarshall();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>UVa</tag>
        <tag>Floyd-Warshall</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10172 解題紀錄</title>
    <url>/UVa-10172/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&category=0&problem=1113">UVa - 10172 - The Lonesome Cargo Distributor</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>有一台卡車及一個環形公路，公路上有許多站點，每個站點會有一個地方放要送到這個站點的貨物，還有一個要到其他站點的 Queue，所有站點的 Queue 都會有相同的容量限制，卡車的結構類似於 Stack，在移除上面的貨物前，無法移動下面的貨物。卡車每到一個站後都會執行相同的事情：</p>
<span id="more"></span>

<ol>
<li>先將車上的貨物卸下，若是目前的站點是貨物要到達的站點的話則直接卸下，否則放入該站點的 Queue 的尾端，重複執行直到貨車為空或是該站點的 Queue 已滿。</li>
<li>將站點的 Queue 中的貨物從前端開始放到卡車上，直到卡車滿或是 Queue 為空。</li>
<li>移動到下一個站點。</li>
</ol>
<p>重複以上的動作直到所有貨物都到達該到達的站點為止。</p>
<ol>
<li>卡車每次卸貨或裝貨都會花費一分鐘。</li>
<li>卡車每次移動到下個站點都會花費兩分鐘。</li>
</ol>
<p><strong>Input：</strong> 第一行為一整數，代表接下來有幾組測資。每組測資的第一行有三個整數 <code>n</code>、<code>s</code>、<code>q</code>，分別代表 <code>站點的數量</code>、<code>貨車的最大容量</code>、<code>站點中 Queue 的最大容量</code>。接下來會有 <code>n</code> 行，代表站點的資訊，從第一個站點開始依序往下。每行起始於一個整數，代表 Queue 中有幾個貨物，後面有該數量個數字，代表每個貨物該到達的站點 ( 不會有要到達目前站點的貨物 )。</p>
<p><strong>Output：</strong> 輸出將所有貨物都送達該送達的站點所需要花費的時間 ( 分鐘 )。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 Stack 模擬卡車，Queue 陣列模擬站點即可，由於 <code>(2 ≤ n ≤ 100)</code>，所以將陣列大小設為 100。</p>
<p>先輸入所有資料，並存入對應的 Queue，接著根據題目操作即可。先將 Stack 裡面的資料 <code>pop()</code> 出來，若是目前站點不是貨物要到達的站點則將貨物放 Queue 的尾端，做完後再把 Queue 中的貨物從前端開始放入 Stack，最後判斷卡車及所有 Queue 是否都為空，若都為空代表這組測資已經處理結束。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fIHBVx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, s, q;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; truck;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; stationQueue[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nc;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; nc;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nc; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> target;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; target;</span><br><span class="line">                stationQueue[i].push(target - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>, time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> unload = [&amp;]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (!truck.empty() &amp;&amp;</span><br><span class="line">                (truck.top() == cur || stationQueue[cur].size() &lt; q));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (unload())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (truck.top() != cur) stationQueue[cur].push(truck.top());</span><br><span class="line">                truck.pop();</span><br><span class="line">                ++time;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (truck.size() &lt; s &amp;&amp; (!stationQueue[cur].empty()))</span><br><span class="line">            &#123;</span><br><span class="line">                truck.push(stationQueue[cur].front());</span><br><span class="line">                stationQueue[cur].pop();</span><br><span class="line">                ++time;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> clear = truck.empty();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; clear; ++i) clear &amp;= stationQueue[i].empty();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (clear) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            cur = (cur + <span class="number">1</span>) % n;</span><br><span class="line">            time += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; time &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/10172.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="http://unfortunatedog.blogspot.com/2013/07/10172-lonesome-cargo-distributor.html">Unfortunate狗的ACM園地: 10172 - The Lonesome Cargo Distributor</a><br><a href="https://ppt.cc/fIHBVx">UVa 10172 - The Lonesome Cargo Distributor.cpp</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Stack</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10188 解題紀錄</title>
    <url>/UVa-10188/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=1129">UVa - 10188 - Automated Judge Script</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩組字串，根據條件分成三種結果。</p>
<span id="more"></span>

<ul>
<li><p><strong>Accepted:</strong> 兩組字串完全相同 ( 包括換行及空白 )。</p>
</li>
<li><p><strong>Presentation Error:</strong> 兩組字串數字部分的順序相同。</p>
</li>
<li><p><strong>Wrong Answer:</strong> 以上兩者皆不符合。</p>
</li>
</ul>
<p><strong>Input：</strong> 每組測資第一行為一整數 <code>n</code>，代表第一組字串有 <code>n</code> 行，後面 <code>n</code> 行為第一組的字串，再下一行為一整數 <code>m</code>，代表第二組字串有 <code>m</code> 行，後面 <code>m</code> 行為第一組的字串</p>
<p><strong>Output：</strong> 根據條件輸出結果。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 String 來保存兩組字串，並在讀取的時候加入換行符 <code>&#39;\n&#39;</code>，之後先比對是否 AC，若不是則取出數字的部分比對是否 PE。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">process</span><span class="params">(<span class="built_in">string</span>&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : str) <span class="keyword">if</span> (<span class="built_in">isalnum</span>(ch) &amp;&amp; !<span class="built_in">isalpha</span>(ch)) ret += ch;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="built_in">cin</span> &gt;&gt; n).ignore() &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> str, ans, output;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 讀取正確答案，並加入換行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            getline(<span class="built_in">cin</span>, str);</span><br><span class="line">            <span class="keyword">if</span> (i) ans += <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            ans += str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 讀取需要比對的答案，並加入換行</span></span><br><span class="line">        (<span class="built_in">cin</span> &gt;&gt; m).ignore();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            getline(<span class="built_in">cin</span>, str);</span><br><span class="line">            <span class="keyword">if</span> (i) output += <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            output += str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Run #&quot;</span> &lt;&lt; ++x &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先檢查是否 AC</span></span><br><span class="line">        <span class="keyword">if</span> (ans == output) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Accepted\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (process(ans) == process(output)) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Presentation Error\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Wrong Answer\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
        <tag>CPE - 2020/12/22</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10189 解題紀錄</title>
    <url>/UVa-10189/</url>
    <content><![CDATA[<p>題目： <a href="https://zerojudge.tw/ShowProblem?problemid=e605">UVa - 10189 - Minesweeper</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>每筆測資開始於兩個數字，表示地雷的地圖大小，隨後是地圖的資訊，算出地圖上的每個點的九宮格內共有幾顆地雷，若該點為地雷則輸出 <code>*</code>，否則輸出該數。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>定義一個大小為 102 * 102 的陣列 ( 上下左右各預留一行可以省去一些判斷 )，在每筆測資運算開始前，先將陣列清空。讀取測資時，使用 String 一行一行讀取，再使用 <code>find()</code> 找到 <code>*</code> 的位置，並將陣列內對應該點位置的九宮格的數字都 + 1 ，最後再將這個位置設為其他字元 ( 我是設為 <code>.</code> )，避免重複運算。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result[<span class="number">102</span>][<span class="number">102</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearResult</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">            result[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addResult</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++result[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">    ++result[n][m - <span class="number">1</span>];</span><br><span class="line">    ++result[n + <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    ++result[n - <span class="number">1</span>][m];</span><br><span class="line">    ++result[n + <span class="number">1</span>][m];</span><br><span class="line"></span><br><span class="line">    ++result[n - <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">    ++result[n][m + <span class="number">1</span>];</span><br><span class="line">    ++result[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    result[n][m] = <span class="number">-100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outputResult</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">if</span> (result[i][j] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; result[i][j];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, casenum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">size_t</span> pos;</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">map</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!n &amp;&amp; !m)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        clearResult(n + <span class="number">2</span>, m + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; <span class="built_in">map</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((pos = <span class="built_in">map</span>.find(<span class="string">&#x27;*&#x27;</span>)) != <span class="built_in">string</span>::npos)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">map</span>[pos] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                addResult(i + <span class="number">1</span>, pos + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Field #&quot;</span> &lt;&lt; casenum &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        outputResult(n, m);</span><br><span class="line">        ++casenum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>2021/02/09 Rewrite</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/f01ivx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> field[<span class="number">102</span>][<span class="number">102</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(field, <span class="string">&#x27;0&#x27;</span>, <span class="keyword">sizeof</span>(field));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fill</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-1</span>; i &lt;= <span class="number">1</span>; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">-1</span>; j &lt;= <span class="number">1</span>; ++j)</span><br><span class="line">        <span class="keyword">if</span> (field[y + i][x + j] != <span class="string">&#x27;*&#x27;</span>) ++field[y + i][x + j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span>) field[i][j] = <span class="string">&#x27;*&#x27;</span>, Fill(i, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> Case = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (Case) <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Field #&quot;</span> &lt;&lt; ++Case &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) <span class="built_in">cout</span> &lt;&lt; field[i][j];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; !(!n &amp;&amp; !m))</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        solve();</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
        <tag>CPE - 2020/06/09</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10226 解題紀錄</title>
    <url>/UVa-10226/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1167">UVa - 10226 - Hardwood Species</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>測資開始於一個整數，代表接下來會有幾組資料，一開始的整數後及每組資料間都有空行隔開，可見 Sample I/O。<span id="more"></span></p>
<p><strong>Input：</strong> 每組資料會有許多行字串，每個字串代表一種樹木，出現的次數即為樹木的數量。直到讀取到空的字串為止。</p>
<p><strong>Output：</strong> 輸出每種樹木的名字及所佔的百分比 ( 順序為樹木名字的升冪排序，百分比輸出到小數點後四位 )，每組輸出的資料中間需有空行隔開。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先讀取最前面的整數，由於接下來要使用 <code>getline()</code>，所以先呼叫 <code>cin.ingore()</code> 將輸入流中的 <code>&#39;\n&#39;</code> 清除，再呼叫一次 <code>getline()</code> 讀取整數與第一組資料間的空行，接著就可以開始讀取資料，使用 map 紀錄一組資料中的各個樹木種類出現的次數，同時需要紀錄樹木的總數，最後計算百分比並輸出即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">    <span class="built_in">cin</span>.ignore();</span><br><span class="line">    <span class="comment">// avoid space</span></span><br><span class="line">    getline(<span class="built_in">cin</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (c--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt; m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, str) &amp;&amp; !str.empty()) ++m[str], ++cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [tree, num] : m)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; tree &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; setprecision(<span class="number">4</span>) &lt;&lt; fixed &lt;&lt; num * <span class="number">100</span> / cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(c) <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/10226.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10245 解題紀錄</title>
    <url>/UVa-10245/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1186">UVa - 10245 - The Closest Pair Problem</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一些在二維平面上的點，求最近的兩點距離為何。</p>
<p><strong>Input：</strong> 每組測資第一個整數 <code>N</code>，表示有幾個點 ( 若 <code>N</code> 為 0 表結束 )，後面 <code>N</code> 行每行有兩個整數，表點的座標。</p>
<p><strong>Output：</strong> 輸出最近的兩點距離為何，輸出至小數點後四位，若超過 10000 則輸出 <code>&quot;INFINITY&quot;</code>。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>Closet Pair Problem，可用 Sweep line 或 Divide and Conquer。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><p><strong>Sweep line:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt; b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(c) memset(c, 0, sizeof(c))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/f4Uwtx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MXN = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line">Point P[MXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">const</span> Point&amp; l, <span class="keyword">const</span> Point&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(r.x - l.x, <span class="number">2</span>) + <span class="built_in">pow</span>(r.y - l.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FOR(i, <span class="number">0</span>, N) <span class="built_in">cin</span> &gt;&gt; P[i].x &gt;&gt; P[i].y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// sweep line</span></span><br><span class="line">    sort(P, P + N, [](Point&amp; l, Point&amp; r) &#123; <span class="keyword">return</span> l.x &lt; r.x; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">1e4</span>;</span><br><span class="line">    FOR(i, <span class="number">0</span>, N) FOR(j, i + <span class="number">1</span>, N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (P[i].x + d &lt; P[j].x) <span class="keyword">break</span>; <span class="comment">// 若區域內沒有點則不需要再判斷</span></span><br><span class="line">        d = min(dist(P[i], P[j]), d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d == <span class="number">1e4</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;INFINITY\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">4</span>) &lt;&lt; fixed &lt;&lt; d &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N &amp;&amp; N)</span><br><span class="line">    &#123;</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Divide and Conquer:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt; b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(c) memset(c, 0, sizeof(c))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/f4Uwtx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MXN = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point P[MXN];</span><br><span class="line">Point tmp[MXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">const</span> Point&amp; l, <span class="keyword">const</span> Point&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(l.x - r.x, <span class="number">2</span>) + <span class="built_in">pow</span>(l.y - r.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">const</span> Point&amp; l, <span class="keyword">const</span> Point&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l.x &lt; r.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">const</span> Point&amp; l, <span class="keyword">const</span> Point&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l.y &lt; r.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FOR(i, <span class="number">0</span>, N) <span class="built_in">cin</span> &gt;&gt; P[i].x &gt;&gt; P[i].y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">DnC</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R) <span class="keyword">return</span> INF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> M = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> d = min(DnC(L, M), DnC(M + <span class="number">1</span>, R));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M; i &gt;= L &amp;&amp; P[M].x - P[i].x &lt; d; --i) tmp[idx++] = P[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M + <span class="number">1</span>; i &lt;= R &amp;&amp; P[i].x - P[M].x &lt; d; ++i) tmp[idx++] = P[i];</span><br><span class="line"></span><br><span class="line">    sort(tmp, tmp + idx, cmp2);</span><br><span class="line"></span><br><span class="line">    FOR(i, <span class="number">0</span>, idx) FOR(j, <span class="number">1</span>, <span class="number">4</span> &amp;&amp; i + j &lt; idx) d = min(dist(tmp[i], tmp[i + j]), d);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(P, P + N, cmp1);</span><br><span class="line">    <span class="keyword">auto</span> ret = DnC(<span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= <span class="number">1e4</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;INFINITY\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">4</span>) &lt;&lt; fixed &lt;&lt; ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N &amp;&amp; N)</span><br><span class="line">    &#123;</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/f4Uwtx">UVa 10245 - The Closest Pair Problem | NaiveRed&amp;’s Blog</a><br><a href="https://ppt.cc/fGcnEx">UVa 10245 - The Closest Pair Problem_小白菜又菜-CSDN博客</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Sweep line</tag>
        <tag>Divide and Conquer</tag>
        <tag>Recursive</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10267 解題紀錄</title>
    <url>/UVa-10267/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=1208">UVa - 10267 - Graphical Editor</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>實作一個模擬圖像編輯的程式，根據指令做出對應的操作。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>根據題目的表格做出對應的操作即可，需要注意的是，題目的 X1、X2 和 Y1、Y2，並沒有設定誰大誰小，所以要記得判斷。填色則使用 DFS 即可，注意邊界條件。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> M, N;</span><br><span class="line"><span class="keyword">int</span> X1, Y1;</span><br><span class="line"><span class="keyword">int</span> X2, Y2;</span><br><span class="line"><span class="keyword">int</span> d[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> C;</span><br><span class="line"><span class="keyword">char</span> G[<span class="number">251</span>][<span class="number">251</span>];</span><br><span class="line"><span class="built_in">string</span> fileName, trash;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> reset = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (reset) C = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; x2) swap(x1, x2);</span><br><span class="line">    <span class="keyword">if</span> (y1 &gt; y2) swap(y1, y2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = y1; i &lt;= y2; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = x1; j &lt;= x2; ++j)</span><br><span class="line">        G[i][j] = C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resetGraph</span><span class="params">()</span> </span>&#123; drawRectangle(<span class="number">1</span>, <span class="number">1</span>, M, N, <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">verticalLine</span><span class="params">()</span> </span>&#123; drawRectangle(X1, Y1, X1, Y2); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">horizontalLine</span><span class="params">()</span> </span>&#123; drawRectangle(X1, Y1, X2, Y1); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floodFill</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">char</span> present)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; M || y &lt; <span class="number">1</span> || y &gt; N) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (G[y][x] == C || G[y][x] != present) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    G[y][x] = C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        floodFill(x + d[i], y + d[i + <span class="number">1</span>], present);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j) <span class="built_in">cout</span> &lt;&lt; G[i][j];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cmd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; cmd, cmd != <span class="string">&#x27;X&#x27;</span>) <span class="keyword">switch</span> (cmd)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; M &gt;&gt; N;</span><br><span class="line">        resetGraph();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">        resetGraph();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; X1 &gt;&gt; Y1 &gt;&gt; G[Y1][X1];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>:</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; X1 &gt;&gt; Y1 &gt;&gt; Y2 &gt;&gt; C;</span><br><span class="line">        verticalLine();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; X1 &gt;&gt; X2 &gt;&gt; Y1 &gt;&gt; C;</span><br><span class="line">        horizontalLine();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;K&#x27;</span>:</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; X1 &gt;&gt; Y1 &gt;&gt; X2 &gt;&gt; Y2 &gt;&gt; C;</span><br><span class="line">        drawRectangle(X1, Y1, X2, Y2);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; X1 &gt;&gt; Y1 &gt;&gt; C;</span><br><span class="line">        floodFill(X1, Y1, G[Y1][X1]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; fileName;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; fileName &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        printGraph();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">cin</span>.ignore();</span><br><span class="line">        getline(<span class="built_in">cin</span>, trash);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
        <tag>CPE - 2020/10/20</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10282 解題紀錄</title>
    <url>/UVa-10282/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1223">UVa - 10282 - Babelfish</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給動物名稱及對應的叫聲，依據叫聲輸出對應的動物名稱。<span id="more"></span></p>
<p><strong>Input：</strong> 測資分為兩部分，前面的部分每一行會有兩個字串，分別代表動物名稱及叫聲，中間以空格隔開。後面的部分為動物的叫聲，兩部分中間以空行隔開。</p>
<p><strong>Output：</strong> 根據測資前面的部分輸出叫聲對應的動物，若是沒有在前面出現過則輸出 “eh”。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 Unordered_map 建立叫聲及動物名稱的映射即可。使用 <code>getline()</code> 以行為單位讀取資料，讀取後先判斷，若為空代表前半部分讀取完畢，否則使用 String 中的 <code>find()</code> 找到空格的 index，將字串分為兩部分，以叫聲為 key，名稱為 val，建立映射即可，當前半部分讀取完後開始讀取叫聲，先判斷這種叫聲是否出現過，若出現過直接輸出名稱即可，否則輸出 “eh”。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> key, val;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, val))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (val.empty()) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> idx = val.find(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        key = val.substr(idx + <span class="number">1</span>, val.length() - idx);</span><br><span class="line">        val.erase(idx);</span><br><span class="line">        m[key] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, key))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (key.empty()) <span class="keyword">break</span>;</span><br><span class="line">        m.count(key) ? <span class="built_in">cout</span> &lt;&lt; m[key] &lt;&lt; <span class="string">&#x27;\n&#x27;</span> : <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;eh\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/10282.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
        <tag>Unordered_map</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10305 解題紀錄</title>
    <url>/UVa-10305/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1246">UVa - 10305 - Ordering Tasks</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一整數 <code>N</code> 代表有 <code>N</code> 個任務要完成，及 <code>M</code> 個規則，表示在做某個任務前需要完成的任務。求適合的執行任務順序 ( 符合規則即可 )。</p>
<span id="more"></span>

<p><strong>Input：</strong> 每組測資第一行為兩個整數 <code>N</code>、<code>M</code>，若 <code>N</code>、<code>M</code> 皆為 0 表示結束。否則接下來 <code>M</code> 行，每行都有兩個整數 <code>a</code>、<code>b</code>，表示在做任務 <code>b</code> 前需要先完成任務 <code>a</code>。</p>
<p><strong>Output：</strong> 符合規則的任務執行順序。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>基本的 Topological sort，建圖之後做 DFS 即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOOP(n) for(int I = 0; I &lt; n; ++I)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE(c) int(c.size())</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M;</span><br><span class="line">    <span class="keyword">int</span> mem[<span class="number">101</span>]; <span class="comment">// 0 -&gt; 沒有被其他點連入，1 -&gt; 被其他點連入</span></span><br><span class="line">    <span class="keyword">int</span> visited[<span class="number">101</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[<span class="number">101</span>];</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[n]) <span class="keyword">return</span>;</span><br><span class="line">        visited[n] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : G[n]) dfs(i);</span><br><span class="line">        ret.push_front(n);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &amp;&amp; (N || M))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        ret.clear();</span><br><span class="line">        fill(mem, mem + <span class="number">101</span>, <span class="number">0</span>);</span><br><span class="line">        fill(visited, visited + <span class="number">101</span>, <span class="number">0</span>);</span><br><span class="line">        fill(G, G + <span class="number">101</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">        LOOP(M)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            G[a].push_back(b);</span><br><span class="line">            mem[b] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="keyword">if</span> (!mem[i]) dfs(i);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ret.front();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = ++ret.begin(); it != ret.end(); ++it) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *it;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/10305.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Recursive</tag>
        <tag>Topological Sort</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10306 解題紀錄</title>
    <url>/UVa-10306/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=1247">UVa - 10306 - e-Coins</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p><a href="http://unfortunatedog.blogspot.com/2013/01/10306-e-coins.html">Unfortunate狗的ACM園地: 10306 - e-Coins</a></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>DP 的 Coin Change 問題，核心概念為枚舉每一個最後加入的面額。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, s;</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; coin[<span class="number">41</span>]; <span class="comment">// Conventional, InfoTechnological</span></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">301</span>][<span class="number">301</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">300</span>; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">300</span>; ++j) dp[i][j] = INF;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    s *= s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">cin</span> &gt;&gt; coin[i].first &gt;&gt; coin[i].second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CoinChange</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; [C, I] = coin[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = C; i &lt;= <span class="number">300</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = I; j &lt;= <span class="number">300</span>; ++j)</span><br><span class="line">                dp[i][j] = min(dp[i - C][j - I] + <span class="number">1</span>, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mn = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">300</span>; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">300</span>; ++j)</span><br><span class="line">        <span class="keyword">if</span> (i * i + j * j == s) mn = min(dp[i][j], mn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mn == INF) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not possible\n&quot;</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mn &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        read();</span><br><span class="line">        init();</span><br><span class="line">        CoinChange();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="http://unfortunatedog.blogspot.com/2013/01/10306-e-coins.html">Unfortunate狗的ACM園地: 10306 - e-Coins</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>UVa</tag>
        <tag>Coin Change</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10330 解題紀錄</title>
    <url>/UVa-10330/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1271">UVa - 10330 - Power Transmission</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>基哥上課講過了。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>最大流，可使用 Dinic 求解。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt; b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(c) memset(c, 0, sizeof(c))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">QPOP</span><span class="params">(<span class="built_in">queue</span>&lt;T&gt;&amp; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MXN = <span class="number">205</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S, T;</span><br><span class="line"><span class="keyword">int</span> rn[MXN][MXN];</span><br><span class="line"><span class="keyword">int</span> l[MXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLR(rn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FOR(i, <span class="number">1</span>, N + <span class="number">1</span>) <span class="built_in">cin</span> &gt;&gt; rn[i][i + N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> u, v, w, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--) <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w, rn[u + N][v] = w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> I, O;</span><br><span class="line">    T = <span class="number">2</span> * N + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; I &gt;&gt; O;</span><br><span class="line">    <span class="keyword">while</span> (I--) <span class="built_in">cin</span> &gt;&gt; v, rn[S][v] = INF;</span><br><span class="line">    <span class="keyword">while</span> (O--) <span class="built_in">cin</span> &gt;&gt; u, rn[u + N][T] = INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dinicBFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLR(l);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(S);</span><br><span class="line">    l[S] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = QPOP(q);</span><br><span class="line"></span><br><span class="line">        FOR(v, <span class="number">0</span>, T + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l[v] || !rn[u][v]) <span class="keyword">continue</span>;</span><br><span class="line">            l[v] = l[u] + <span class="number">1</span>;</span><br><span class="line">            q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l[T];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinicDFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> cp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == T) <span class="keyword">return</span> cp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp = cp;</span><br><span class="line"></span><br><span class="line">    FOR(v, <span class="number">0</span>, T + <span class="number">1</span> &amp;&amp; tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l[v] != l[u] + <span class="number">1</span> || !rn[u][v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> bt = dinicDFS(v, min(rn[u][v], tmp));</span><br><span class="line">        rn[u][v] -= bt;</span><br><span class="line">        rn[v][u] += bt;</span><br><span class="line">        tmp -= bt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cp - tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximumFlow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (dinicBFS()) mf += dinicDFS(S, INF);</span><br><span class="line">    <span class="keyword">return</span> mf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maximumFlow() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Queue</tag>
        <tag>Maximum Flow</tag>
        <tag>Dinic</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10337 解題紀錄</title>
    <url>/UVa-10337/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1278">UVa - 10337 - Flight Planner</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>在一個平面座標系上，有一架飛機從原點 <code>( 0, 0 )</code> 起飛，要到 <code>X</code> <code>( X, 0 )</code>，將原點到 <code>X</code> 每 100 miles 分為一段，給每段的各個空層 ( 共 9 層 ) 的風速<span id="more"></span>，飛機每飛過 100 miles 可以選擇往上一層、往下一層、或是平飛，花費的燃料依序為 60、20、30，且花費的燃料還要減掉該層的風速，求從起點到終點花費的最少燃料為何。飛機不能在地面平飛 ( 第 0 層 )，也不能飛超過第 9 層。</p>
<p><strong>Input：</strong> 第一個整數 <code>T</code>，表示有 <code>T</code> 組測資，每組測資第一個整數為 <code>X</code>，後面 9 * <code>X</code> / 100 的表格為風速，以左下角為原點，向右為 x 軸 ( 0 ~ <code>X</code> / 100 )，向上為 y 軸 ( 0 ~ 9 )。</p>
<p><strong>Output：</strong> 輸出從起點到終點的最小花費燃料。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>動態規劃題，先讀取測資，將每 100 miles 分為一段，<code>winds[i][j]</code> 表第 <code>i</code> 段，第 <code>j</code> 層的風速，先讀取風速，記得是從第 9 層開始。</p>
<p>定義 <code>dp[i][j]</code> 表飛機到達第 <code>i</code> 段，第 <code>j</code> 層所需的最小花費，對於 (i, j) 來說，只能從 (i - 1, j)、(i - 1, j - 1)、(i - 1, j + 1) 到達，依此想法做動態規劃即可，記得注意題目要求的一些限制，如不能在第 0 層走等等。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fzYlzx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> X;</span><br><span class="line"><span class="keyword">int</span> winds[<span class="number">1005</span>][<span class="number">10</span>]; <span class="comment">// winds[i][j] 表第 i 段，第 j 層的風速</span></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">10</span>];    <span class="comment">// dp[i][j] 表飛機到達第 i 段，第 j 層所需的最小花費</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; X;</span><br><span class="line">    X /= <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; --i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; X; ++j)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; winds[j][i], dp[j][i] = inf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 起點</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= X; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mn = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mn = min(dp[i - <span class="number">1</span>][j] + <span class="number">30</span> - winds[i - <span class="number">1</span>][j], mn);         <span class="comment">// 從 i - 1 平飛到 i</span></span><br><span class="line">            mn = min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">60</span> - winds[i - <span class="number">1</span>][j - <span class="number">1</span>], mn); <span class="comment">// 從 i - 1 向上飛到 i</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">9</span>) mn = min(dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">20</span> - winds[i - <span class="number">1</span>][j + <span class="number">1</span>], mn); <span class="comment">// 從 i - 1 向下飛到 i</span></span><br><span class="line">        dp[i][j] = mn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[X][<span class="number">0</span>] &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fzYlzx">[UVA] 10337 - Flight Planner | 水泥城式</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10415 解題紀錄</title>
    <url>/UVa-10415/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=1356">UVa - 10415 - Eb Alto Saxophone Player</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給薩克斯風的各種音調的指法，及由這些音調組成的歌曲 ( 假設一個手指頭只能按特定一個按鍵，且不同手指控制不同按鈕 )，求每根手指需要按下的次數，如果某一按鍵在下一音符時不會用到，那麼就會放開，否則就是維持按著的情況。</p>
<span id="more"></span>

<p><strong>Input：</strong> 第一個整數 <code>T</code>，表示有 <code>T</code> 組測資，後面 <code>T</code> 行每行為一首歌曲，歌曲可能為空。</p>
<p><strong>Output：</strong> 對於每組測資，請輸出 10 個數字，代表每個手指的按下次數，數字用空格分隔。</p>
<p>參考自：<a href="https://zerojudge.tw/ShowProblem?problemid=e531">e531. 10415 - Eb Alto Saxophone Player - 高中生程式解題系統</a></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先建表，建立音調及手指的映射，之後查表即可，需要注意的是由於<strong>歌曲可能為空</strong>，所以使用 <code>getline()</code> 讀取，還需要紀錄上一個音調按下的手指，並在計算次數時比對。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">string</span> present;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; dict</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&quot;0111001111&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&quot;0111001110&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;e&#x27;</span>, <span class="string">&quot;0111001100&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;f&#x27;</span>, <span class="string">&quot;0111001000&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&quot;0111000000&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&quot;0110000000&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&quot;0100000000&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&quot;0010000000&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;D&#x27;</span>, <span class="string">&quot;1111001110&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;E&#x27;</span>, <span class="string">&quot;1111001100&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;F&#x27;</span>, <span class="string">&quot;1111001000&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;G&#x27;</span>, <span class="string">&quot;1111000000&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&quot;1110000000&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;B&#x27;</span>, <span class="string">&quot;1100000000&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(cnt, cnt + <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    present.assign(<span class="number">10</span>, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i) <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cnt[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    (<span class="built_in">cin</span> &gt;&gt; T).ignore();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        getline(<span class="built_in">cin</span>, str);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : str)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">                cnt[i] += max(<span class="number">0</span>, dict[ch][i] - present[i]);</span><br><span class="line">            present = dict[ch];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/10415.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://zerojudge.tw/ShowProblem?problemid=e531">e531. 10415 - Eb Alto Saxophone Player - 高中生程式解題系統</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
        <tag>Unordered_map</tag>
        <tag>CPE - 2020/12/22</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10449 解題紀錄</title>
    <url>/UVa-10449/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1390">UVa - 10449 - Traffic</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>題目看不是很懂，反正就是有一個有向圖，圖上的每個點都有一個數值，邊的權重為 <code>目的地的值 - 出發點的值</code> 的三次方，給一個起點及一些終點，求從起點 ( 1 號點 ) 到終點的最短路徑。</p>
<span id="more"></span>

<p><strong>Input：</strong> 每組測資的第一個數字 <code>n</code> 表示有 <code>n</code> 個點，後面 <code>n</code> 個數字依序代表點的數值 <code>(1 ~ n)</code>，後面一個整數 <code>m</code>，表示有 <code>m</code> 條邊，後面 <code>m</code> 行每行有兩個整數 <code>u</code>、<code>v</code>，表示有邊 <code>u -&gt; v</code>，後面有一個整數 <code>q</code>，表示有幾個終點，後面 <code>q</code> 個整數表示終點的位置。</p>
<p><strong>Output：</strong> 若起點 ( 1 號點 ) 到終點的最短路徑小於 3 或是起點無法到達終點就輸出 <code>&quot;?&quot;</code>，否則輸出最短路徑。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p><strong>這個解法需要有 Bellman Ford 演算法的概念。</strong></p>
<p>先建圖並使用 Bellman Ford，之後再做一次，儲存在負環上的點 ( 因為在負環表示可以無限變小 )，之後讀取終點並根據情況輸出即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// data</span></span><br><span class="line"><span class="keyword">int</span> busyness[<span class="number">201</span>];</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">201</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; edges[<span class="number">201</span>];</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.clear();</span><br><span class="line">    fill(dist, dist + <span class="number">201</span>, INT_MAX);</span><br><span class="line">    fill(edges, edges + <span class="number">201</span>, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bellman</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 從 1 開始</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若不存在負環，則做 n - 1 次後 dist 會儲存 0 到每個點的最短路徑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [v, w] : edges[u])</span><br><span class="line">            <span class="keyword">if</span> (dist[u] != INT_MAX) dist[v] = min(dist[u] + w, dist[v]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u) <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [v, w] : edges[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果 v 還能變小，表示 v 可以無限變小</span></span><br><span class="line">        <span class="keyword">if</span> (dist[u] != INT_MAX &amp;&amp; dist[v] &gt; dist[u] + w)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[v] = dist[u] + w;</span><br><span class="line">            s.insert(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, Case = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; b;</span><br><span class="line">            busyness[i] = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            edges[u].push_back(&#123; v, (<span class="keyword">int</span>)<span class="built_in">pow</span>(busyness[v] - busyness[u], <span class="number">3</span>) &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bellman(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Set #&quot;</span> &lt;&lt; ++Case &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span> (q--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; p;</span><br><span class="line">            <span class="keyword">if</span> (s.count(p) || dist[p] &lt; <span class="number">3</span> || dist[p] == INT_MAX) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;?\n&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; dist[p] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/10449.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Graph</tag>
        <tag>Vector</tag>
        <tag>Unordered_set</tag>
        <tag>Bellman Ford</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10534 解題紀錄</title>
    <url>/UVa-10534/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1475">UVa - 10534 - Wavio Sequence</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><blockquote>
<p>給定一個長度為 n 的整數序列，求一個最長子序列（不一定為連續），使得該序列的長度為奇數 2 * k + 1，前 k + 1 個數嚴格遞增，後 k + 1 個數嚴格遞減。（嚴格遞增 / 遞減意味著相鄰兩個數不能相同）</p>
</blockquote>
<p><a href="http://www.aspphp.online/bianchen/cyuyan/cjj/cjjrm/201701/211956.html">UVA 10534 - Wavio Sequence LIS_C++入門知識</a></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>遞增的部分很明顯是 LIS，遞減的部分可以視為反向的 LIS，先做出正向及反向的 LIS，之後遍歷陣列，遍歷到的元素視為中心，可以組出的長度為正向及反向 LIS 的較小值乘 2 加 1 ( 依照題目要求 )。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt; b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(c) memset(c, 0, sizeof(c))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MXN = <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> l;</span><br><span class="line"><span class="keyword">int</span> n[MXN];</span><br><span class="line"><span class="keyword">int</span> seq[MXN];</span><br><span class="line"><span class="keyword">int</span> L[MXN];</span><br><span class="line"><span class="keyword">int</span> LR[MXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLR(seq);</span><br><span class="line">    l = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FOR(i, <span class="number">0</span>, N) <span class="built_in">cin</span> &gt;&gt; n[i], L[i] = LR[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LIS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FOR(i, <span class="number">0</span>, N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = lower_bound(seq, seq + l, n[i]) - seq;</span><br><span class="line">        seq[pos] = n[i];</span><br><span class="line">        L[i] = pos + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos == l) ++l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = lower_bound(seq, seq + l, n[i]) - seq;</span><br><span class="line">        seq[pos] = n[i];</span><br><span class="line">        LR[i] = pos + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos == l) ++l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">1</span>;</span><br><span class="line">    FOR(i, <span class="number">0</span>, N) mx = max(min(L[i], LR[i]) * <span class="number">2</span> - <span class="number">1</span>, mx);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mx &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N)</span><br><span class="line">    &#123;</span><br><span class="line">        read();</span><br><span class="line">        init();</span><br><span class="line">        LIS();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="http://www.aspphp.online/bianchen/cyuyan/cjj/cjjrm/201701/211956.html">UVA 10534 - Wavio Sequence LIS_C++入門知識</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>UVa</tag>
        <tag>LIS</tag>
        <tag>LDS</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10557 解題紀錄</title>
    <url>/UVa-10557/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1498">UVa - 10557 - XYZZY</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個有向圖，圖上每個點都會有能量值變化量，初始能量值為 100，求是否能從起點 ( 1 號點 ) 走到終點，且過程中能量值不能為 0。</p>
<span id="more"></span>

<p><strong>Input：</strong> 每組測資第一行為一整數 <code>N</code>，表示有 <code>N</code> 個點，若為 -1 表示結束，後面 <code>N</code> 行依序為每個點的資訊 <code>(1 ~ N)</code>，每行至少有兩個整數，第一個整數表示該點的能量值變化量，後面一個整數表示該點連接到幾個其他的點，後面為該點能連接到的點 ( 單向 )。</p>
<p><strong>Output：</strong> 若從起點 ( 1 號點 ) 能走到終點則輸出 <code>&quot;winnable&quot;</code>，否則輸出 <code>&quot;hopeless&quot;</code>。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p><strong>這個解法需要有 Bellman Ford 演算法的概念。</strong></p>
<p>可以將題目轉換為求最大路徑的問題，由於可能會有正環，所以我們需要知道連接在正環的點是否能到達終點，若可以那表示一定能走到終點，因為可以一直在正環走，使能量值無限。</p>
<p>找出圖上能到達終點的點的問題可以轉換成，在反向的圖上，從終點開始走能到達的點。</p>
<p>所以先讀取測資並建圖，同時建一個反向的圖，接著先找出能到達終點的點，之後使用 Bellman Ford，再檢查是否有正環，若沒有則最後判斷到終點的最大路徑和是否大於 0 即可。<strong>需要注意的是，由於過程中能量值不能為 0，所以每個點的最大路徑和一開始都設為 0。</strong></p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// data</span></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> energy[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">101</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[<span class="number">101</span>];   <span class="comment">// 正向圖</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re[<span class="number">101</span>];  <span class="comment">// 反向圖</span></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s; <span class="comment">// 可以連到終點的點</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.clear();</span><br><span class="line">    fill(dist, dist + <span class="number">101</span>, <span class="number">0</span>);</span><br><span class="line">    fill(G, G + <span class="number">101</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    fill(re, re + <span class="number">101</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 從終點往回走 ( 反向圖 )，找出可以到達終點的點</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.insert(u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : re[u]) <span class="keyword">if</span> (!s.count(v)) dfs(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bellman</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 從 1 開始</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若不存在正環，則做 n - 1 次後 dist 會儲存 1 到每個點的最大能量走法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= N; ++u) <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : G[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dist[u]) dist[v] = max(dist[u] + energy[v], dist[v]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= N; ++u) <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : G[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若 v 還能變大表示有正環，可以重複走直到能量無限，</span></span><br><span class="line">        <span class="comment">// 所以如果 v 能到達終點，表示一定能走到終點</span></span><br><span class="line">        <span class="keyword">if</span> (dist[u] &amp;&amp; dist[v] &lt; dist[u] + energy[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.count(v)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            dist[v] = dist[u] + energy[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist[N];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N &amp;&amp; N != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j, tmp;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; tmp &gt;&gt; j;</span><br><span class="line">            energy[i] = tmp;</span><br><span class="line">            <span class="keyword">while</span> (j--) <span class="built_in">cin</span> &gt;&gt; tmp, G[i].push_back(tmp), re[tmp].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出可以走到終點的點</span></span><br><span class="line">        dfs(N);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bellman()) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;winnable\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hopeless\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/10557.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Graph</tag>
        <tag>Vector</tag>
        <tag>Unordered_set</tag>
        <tag>Bellman Ford</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10594 解題紀錄</title>
    <url>/UVa-10594/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1535">UVa - 10594 - Data Flow</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><blockquote>
<p>給你一個無向圖，兩點之間的邊的容量是 K，每條邊有不同的 cost，現在有大小為 D 的資料，要從起點傳到終點，問把全部資料傳過去的最小 cost 是多少，如果不能全部傳過去則輸出 Impossible.<br>第一行輸入 N M：總共N個點，編號從 1 ~ N，然後底下有 M 行<br>有 M 行，每行 u v c：表示點 u 和點 v 之間的 cost 為 c (雙向圖)<br>最後一行 D K：要傳的資料大小為 D，每個邊的容量為 K</p>
</blockquote>
<p><a href="https://ppt.cc/f6C1Yx">Programming學習筆記: UVa 10594 Data Flow</a></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>建圖後求 MCMF 即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt; b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(c) memset(c, 0, sizeof(c))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">QPOP</span><span class="params">(<span class="built_in">queue</span>&lt;T&gt;&amp; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MXN = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/f6C1Yx</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[MXN];</span><br><span class="line">ll c[MXN][MXN];</span><br><span class="line">ll f[MXN][MXN];</span><br><span class="line">ll cost[MXN][MXN];</span><br><span class="line">ll d[MXN];</span><br><span class="line"><span class="keyword">int</span> p[MXN];</span><br><span class="line"><span class="keyword">bool</span> inQ[MXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S = <span class="number">1</span>, T;</span><br><span class="line"><span class="keyword">int</span> N, M, D, K;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> Cap = <span class="number">0</span>, <span class="keyword">int</span> Cost = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[u].push_back(v);</span><br><span class="line">    c[u][v] = Cap;</span><br><span class="line">    cost[u][v] = Cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T = N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : e) v.clear();</span><br><span class="line">    CLR(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, C;</span><br><span class="line">    <span class="keyword">while</span> (M--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; C;</span><br><span class="line"></span><br><span class="line">        addEdge(u, v, <span class="number">1</span>, C);</span><br><span class="line">        addEdge(v, u, <span class="number">1</span>, C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; D &gt;&gt; K;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(d, d + MXN, INF);</span><br><span class="line">    d[S] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    CLR(inQ);</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    q.push(S);</span><br><span class="line">    inQ[S] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> u = QPOP(q);</span><br><span class="line">        inQ[u] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : e[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[u][v] &gt; f[u][v] &amp;&amp; d[u] + cost[u][v] &lt; d[v])</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] = d[u] + cost[u][v];</span><br><span class="line">                p[v] = u;</span><br><span class="line">                <span class="keyword">if</span> (!inQ[v]) q.push(v), inQ[v] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (f[v][u] &gt; <span class="number">0</span> &amp;&amp; d[u] + (-cost[v][u]) &lt; d[v])</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] = d[u] + (-cost[v][u]);</span><br><span class="line">                p[v] = u;</span><br><span class="line">                <span class="keyword">if</span> (!inQ[v]) q.push(v), inQ[v] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d[T] != INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">augment</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ll bottleNeck)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == S) <span class="keyword">return</span> bottleNeck;</span><br><span class="line">    bottleNeck = augment(p[u], u, min(c[u][v] - f[u][v], bottleNeck));</span><br><span class="line">    f[u][v] += bottleNeck;</span><br><span class="line">    f[v][u] -= bottleNeck;</span><br><span class="line">    <span class="keyword">return</span> bottleNeck;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">MCMF</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll mnC = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (SPFA())</span><br><span class="line">    &#123;</span><br><span class="line">        mnC += min(K, D) * d[T];</span><br><span class="line">        D -= K;</span><br><span class="line">        <span class="keyword">if</span> (D &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        augment(p[T], T, INF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (D &lt;= <span class="number">0</span>) <span class="keyword">return</span> mnC;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> mnC = MCMF();</span><br><span class="line">    <span class="keyword">if</span> (mnC != <span class="number">-1</span>) <span class="built_in">cout</span> &lt;&lt; mnC &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Impossible.\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/f6C1Yx">Programming學習筆記: UVa 10594 Data Flow</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Queue</tag>
        <tag>Maximum Flow</tag>
        <tag>Edmonds-Karp</tag>
        <tag>SPFA</tag>
        <tag>MCMF</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10616 解題紀錄</title>
    <url>/UVa-10616/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1557">UVa - 10616 - Divisible Group Sums</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一些整數及一些 <code>D</code>、<code>M</code>，求在這些整數中，找 <code>M</code> 個相加可以被 <code>D</code> 整除的情況數。</p>
<p><strong>Input：</strong> 每組測資前兩個整數依序為 <code>N</code>、<code>Q</code>，表有 <code>N</code> 個數字，及 <code>Q</code> 組 <code>D</code>、<code>M</code>，後面 <code>N</code> 行為 <code>N</code> 個整數，再後面 <code>Q</code> 行每行有兩個整數，依序代表 <code>D</code>、<code>M</code>。</p>
<p><strong>Output：</strong> 輸出在這些整數中，找 <code>M</code> 個相加可以被 <code>D</code> 整除的情況數。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>為了方便計算，先對所有數字進行處理，使得數字都落在 0 ~ <code>D</code> - 1 裡面，若是正數只要直接 % <code>D</code> 即可，負數需要特別處理，由於負數 % <code>D</code> 後範圍會落在 0 ~ - ( <code>D</code> - 1 )，根據同餘定理，加上 <code>D</code> 後取餘的結果相同，因此加上 <code>D</code>，使得所有數字都在範圍內。</p>
<p>定義 <code>dp[k][j]</code>，表挑 <code>j</code> 個數字相加等於 <code>k</code> 的情況數。</p>
<p>之後遍歷處理好的陣列，核心想法為考慮目前遍歷的數字是否要加入，以此想法做 DP 即可。</p>
<p>由於 DP 縮減了一維，所以計算時要從後面往前算。</p>
<p>最後再將能被 <code>D</code> 整除的所有情況數相加即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fAF1Zx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> C;</span><br><span class="line"><span class="keyword">int</span> N, Q;</span><br><span class="line"><span class="keyword">int</span> D, M;</span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">201</span>];</span><br><span class="line"><span class="keyword">int</span> tmp[<span class="number">201</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">201</span>][<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; D &gt;&gt; M;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 將所有數字轉換到 0 ~ D 區間</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp[i] = nums[i] % D;</span><br><span class="line">        <span class="keyword">if</span> (tmp[i] &lt; <span class="number">0</span>) tmp[i] += D; <span class="comment">// 同餘定理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="built_in">cin</span> &gt;&gt; nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;SET &quot;</span> &lt;&lt; ++C &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q &lt; Q)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = M; j &gt; <span class="number">0</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = tmp[i]; k &lt;= <span class="number">200</span>; ++k) dp[k][j] += dp[k - tmp[i]][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">200</span>; i += D) cnt += dp[i][M];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;QUERY &quot;</span> &lt;&lt; ++q &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; Q &amp;&amp; N &amp;&amp; Q) solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fAF1Zx">UVa 10616 - Divisible Group Sums_小白菜又菜-CSDN博客</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>UVa</tag>
        <tag>0-1 Knapsack</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 1062 解題紀錄</title>
    <url>/UVa-1062/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&category=0&problem=3503">UVa - 1062 - Containers</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個字串，代表依序進到港口的貨物，後面的貨物進來後就無法再移動前面的貨物，在港口的貨物須從下而上按照字典序的大而小排序，求最少堆成幾堆可以滿足條件。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p><strong>解法一：</strong></p>
<p>將港口的每堆貨物視為一個 Stack，每次貨物進來後先檢查能否放在原本的 Stack 上，若無法則新增一個 Stack 後放入。最後輸出 Stack 的個數即可。</p>
<p><strong>解法二：</strong></p>
<p>延續解法一的想法，可以發現由左到右的 Stack 的 <code>top()</code> 其實就是 LIS，所以 Stack 的數量即為 LIS ( 最長嚴格遞增子陣列 ) 的長度，使用 DP 找出長度即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><p>解法一：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt;&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> AddToStack = [&amp;](<span class="keyword">char</span>&amp; ch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; s : v) <span class="keyword">if</span> (ch &lt;= s.top()) &#123; s.push(ch); <span class="keyword">return</span>; &#125;</span><br><span class="line">        v.push_back(<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt;());</span><br><span class="line">        v.back().push(ch);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str &amp;&amp; str != <span class="string">&quot;end&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        v.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : str) AddToStack(ch);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; ++cnt &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/01062-1.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<p>解法二：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> in;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; in &amp;&amp; in != <span class="string">&quot;end&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>, l = in.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(l, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; l; ++j)</span><br><span class="line">                <span class="keyword">if</span> (in[j] &gt; in[i]) dp[j] = max(dp[j], dp[i] + <span class="number">1</span>);</span><br><span class="line">            ret = max(ret, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; ++cnt &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/01062-2.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>UVa</tag>
        <tag>Stack</tag>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10653 解題紀錄</title>
    <url>/UVa-10653/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&category=0&problem=1594">UVa - 10653 - Bombs! NO they are Mines!!</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>有一個機器人在地圖上走，地圖上有一些炸彈，給一個起點及終點，求機器人從起點走到終點且繞過炸彈的最短路徑。</p>
<span id="more"></span>

<p><strong>Input：</strong> 每組測資的第一行為兩整數 <code>R</code>、<code>C</code>，分別表示地圖的寬跟高，若兩者皆為 0 則結束，下面一行為 1 個整數 <code>rows</code>，代表有幾個列有炸彈，接下來 <code>rows</code> 行，每行至少有兩個整數 <code>r</code>、<code>n</code>，分別代表第幾列有炸彈及有幾個炸彈，後面有 <code>n</code> 個數字，表示這一列的哪個位置有炸彈，最後兩行分別代表起始點及終點的位置。</p>
<p><strong>Output：</strong> 輸出從起點走到終點的步數。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先記錄炸彈的位置，之後 BFS 求解即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fsckax</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R, C;</span><br><span class="line"><span class="keyword">int</span> sx, sy, ex, ey; <span class="comment">// 起始點與終點</span></span><br><span class="line"><span class="keyword">bool</span> bomb[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> d[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span> &#125;; <span class="comment">// 偏移量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    q.push(&#123; sx, sy &#125;);</span><br><span class="line">    visited[sx][sy] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (size--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x, y] = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x == ex &amp;&amp; y == ey) <span class="keyword">return</span> steps;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> dx, dy;</span><br><span class="line">            <span class="keyword">auto</span> stop = [&amp;] <span class="comment">// 不能走的點</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> dx &lt; <span class="number">0</span> || dx &gt;= R || dy &lt; <span class="number">0</span> </span><br><span class="line">                || dy &gt;= C || visited[dx][dy] || bomb[dx][dy];</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                dx = x + d[i], dy = y + d[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (stop()) <span class="keyword">continue</span>;</span><br><span class="line">                q.push(&#123; dx, dy &#125;);</span><br><span class="line">                visited[dx][dy] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++steps; <span class="comment">// 先將目前可能的位置都拓展一步之後再將步數加一</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; R &gt;&gt; C &amp;&amp; !(!R &amp;&amp; !C))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        fill(bomb[<span class="number">0</span>], bomb[<span class="number">0</span>] + <span class="number">1005</span> * <span class="number">1005</span>, <span class="literal">false</span>);</span><br><span class="line">        fill(visited[<span class="number">0</span>], visited[<span class="number">0</span>] + <span class="number">1005</span> * <span class="number">1005</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rows;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; rows;</span><br><span class="line">        <span class="keyword">while</span> (rows--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> r, n, k;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; r &gt;&gt; n;</span><br><span class="line">            <span class="keyword">while</span> (n--) <span class="built_in">cin</span> &gt;&gt; k, bomb[r][k] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; sx &gt;&gt; sy &gt;&gt; ex &gt;&gt; ey;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; bfs() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/10653.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fsckax">UVa 10653 - Bombs! NO they are Mines!!_小白菜又菜-CSDN博客</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Queue</tag>
        <tag>Graph</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10721 解題紀錄</title>
    <url>/UVa-10721/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1662">UVa - 10721 - Bar Codes</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>組成 bar 的單位為長方條 ( units )，units 的顏色可以是黑色也可以是白色，同一種顏色排在一起視為一個 bar。</p>
<span id="more"></span>

<p><code>BC(n, k, m)</code> 表總共使用 <code>n</code> 個 units，組成 <code>k</code> 個 bar，每個 bar 的寬度不可超過 <code>m</code> 個 units，且第一個 bar 為黑色，能組出的所有情況數</p>
<p>給 <code>n</code>、<code>k</code>、<code>m</code>，求 <code>BC(n, k, m)</code>。</p>
<p><strong>Input：</strong> 每組測資有三個整數，依序為 <code>n</code>、<code>k</code>、<code>m</code>。</p>
<p><strong>Output：</strong> 輸出 <code>BC(n, k, m)</code>。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>動態規劃題，由於測資範圍不大，因此先算出所有情況的答案再輸出即可。</p>
<p>定義 <code>dp[n][k][m]</code> 表 <code>BC(n, k, m)</code>，先設定初始狀態，由於第一個 bar 必為黑色，因此可以知道，<strong>dp[n][1][m] = 1，對於所有 m &gt;= n</strong>，也就是只能是黑色的 bar，而 <code>m &gt;= n</code> 是因為當 <code>m &lt; n</code> 時無法使用完 <code>n</code> 個 units，因此為 0。</p>
<p>對於 <code>dp[n][k][m]</code>：</p>
<ul>
<li>若 <code>m &gt; n</code>，<strong>dp[n][k][m] = dp[n][k][n]</strong> 。因為最多只可使用 <code>n</code> 個 units。</li>
<li>若 <code>m &lt;= n</code>，<strong>dp[n][k][m] = dp[n - 1][k - 1][m] + dp[n - 2][k - 1][m] + … + dp[n - m][k - 1][m]</strong> 。<br>可以想像為，在原本的組合下接上新的 bar，如 <code>dp[n - 1][k - 1][m]</code> 為接上一個 unit 的 bar 後的情況數，<code>dp[n - 2][k - 1][m]</code> 為接上兩個 units 的 bar 後的情況數，…，最多只可接上 <code>m</code> 個 units 的 bar。而新接上的 bar 的顏色必定與原本最後一個 bar 的顏色相反，由於只有黑白兩色，因此計算時不需考慮顏色。</li>
</ul>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">reference:</span></span><br><span class="line"><span class="comment">    https://ppt.cc/fr07lx</span></span><br><span class="line"><span class="comment">    https://ppt.cc/fzn4hx</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">51</span>][<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 當只有一個 bar 時，對於 m &gt;= n，dp[n][1][m] = 1 ( 只有一個黑色的 bar )</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= <span class="number">50</span>; ++n) <span class="keyword">for</span> (<span class="keyword">int</span> m = n; m &lt;= <span class="number">50</span>; ++m) dp[n][<span class="number">1</span>][m] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= <span class="number">50</span>; n++) <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">50</span>; k++) <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt;= <span class="number">50</span>; m++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 由於最多 n 個 units，因此當 m &gt; n 時，dp[n][k][m] = dp[n][k][n]，也就是無法再接 bar 上去</span></span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123; dp[n][k][m] = dp[n][k][n]; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="comment">// 新接上的 bar 寬度為 1 ~ m</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) dp[n][k][m] += dp[n - i][k - <span class="number">1</span>][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    compute();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; m) <span class="built_in">cout</span> &lt;&lt; dp[n][k][m] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fr07lx">[UVA] 10721 - Bar Codes | 水泥城式</a><br><a href="https://ppt.cc/fzn4hx">UVa/UVa 10721 - Bar Codes.cpp at master · ajahuang/UVa</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10755 解題紀錄</title>
    <url>/UVa-10755/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1696">UVa - 10755 - Garbage Heap</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 <code>A</code> * <code>B</code> * <code>C</code> 的長方體，長方體內每個單位都有數字，求最大的子長方體的數字和。</p>
<p><strong>Input：</strong> 第一個整數為 <code>T</code>，表示有 <code>T</code> 組測資，每組測資前三個整數依序為 <code>A</code>、<code>B</code>、<code>C</code>，後面 <code>A</code> * <code>B</code> * <code>C</code> 個數字為長方體內單位的數字。</p>
<p><strong>Output：</strong> 輸出最大的子長方體的數字和。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>Kadane’s Algorithm 題，依照二維壓成一維的概念將三維壓成二維，再將二維壓成一維之後使用 Kadane’s Algorithm 求解即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A, B, C;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> cuboid[<span class="number">21</span>][<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum2D[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B &gt;&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B; ++j) <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; C; ++k)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; cuboid[i][j][k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">max1D</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mx, ret;</span><br><span class="line">    mx = ret = sum[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; C; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        mx = max(mx + sum[i], sum[i]);</span><br><span class="line">        ret = max(mx, ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">max2D</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mx = LLONG_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; B; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; C; ++k) sum[k] += sum2D[j][k];</span><br><span class="line">            mx = max(max1D(), mx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mx = LLONG_MIN;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// max3D</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; A; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; B; ++k) <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; C; ++l) sum2D[k][l] += cuboid[j][k][l];</span><br><span class="line">            mx = max(max2D(), mx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(sum2D, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum2D));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mx &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">        <span class="keyword">if</span> (T) <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>UVa</tag>
        <tag>Kadane</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10765 解題紀錄</title>
    <url>/UVa-10765/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1706">UVa - 10765 - Doves and bombs</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>其實我不是太懂題目的意思，就以我理解的想法大致敘述一下。</p>
<p>給一個圖，求在圖上任意拿掉一點使得原本該點所在的連通圖會被分為幾個連通圖 ( 意思為在一個連通圖上拿掉一點，使得該連通圖被分為幾個連通圖 )，輸出前面幾個拿掉會造成原本的連通圖被分為最多個連通圖的點及連通圖的數量。</p>
<span id="more"></span>

<p><strong>Input：</strong> 每筆測資的第一行為兩整數 <code>n</code>、<code>m</code>，<code>n</code> 表示圖上有 n 個點 <code>(0 ~ N - 1)</code>，若 <code>n</code> 及 <code>m</code> 皆為 0 代表結束。接下來每行會有兩個整數 <code>u</code>、<code>v</code> 表示邊 <code>(u, v)</code> 是連通的，若 <code>u</code>、<code>v</code> 皆為 -1 代表結束。</p>
<p><strong>Output：</strong> 輸出前 <code>m</code> 大的結果 ( 值較大的在上面，若值相等則序號較小的在上面 )。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先讀取測資並建圖，之後 DFS，紀錄 DFS 時的序號及 low 值 ( 記錄節點 <code>u</code> 或 <code>u</code> 的子樹通過非父子邊追溯到最早的祖先節點 ( 即 DFS 的序號最小 ) )，之後根據<a class="lilink" href="../UVa%20-%20315/" target="_blank">割點的定義</a>，紀錄每個點被多少個點視為割點最後再加一即為該點的值，因為若一個點被另一個點視為割點，則該點拿掉的話會導致原本的連通圖變為兩個連通圖，同理，若被 N 個點視為割點則拿掉該點的話會導致原本的連通圖變為 N + 1 個連通圖。最後根據題目的要求排序並輸出即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">reference:</span></span><br><span class="line"><span class="comment">https://ppt.cc/foedPx</span></span><br><span class="line"><span class="comment">https://ppt.cc/fxMzyx</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> TIME;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dfn;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; low;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; G;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> parent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        dfn[u] = low[u] = ++TIME;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : G[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfn[v])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (v != parent) low[u] = min(dfn[v], low[u]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++child;</span><br><span class="line">            dfs(v, u);</span><br><span class="line">            low[u] = min(low[v], low[u]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 紀錄有幾個點將 u 視為割點</span></span><br><span class="line">            <span class="keyword">if</span> (low[v] &gt;= dfn[u] &amp;&amp; (child &gt;= <span class="number">2</span> || parent != <span class="number">-1</span>)) ++cnt[u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; (n || m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        TIME = <span class="number">0</span>;</span><br><span class="line">        dfn.assign(n, <span class="number">0</span>);</span><br><span class="line">        low.assign(n, <span class="number">0</span>);</span><br><span class="line">        cnt.assign(n, <span class="number">0</span>);</span><br><span class="line">        G.assign(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        ret.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &amp;&amp; !(u == <span class="number">-1</span> &amp;&amp; v == <span class="number">-1</span>))</span><br><span class="line">        &#123;   <span class="comment">// 無向圖，建雙向邊</span></span><br><span class="line">            G[u].push_back(v);</span><br><span class="line">            G[v].push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">if</span> (!dfn[i]) dfs(i, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最後要加一是因為若有一個節點將此點視為割點，則拿掉此點</span></span><br><span class="line">        <span class="comment">// 圖會被分為兩部分，若有 n 個，則為 n + 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) ret.push_back(&#123; i, cnt[i] + <span class="number">1</span> &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根據題目的要求排序 ( 值較大的在上面，若值相等則序號較小的在上面 )</span></span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; l, <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> l.second != r.second ? l.second &gt; r.second : l.first &lt; r.first;</span><br><span class="line">        &#125;;</span><br><span class="line">        sort(begin(ret), end(ret), cmp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) <span class="built_in">cout</span> &lt;&lt; ret[i].first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ret[i].second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/10765.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/foedPx">[UVA][關節點] 10765 - Doves and bombs＠Morris’ Blog｜PChome 個人新聞台</a><br><a href="https://ppt.cc/fxMzyx">UVa 10765 | 程式隨筆</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Recursive</tag>
        <tag>Graph</tag>
        <tag>Vector</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10783 解題紀錄</title>
    <url>/UVa-10783/</url>
    <content><![CDATA[<p>題目： <a href="https://zerojudge.tw/ShowProblem?problemid=c022">UVa - 10783 - Odd Sum</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>第一個數字代表有幾筆測資，每筆測資有兩個數字，題目要求算出兩數字間的奇數和 ( 包含兩數字 )。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 for 迴圈直接做即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, T, casenum = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a; i &lt;= b; ++i)</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                ans += i;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; casenum &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        ++casenum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/10783.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10806 解題紀錄</title>
    <url>/UVa-10806/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1747">UVa - 10806 - Dijkstra, Dijkstra.</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><blockquote>
<p>給你一個無向圖，每條邊有 cost，現在問如果不走已經走過的邊，則從 S 到 T，然後再從 T 到 S 的最少 cost 是多少，如果無法達成則輸出 “Back to jail”。</p>
</blockquote>
<p><a href="https://ppt.cc/frKlbx">Programming學習筆記: UVa 10806 Dijkstra, Dijkstra</a></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>建圖後求 MCMF 即可，由於是雙向圖，所以將路線的邊 Capacity 都設為 1，源點到監獄及終點到匯點的 Capacity 設為 2 即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt; b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(c) memset(c, 0, sizeof(c))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">QPOP</span><span class="params">(<span class="built_in">queue</span>&lt;T&gt;&amp; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MXN = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[MXN];</span><br><span class="line"><span class="keyword">int</span> c[MXN][MXN];</span><br><span class="line"><span class="keyword">int</span> f[MXN][MXN];</span><br><span class="line"><span class="keyword">int</span> cost[MXN][MXN];</span><br><span class="line"><span class="keyword">int</span> d[MXN];</span><br><span class="line"><span class="keyword">int</span> p[MXN];</span><br><span class="line"><span class="keyword">bool</span> inQ[MXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S, T;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> Cap = <span class="number">0</span>, <span class="keyword">int</span> Cost = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[u].push_back(v);</span><br><span class="line">    c[u][v] = Cap;</span><br><span class="line">    cost[u][v] = Cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T = N + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : e) v.clear();</span><br><span class="line">    CLR(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; M;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> u, v, C;</span><br><span class="line">    <span class="keyword">while</span> (M--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; C;</span><br><span class="line">        addEdge(u, v, <span class="number">1</span>, C);</span><br><span class="line">        addEdge(v, u, <span class="number">1</span>, C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEdge(S, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    addEdge(<span class="number">1</span>, S, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    addEdge(N, T, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    addEdge(T, N, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(d, d + MXN, INF);</span><br><span class="line">    d[S] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    CLR(inQ);</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    q.push(S);</span><br><span class="line">    inQ[S] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> u = QPOP(q);</span><br><span class="line">        inQ[u] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : e[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[u][v] &gt; f[u][v] &amp;&amp; d[u] + cost[u][v] &lt; d[v])</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] = d[u] + cost[u][v];</span><br><span class="line">                p[v] = u;</span><br><span class="line">                <span class="keyword">if</span> (!inQ[v]) q.push(v), inQ[v] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (f[v][u] &gt; <span class="number">0</span> &amp;&amp; d[u] + (-cost[v][u]) &lt; d[v])</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] = d[u] + (-cost[v][u]);</span><br><span class="line">                p[v] = u;</span><br><span class="line">                <span class="keyword">if</span> (!inQ[v]) q.push(v), inQ[v] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d[T] != INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">augment</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> bottleNeck)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == S) <span class="keyword">return</span> bottleNeck;</span><br><span class="line">    bottleNeck = augment(p[u], u, min(c[u][v] - f[u][v], bottleNeck));</span><br><span class="line">    f[u][v] += bottleNeck;</span><br><span class="line">    f[v][u] -= bottleNeck;</span><br><span class="line">    <span class="keyword">return</span> bottleNeck;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MCMF</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mnC = <span class="number">0</span>, mf = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (SPFA())</span><br><span class="line">    &#123;</span><br><span class="line">        mnC += d[T];</span><br><span class="line">        mf += augment(p[T], T, INF);</span><br><span class="line">        <span class="keyword">if</span> (mf &gt;= <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mf &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> mnC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> mnC = MCMF();</span><br><span class="line">    <span class="keyword">if</span> (mnC != <span class="number">-1</span>) <span class="built_in">cout</span> &lt;&lt; mnC &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Back to jail\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N &amp;&amp; N)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/frKlbx">Programming學習筆記: UVa 10806 Dijkstra, Dijkstra</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Queue</tag>
        <tag>Maximum Flow</tag>
        <tag>Edmonds-Karp</tag>
        <tag>SPFA</tag>
        <tag>MCMF</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10827 解題紀錄</title>
    <url>/UVa-10827/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1768">UVa - 10827 - Maximum sum on a torus</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 <code>N</code> * <code>N</code> 的矩陣，矩陣上有一些數字，求最大的子矩陣和，子矩陣可跨過邊界。</p>
<p><strong>Input：</strong> 第一個整數為 <code>T</code>，表示有 <code>T</code> 組測資，每組測資第一個整數為 <code>N</code>，後面 <code>N</code> * <code>N</code> 個數字為矩陣中的數字。</p>
<p><strong>Output：</strong> 求最大的子矩陣和，子矩陣可跨過邊界。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>Kadane’s Algorithm 題，將二維壓成一維之後使用 Kadane’s Algorithm 求解即可。</p>
<p>由於可跨過邊界，所以先將資料複製，將 <code>N</code> * <code>N</code> 複製為 <code>2N</code> * <code>N</code>，第 <code>N</code> 列與第 0 列相同，第 <code>N + 1</code> 列與第 1 列相同，…。如此可解決跨越上下的情況，而跨左右的子矩陣可視為整個矩陣減去最小子矩陣。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/f4CYbx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">76</span>];</span><br><span class="line"><span class="keyword">int</span> table[<span class="number">151</span>][<span class="number">76</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">        table[i][j] = table[i + N][j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max1D</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx, mxRet, mn, mnRet, total;</span><br><span class="line">    mx = mxRet = mn = mnRet = total = sum[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        total += sum[i];</span><br><span class="line"></span><br><span class="line">        mx = max(mx + sum[i], sum[i]);</span><br><span class="line">        mxRet = max(mx, mxRet);</span><br><span class="line">        </span><br><span class="line">        mn = min(mn + sum[i], sum[i]);</span><br><span class="line">        mnRet = min(mn, mnRet);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不可不選</span></span><br><span class="line">    <span class="keyword">if</span> (total == mnRet) <span class="keyword">return</span> mxRet;</span><br><span class="line">    <span class="keyword">return</span> max(mxRet, total - mnRet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// max2D</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; N; ++t)         <span class="comment">// top</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = t; b &lt; t + N; ++b) <span class="comment">// bottom</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) sum[i] += table[b][i];</span><br><span class="line">            mx = max(max1D(), mx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mx &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> C;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; C;</span><br><span class="line">    <span class="keyword">while</span> (C--)</span><br><span class="line">    &#123;</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/f4CYbx">UVa 10827 - Maximum sum on a torus | NaiveRed’s Blog</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>UVa</tag>
        <tag>Kadane</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10888 解題紀錄</title>
    <url>/UVa-10888/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1829">UVa - 10888 - Warehouse</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>推箱子遊戲，問最少需要幾步才可以將所有箱子 (B) 推到 X。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>建圖後求 MCMF 即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt; b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(c) memset(c, 0, sizeof(c))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">QPOP</span><span class="params">(<span class="built_in">queue</span>&lt;T&gt;&amp; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MXN = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> D[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[MXN];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; pb, po; <span class="comment">// position of B, position of #</span></span><br><span class="line"><span class="keyword">char</span> g[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[MXN][MXN];</span><br><span class="line"><span class="keyword">int</span> f[MXN][MXN];</span><br><span class="line"><span class="keyword">int</span> cost[MXN][MXN];</span><br><span class="line"><span class="keyword">int</span> d[MXN];</span><br><span class="line"><span class="keyword">int</span> p[MXN];</span><br><span class="line"><span class="keyword">bool</span> inQ[MXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S, T;</span><br><span class="line"><span class="keyword">int</span> X, Y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> Cap = <span class="number">0</span>, <span class="keyword">int</span> Cost = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[u].push_back(v);</span><br><span class="line">    c[u][v] = Cap;</span><br><span class="line">    cost[u][v] = Cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : e) v.clear();</span><br><span class="line">    pb.clear();</span><br><span class="line">    po.clear();</span><br><span class="line">    CLR(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Y &gt;&gt; X;</span><br><span class="line">    FOR(i, <span class="number">0</span>, Y) FOR(j, <span class="number">0</span>, X)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; g[i][j];</span><br><span class="line">        <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;B&#x27;</span>) pb[&#123;i, j&#125;] = pb.size() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (g[i][j] == <span class="string">&#x27;X&#x27;</span>) po[&#123;i, j&#125;] = po.size() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T = pb.size() + po.size() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(dist[<span class="number">0</span>], dist[<span class="number">0</span>] + <span class="number">50</span> * <span class="number">50</span>, INF);</span><br><span class="line">    dist[y][x] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    q.push(&#123; y, x &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [_y, _x] = QPOP(q);</span><br><span class="line"></span><br><span class="line">        FOR(i, <span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> dy = _y + D[i], dx = _x + D[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (dy &lt; <span class="number">0</span> || dy &gt;= Y || dx &lt; <span class="number">0</span> || dx &gt;= X || g[dy][dx] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (dist[dy][dx] == INF) q.push(&#123; dy, dx &#125;);</span><br><span class="line">            dist[dy][dx] = min(dist[_y][_x] + <span class="number">1</span>, dist[dy][dx]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [boxPos, u] : pb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; [y, x] = boxPos;</span><br><span class="line"></span><br><span class="line">        bfs(y, x);</span><br><span class="line"></span><br><span class="line">        addEdge(S, u, <span class="number">1</span>);</span><br><span class="line">        addEdge(u, S);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [pos, v] : po)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; [dy, dx] = pos;</span><br><span class="line">            v += pb.size();</span><br><span class="line"></span><br><span class="line">            addEdge(u, v, <span class="number">1</span>, dist[dy][dx]);</span><br><span class="line">            addEdge(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [_, v] : po)</span><br><span class="line">    &#123;</span><br><span class="line">        v += pb.size();</span><br><span class="line"></span><br><span class="line">        addEdge(v, T, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        addEdge(T, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(d, d + MXN, INF);</span><br><span class="line">    d[S] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    CLR(inQ);</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    q.push(S);</span><br><span class="line">    inQ[S] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> u = QPOP(q);</span><br><span class="line">        inQ[u] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : e[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[u][v] &gt; f[u][v] &amp;&amp; d[u] + cost[u][v] &lt; d[v])</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] = d[u] + cost[u][v];</span><br><span class="line">                p[v] = u;</span><br><span class="line">                <span class="keyword">if</span> (!inQ[v]) q.push(v), inQ[v] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (f[v][u] &gt; <span class="number">0</span> &amp;&amp; d[u] + (-cost[v][u]) &lt; d[v])</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] = d[u] + (-cost[v][u]);</span><br><span class="line">                p[v] = u;</span><br><span class="line">                <span class="keyword">if</span> (!inQ[v]) q.push(v), inQ[v] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d[T] != INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">augment</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> bottleNeck)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == S) <span class="keyword">return</span> bottleNeck;</span><br><span class="line">    bottleNeck = augment(p[u], u, min(c[u][v] - f[u][v], bottleNeck));</span><br><span class="line">    f[u][v] += bottleNeck;</span><br><span class="line">    f[v][u] -= bottleNeck;</span><br><span class="line">    <span class="keyword">return</span> bottleNeck;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MCMF</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mnC = <span class="number">0</span>, mf = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (SPFA())</span><br><span class="line">    &#123;</span><br><span class="line">        mnC += d[T];</span><br><span class="line">        mf += augment(p[T], T, INF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mnC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    build();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; MCMF() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Queue</tag>
        <tag>Maximum Flow</tag>
        <tag>Edmonds-Karp</tag>
        <tag>SPFA</tag>
        <tag>MCMF</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10901 解題紀錄</title>
    <url>/UVa-10901/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=0&problem=1842">UVa - 10901 - Ferry Loading III</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>有一艘可以載車子的船，兩岸分別有一些要到達對岸的車子。船只有一艘，且一開始在左岸，當船目前所在的岸沒有車子，而對岸有車時，船必須直接過去載車，若是兩岸目前都沒有車，則船可以維持不動。而船上只要一有車就必須開到對岸，不可以等後面的車到達才開船。</p>
<span id="more"></span>

<p><strong>Input：</strong> 第一行為一整數 <code>T</code>，代表有 <code>T</code> 組測資，每組測資第一行為三個整數 <code>n</code>, <code>t</code>, <code>m</code>，分別代表 <code>船上能載的車子最大數量</code>、<code>船從一岸到達另一岸所需要的時間</code>、<code>需要過岸的車子數量</code>。接下來 <code>m</code> 行，每行有一個整數及一個字串，整數代表車子到達岸邊的時間，字串只會為 <code>&quot;left&quot;</code> 或 <code>&quot;right&quot;</code> 代表車子到達的那個岸邊。</p>
<p><strong>Output：</strong> 按照 Input 時車子的順序輸出車子到達對岸的時間。每組測資中間需以空行隔開。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用兩個 Queue 代表左岸及右岸，存放車子的編號 ( 代表順序 ) 及到達的時間。接著定義 <code>time</code> 為目前的時間，<code>cur</code> 為目前的位置 ( 0 為左岸，1 為右岸 )。每次執行時，先取得兩岸最先到達的車子的時間，接著更新 <code>time</code>，若是 <code>time</code> 變大代表在這段期間內船都在等車子到達，之後船就必須開到對岸了，因為不管先到達的是目前的岸還是對岸，船都必須開到對岸，開船前會將目前岸上的車子移到船上 ( 紀錄時間並直接 <code>pop()</code> 掉 )，最後更新 <code>time</code> 及 <code>cur</code> 即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fNbc8x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n, t, m;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; t &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; bank[<span class="number">2</span>]; <span class="comment">// 0 for left, 1 for right</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">arriveTime</span><span class="params">(m)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> [tmp, str] = <span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="built_in">string</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; tmp &gt;&gt; str;</span><br><span class="line">            str == <span class="string">&quot;left&quot;</span> ? bank[<span class="number">0</span>].emplace(i, tmp) : bank[<span class="number">1</span>].emplace(i, tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> [time, cur] = <span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (!bank[<span class="number">0</span>].empty() || !bank[<span class="number">1</span>].empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> closest = INT_MAX;</span><br><span class="line">            <span class="keyword">if</span> (!bank[<span class="number">0</span>].empty()) closest = bank[<span class="number">0</span>].front().second;</span><br><span class="line">            <span class="keyword">if</span> (!bank[<span class="number">1</span>].empty()) closest = min(closest, bank[<span class="number">1</span>].front().second);</span><br><span class="line"></span><br><span class="line">            time = max(time, closest);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!bank[cur].empty() &amp;&amp; cnt &lt; n &amp;&amp; bank[cur].front().second &lt;= time)</span><br><span class="line">            &#123;</span><br><span class="line">                arriveTime[bank[cur].front().first] = time + t;</span><br><span class="line">                bank[cur].pop();</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cur ^= <span class="number">1</span>;</span><br><span class="line">            time += t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : arriveTime) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (T) <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/10901.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fNbc8x">UVa 10901 - Ferry Loading III.cpp</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Queue</tag>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10912 解題紀錄</title>
    <url>/UVa-10912/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=1853">UVa - 10912 - Simple Minded Hashing</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>26 個英文字母，依序從 1 開始編號，a = 1, b = 2, …, z = 26。</p>
<p>給兩個整數 L、S，求使用 L 個英文字母，組成編號總和為 S 的嚴格遞增字串的字串個數。</p>
<span id="more"></span>

<p><strong>Input：</strong> 每組測資有兩個整數，依序為 <code>L</code>、<code>S</code>。若皆為 0 表結束。</p>
<p><strong>Output：</strong> 輸出使用 <code>L</code> 個英文字母，組成編號總和為 <code>S</code> 的嚴格遞增字串的字串個數。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>動態規劃題，由於測資範圍不大，因此先算出所有情況的答案再輸出即可。</p>
<p>由於組成的字串必須是嚴格遞增，因此最多只會有 26 個字母，且編號總和最大為 351 ( 1 + 2 + … + 26 )。</p>
<p>定義 <code>dp[i][j][k]</code> 表只使用前 <code>i</code> 個字母 ( 編號 1 ~ <code>i</code> 的字母 )，組成長度為 <code>j</code>，總和為 <code>k</code> 的字串的所有情況數，先設定初始狀態 <strong>dp[n][1][n] = 1，對於所有 1 &lt;= n &lt;= 26</strong>，因為若只有一個字母，組成與自己編號總和相同的字串，必定就是只有自己一種情況而已。</p>
<p>對於 <code>dp[i][j][k]</code>：</p>
<ul>
<li>若 <code>k &lt; i</code>，表示 <code>i</code> 無法出現在字串中，則 <code>dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j][k])</code>。</li>
<li>若 <code>k &gt;= i</code>，表示 <code>i</code> 可以出現在字串中，則 <code>dp[i][j][k] += dp[i - 1][j - 1][k - i]</code>，可以理解為若要將 <code>i</code> 放入字串中，可能數為 最大可能字母為 <code>i - 1</code>，長度為 <code>j - 1</code>，總和為 <code>k - i</code> 的字串，因為將 <code>i</code> 接上後會組成 最大可能字母為 <code>i</code>，長度為 <code>j</code>，總和為 <code>k</code> 的字串。</li>
</ul>
<p>簡單來說，就是不斷枚舉是否能將字母放入最後一位，若無法則至少情況數會是 <code>i - 1</code> 的情況數，這樣才符合最初 <code>dp</code> 數組的定義。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/f8d2Lx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Cas;</span><br><span class="line"><span class="keyword">int</span> L, S;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">27</span>][<span class="number">27</span>][<span class="number">352</span>]; <span class="comment">// dp[i][j][k] 表只使用前 i 個字母，組成長度為 j，總和為 k 的字串的所有情況數</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; ++i) dp[i][<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">351</span>; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j][k] += dp[i - <span class="number">1</span>][j][k];</span><br><span class="line">            <span class="comment">// 判斷是否能將 i 接上</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt;= i) dp[i][j][k] += dp[i - <span class="number">1</span>][j - <span class="number">1</span>][k - i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    compute();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; L &gt;&gt; S &amp;&amp; L &amp;&amp; S)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; ++Cas &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="comment">// 由於嚴格遞增，因此最多 26 個字母，S 最大為 351</span></span><br><span class="line">        <span class="keyword">if</span> (L &gt; <span class="number">26</span> || S &gt; <span class="number">351</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; dp[<span class="number">26</span>][L][S] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由於只需要使用 26 個字母的情況，所以可以縮一維。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, a, b) for(int i = a; i &lt; b; ++i)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> L, S;</span><br><span class="line"><span class="keyword">int</span> C;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">27</span>][<span class="number">352</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    FOR(i, <span class="number">1</span>, <span class="number">27</span>) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">26</span>; j &gt; <span class="number">0</span>; --j) FOR(k, i, <span class="number">352</span>)</span><br><span class="line">        dp[j][k] += dp[j - <span class="number">1</span>][k - i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    compute();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; L &gt;&gt; S &amp;&amp; (L || S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; ++C &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (L &gt; <span class="number">27</span> || S &gt; <span class="number">351</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; dp[L][S] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/f8d2Lx">UVa/10912 - Simple Minded Hashing.cpp at master · morris821028/UVa</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10935 解題紀錄</title>
    <url>/UVa-10935/</url>
    <content><![CDATA[<p>題目： <a href="https://zerojudge.tw/ShowProblem?problemid=e155">UVa - 10935 - Throwing cards away I</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>每筆測資為一個數字 n，會有一個 1 ~ n 的紙牌堆，題目要求丟掉最上面的牌，然後把目前最上面的那張牌放到牌堆的最下面。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>利用 queue 先進先出的特性，先輸出 <code>front()</code> 然後 <code>pop()</code> 掉，再把 <code>front()</code> <code>push()</code> 進去，最後再 <code>pop()</code> 即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">queue</span>&lt; <span class="keyword">int</span> &gt; cards;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((<span class="built_in">cin</span> &gt;&gt; n) &amp;&amp; n != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            cards.push(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cards.size() == <span class="number">1</span>) <span class="comment">// 當只有一張卡時直接印出即可</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Discarded cards:&quot;</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;Remaining card: &quot;</span> &lt;&lt; cards.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Discarded cards: &quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (cards.size() &gt; <span class="number">2</span>) <span class="comment">// 先輸出最上面的卡然後移出，再將第一張放到最後面再移出</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; cards.front() &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">                cards.pop();</span><br><span class="line">                cards.push(cards.front());</span><br><span class="line">                cards.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cards.front(); <span class="comment">// 輸出倒數第二張牌</span></span><br><span class="line">            cards.pop();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;Remaining card: &quot;</span> &lt;&lt; cards.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cards.pop(); <span class="comment">// 將 queue 清空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/10935.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10943 解題紀錄</title>
    <url>/UVa-10943/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=1884">UVa - 10943 - How do you add?</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個整數 <code>N</code>、<code>K</code>，求將 <code>N</code> 拆為 <code>K</code> 個小於等於 <code>N</code> 的數字相加的所有情況數。不同排序視為不同情況，如 20 + 0，0 + 20 為兩種情況。</p>
<p>題目看不是很懂，好像計算的時候要隨時取 1000000 的餘數。</p>
<span id="more"></span>

<p><strong>Input：</strong> 每組測資有兩個整數，依序為 <code>N</code>、<code>K</code>，若 <code>N</code>、<code>K</code> 皆為 0 表結束。</p>
<p><strong>Output：</strong> 輸出將 <code>N</code> 拆為 <code>K</code> 個小於等於 <code>N</code> 的數字相加的所有情況數。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>動態規劃題，由於測資範圍不大，因此先算出所有情況的答案再輸出即可。</p>
<p>定義 <code>dp[i][j]</code> 表 <code>i</code> 拆成 <code>j</code> 個數字的方法數，先設定初始狀態，<strong>dp[i][1] = 1, 對於所有 0 &lt;= i &lt; 101</strong>，因為任何數拆成一個數字相加只會有一個情況，就是自己。</p>
<p>對於 <code>dp[i][j]</code>:<br><strong>dp[i][j] = (dp[i][j] + dp[i - k][j - 1]) % 1000000，對於所有 0 &lt;= k &lt;= i。</strong><br>可以想像為，將 <code>i</code> 拆為 <code>k</code> 及 <code>i - k</code> 相加，而 <code>i - k</code> 由 <code>j - 1</code> 個數字相加組成，這樣組合起來的意義即為使用 <code>j</code> 個數字組合成 <code>i</code>。<br>簡單來說，就是不斷枚舉加入最後一位數字，並將所有情況數相加即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fMOZjx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">101</span>][<span class="number">101</span>]; <span class="comment">// dp[i][j] 表 i 拆成 j 個數字的方法數</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; ++i) dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">101</span>; ++j) <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= i; ++k)</span><br><span class="line">        dp[i][j] = (dp[i][j] + dp[i - k][j - <span class="number">1</span>]) % <span class="number">1000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    compute();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K &amp;&amp; N &amp;&amp; K) <span class="built_in">cout</span> &lt;&lt; dp[N][K] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fMOZjx">UVa 10943 - How do you add?_小白菜又菜-CSDN博客</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11034 解題紀錄</title>
    <url>/UVa-11034/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&category=0&problem=1975">UVa - 11034 - Ferry Loading IV</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>有一艘可以載車子的船，兩岸分別有一些要到達對岸的車子，船有長度限制，在不超過船的長度限制的前提下，要放多少輛車都可以。在岸邊的車子有先後順序之分，在載完前面的車子前，不可以載後面的車子。</p>
<span id="more"></span>

<p><strong>Input：</strong> 第一行為一個整數 <code>T</code>，代表有 <code>T</code> 組測資，每組測資第一行為兩個整數 <code>l</code>, <code>m</code>，分別代表 <code>船的長度</code> ( 船的長度的單位為車子長度的單位的一百倍 ) 及 <code>需要過岸的車子數量</code>，接下來 <code>m</code> 行，每行有一個整數及一個字串，整數代表車子的長度，字串只會為 <code>&quot;left&quot;</code> 或 <code>&quot;right&quot;</code> 代表車子所在的那個岸邊。</p>
<p><strong>Output：</strong> 求將所有車子都移到各自的對岸，船需要走幾趟 ( 來回算兩趟 )。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用兩個 Queue 代表左岸及右岸，儲存車子的長度，之後模擬操作即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fNbc8x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, m;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0 for left, 1 for right</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; bank[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> [tmp, str] = <span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="built_in">string</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; tmp &gt;&gt; str;</span><br><span class="line">            str == <span class="string">&quot;left&quot;</span> ? bank[<span class="number">0</span>].push(tmp) : bank[<span class="number">1</span>].push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!bank[<span class="number">0</span>].empty() || !bank[<span class="number">1</span>].empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> Cap = l * <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">while</span> (!bank[cur].empty() &amp;&amp; bank[cur].front() &lt;= Cap)</span><br><span class="line">                Cap -= bank[cur].front(), bank[cur].pop();</span><br><span class="line">            cur ^= <span class="number">1</span>;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/11034.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fNbc8x">UVa 10901 - Ferry Loading III.cpp</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 1108 解題紀錄</title>
    <url>/UVa-1108/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=3549">UVa - 1108 - Mining Your Own Business</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個連通的無向圖，求最少在圖上標記幾個點，使得圖上任意一點崩塌 ( 被拿掉 ) 後，其他所有的點都能夠走到被標記的點。</p>
<span id="more"></span>

<p><strong>Input：</strong> 每組測資起始於一整數 <code>N</code>，若 <code>N</code> 為 0 代表結束，否則下面 <code>N</code> 行，每行會有兩個整數 <code>u</code>、<code>v</code>，表示圖上有邊 <code>(u, v)</code>。</p>
<p><strong>Output：</strong> 輸出最少需要標記的點及標記點的方法數。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>解這道題首先需要求出 Binconnected component ( 以下簡稱為 BCC )，因為在 BCC 上拿掉任意一點都不會打破原本的連通性 ( 因為 BCC 上沒有割點 )，之後我們可以發現，因為原本圖是連通的，所以我們只需要在 <strong>只有連接到另一個 BCC 的 BCC</strong> 上有標記點即可，因為若一個 BCC 連接到兩個以上的 BCC，則在整張圖上拿掉任意一點，在這個 BCC 上的點都可以走到其他的 BCC 上被標記的點。我們也可以發現，雖然標記在割點上能使得連接到的 BCC 都能走到，能夠達到標記最少的點，但是若被拿掉的是割點則會打破原本連通性的導致連接到的 BCC 都不能走到被標記的點，所以不能標記在割點上。</p>
<p>這道題需使用兩次 DFS ( 一次或許可以，但我不會 )，為了方便理解，將解法分成以下幾個步驟。</p>
<ol>
<li><p>讀取測資並建圖，記得建雙向，因為是無向圖。</p>
</li>
<li><p>在圖上進行一次 DFS，根據<a class="lilink" href="../UVa%20-%20315/" target="_blank">割點的定義</a>找出所有割點。</p>
</li>
<li><p>再進行一次 DFS，找出所有 BCC 連接的割點數量 ( 即表示 BCC 連接到其他 BCC 的數量 )，若只有 1 則將此 BCC 的節點數保存。</p>
</li>
<li><p>最後的方法數即為第三步所有保存的 BCC 的節點數相乘 ( 在每個 BCC 上選任意一點標記 )，標記點的數量即為保存的 BCC 的個數。</p>
</li>
</ol>
<p>需要注意的是，<strong>若整張圖就是一個 BCC，則只需要在上面任意標記兩點</strong>，方法數則為 <code>n * (n - 1) / 2</code>， n 為點的數量。</p>
<p><strong>方法數需使用 long long 運算及保存</strong></p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">reference:</span></span><br><span class="line"><span class="comment">題目: https://ppt.cc/fkzEYx</span></span><br><span class="line"><span class="comment">解題想法: https://ppt.cc/fbXXcx</span></span><br><span class="line"><span class="comment">雙連通分量: https://ppt.cc/fs5cxx</span></span><br><span class="line"><span class="comment">Code: https://ppt.cc/fsPeKx</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> TIME;</span><br><span class="line"><span class="keyword">int</span> comSize;               <span class="comment">// 目前遍歷的 Biconnected component 的節點數</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; dfn;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; low;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; G;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; isCut;  <span class="comment">// 儲存所有割點</span></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; adjCut; <span class="comment">// 一個 Biconnected component 連接到的割點</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    dfn[u] = low[u] = ++TIME;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : G[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (v != parent) low[u] = min(dfn[v], low[u]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++child;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">        low[u] = min(low[v], low[u]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 記錄所有割點</span></span><br><span class="line">        <span class="keyword">if</span> (low[v] &gt;= dfn[u] &amp;&amp; (child &gt;= <span class="number">2</span> || parent != <span class="number">-1</span>)) isCut.insert(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findAns</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    visited.insert(u);</span><br><span class="line">    ++comSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : G[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.count(v) || isCut.count(v))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果 v 是割點</span></span><br><span class="line">            <span class="keyword">if</span> (isCut.count(v)) adjCut.insert(v);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        findAns(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, Case = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N &amp;&amp; N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        TIME = <span class="number">0</span>;</span><br><span class="line">        dfn.clear();</span><br><span class="line">        low.clear();</span><br><span class="line">        G.clear();</span><br><span class="line">        isCut.clear();</span><br><span class="line">        visited.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build the graph</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line"></span><br><span class="line">            G[u].push_back(v);</span><br><span class="line">            G[v].push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尋找所有割點</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [u, __] : G) <span class="keyword">if</span> (!dfn[u]) dfs(u, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; D; <span class="comment">// 儲存每個 Biconnected component 的節點數量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [u, __] : G)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.count(u) || isCut.count(u)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            comSize = <span class="number">0</span>;</span><br><span class="line">            adjCut.clear();</span><br><span class="line">            findAns(u);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果遍歷到的 Biconnected component 只連接到一個割點才需要有標記點</span></span><br><span class="line">            <span class="keyword">if</span> (adjCut.size() == <span class="number">1</span>) D.push_back(comSize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Biconnected component 的個數代表最少需要有幾個標記點 ( 個數不為 1 的情況 )</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ways = <span class="number">1</span>, mn = D.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : D) ways *= i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果整個圖本身為一個 Biconnected component，則任選兩點標記，mn 為 2</span></span><br><span class="line">        <span class="keyword">if</span> (D.empty()) ways = (<span class="keyword">long</span> <span class="keyword">long</span>)G.size() * (G.size() - <span class="number">1</span>) / <span class="number">2</span>, mn = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; ++Case &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; mn &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ways &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/01108.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fkzEYx">Mining Your Own Business - 洛谷</a><br><a href="https://ppt.cc/fbXXcx">UVA 1108 Mining Your Own Business ( 點雙連通分量 ) - 0w1</a><br><a href="https://ppt.cc/fs5cxx">(Template) Connected component</a><br><a href="https://ppt.cc/fsPeKx">UVa 1108 - Mining Your Own Business | Morris’ Blog</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Map</tag>
        <tag>Recursive</tag>
        <tag>Graph</tag>
        <tag>Vector</tag>
        <tag>Unordered_set</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10954 解題紀錄</title>
    <url>/UVa-10954/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=1895">UVa - 10954 - Add All</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一些數字，將數字全部相加，相加的過程需要成本，例如 <code>1 + 3 = 4</code>，則成本為 <code>4</code>，求將數字全部相加後的成本為何。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>每次選擇最小的兩者相加即可花費最少的成本。使用 Priority_queue，每次取兩個最小的數字出來相加即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, tmp;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n--) <span class="built_in">cin</span> &gt;&gt; tmp, pq.push(tmp);</span><br><span class="line">        <span class="keyword">while</span> (pq.size() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = pq.top(); pq.pop();</span><br><span class="line">            n1 += pq.top(), pq.pop();</span><br><span class="line">            ret += n1;</span><br><span class="line">            pq.push(n1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        pq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/10954.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Vector</tag>
        <tag>Priority_queue</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11096 解題紀錄</title>
    <url>/UVa-11096/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=2037">UVa - 11096 - Nails</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一些在二維平面的座標點，求包住所有座標點的最小多邊形的周長。</p>
<p><strong>Input：</strong> 第一個整數 <code>T</code>，表示有 <code>T</code> 組測資，每組測資的前兩個整數分別代表 <code>l</code>、<code>N</code>，後面 <code>N</code> 行每行有兩個整數表示座標點。</p>
<p><strong>Output：</strong> 輸出包住所有座標點的最小多邊形的周長，若小於 <code>l</code> 則輸出 <code>l</code>。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p><strong>此解法需要有 Convex Hull 及 Graham Scan 演算法的概念</strong></p>
<p>簡單的凸包題，使用 Graham Scan 演算法找出所有頂點，之後計算周長即可。<strong>需要注意的是，若 n 為二，則周長為兩點距離乘二。</strong></p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt; b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(c) memset(c, 0, sizeof(c))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fqcIxx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MXN = <span class="number">102</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> d; <span class="comment">// 與第一個點的距離</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point P[MXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> top; <span class="comment">// 凸包頂點數</span></span><br><span class="line"><span class="keyword">double</span> l;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 兩點間的距離</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">const</span> Point&amp; l, <span class="keyword">const</span> Point&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(l.x - r.x, <span class="number">2</span>) + <span class="built_in">pow</span>(l.y - r.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">crossProduct</span><span class="params">(<span class="keyword">const</span> Point&amp; o, <span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.x - o.x) * (b.y - o.y) - (b.x - o.x) * (a.y - o.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 選出最下面的點，若有相同 y 的點則選擇 x 較小的那個</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">const</span> Point&amp; l, <span class="keyword">const</span> Point&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l.y == r.y ? l.x &lt; r.x : l.y &lt; r.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 極角排序，cp &gt; 0: ol -&gt; or 逆時針</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">const</span> Point&amp; l, <span class="keyword">const</span> Point&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cp = crossProduct(P[<span class="number">0</span>], l, r);</span><br><span class="line">    <span class="keyword">return</span> cp == <span class="number">0</span> ? l.d &lt; r.d : cp &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; N;</span><br><span class="line">    FOR(i, <span class="number">0</span>, N) <span class="built_in">cin</span> &gt;&gt; P[i].x &gt;&gt; P[i].y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convex Hull</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GrahamScan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找出第一個點，並將其他點依照極角排序</span></span><br><span class="line">    sort(P, P + N, cmp1);</span><br><span class="line">    FOR(i, <span class="number">1</span>, N) P[i].d = dist(P[<span class="number">0</span>], P[i]);</span><br><span class="line">    sort(P + <span class="number">1</span>, P + N, cmp2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找凸包</span></span><br><span class="line">    top = <span class="number">1</span>;</span><br><span class="line">    FOR(i, <span class="number">2</span>, N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">0</span> &amp;&amp; crossProduct(P[top - <span class="number">1</span>], P[top], P[i]) &lt;= <span class="number">0</span>) --top;</span><br><span class="line">        P[++top] = P[i];</span><br><span class="line">    &#125;</span><br><span class="line">    P[++top] = P[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (N &gt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GrahamScan();</span><br><span class="line">        FOR(i, <span class="number">0</span>, top) sum += dist(P[i], P[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (N == <span class="number">2</span>) sum = dist(P[<span class="number">0</span>], P[<span class="number">1</span>]) * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">5</span>) &lt;&lt; fixed &lt;&lt; max(sum, l) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fqcIxx">UVa 11096 - Nails_小白菜又菜-CSDN博客</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Convex Hull</tag>
        <tag>Graham Scan</tag>
        <tag>Computational Geometry</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 1112 解題紀錄</title>
    <url>/UVa-1112/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3553">UVa - 1112 - Mice and Maze</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一張有向圖，走過每條邊都需要一些時間，從圖上任意點走需要最少時間的路徑到終點，求有多少點可以在限定的時間內走到。</p>
<span id="more"></span>

<p><strong>Input：</strong> 第一行為一個整數，表示有幾組測資，每組測資一開始有四個整數 <code>n</code>、<code>end</code>、<code>time</code>、<code>m</code>，表示 有 <code>n</code> 個點 <code>(1 ~ n)</code>、終點為 <code>end</code>、限定時間為 <code>time</code>、有 <code>m</code> 條邊。後面 <code>m</code> 行，每行有 3 個整數 <code>u</code>、<code>v</code>、<code>w</code>，表示有邊可以從 u 走到 v，需要的時間為 <code>w</code>。</p>
<p><strong>Output：</strong> 求有多少點可以在限定的時間內走到終點。需要注意的是，<strong>終點本身也算一個點</strong>。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p><strong>這個解法需要有 Dijkstra 演算法的概念。</strong></p>
<p>若模擬從每個點開始，會非常沒效率，所以我們可以將題目轉換一下，將圖上的所有邊反向，從終點開始，走到圖上各點花費的時間跟從各點走到終點是一樣的，這樣只需要做一次就可以了。</p>
<p>使用 Dijkstra 搭配 Priority_queue 求解即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fU8XZx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> point&amp; r) <span class="keyword">const</span> &#123; <span class="keyword">return</span> w &gt; r.w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// data</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; edges;</span><br><span class="line"><span class="keyword">int</span> value[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">101</span>];</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;point, <span class="built_in">vector</span>&lt;point&gt;, greater&lt;point&gt;&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edges.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) value[i] = INT_MAX, visited[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pq.push(&#123; start, value[start] = <span class="number">0</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [u, val] = pq.top();</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        pq.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [v, w] : edges[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp = val + w;</span><br><span class="line">            <span class="keyword">if</span> (value[v] &gt; tmp) pq.push(&#123; v, value[v] = tmp &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n, end, time, m;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; end &gt;&gt; time &gt;&gt; m;</span><br><span class="line">        init(n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, w;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反向建邊</span></span><br><span class="line">            edges[v].push_back(&#123; u, w &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 從終點開始</span></span><br><span class="line">        dijkstra(end);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (value[i] &lt;= time) ++ret;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (T) <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/01112.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fU8XZx">[題解] UVa 1112 - Mice and Maze</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Unordered_map</tag>
        <tag>Graph</tag>
        <tag>Priority_queue</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11136 解題紀錄</title>
    <url>/UVa-11136/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=2077">UVa - 11136 - Hoax or what</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>超市進行促銷，把帳單放入一個箱子中，每天會放入一些帳單，接著取出金額最大及最小的帳單，並且支付 <code>最大 - 最小</code> 的金額，求 <code>n</code> 天後總共需要支付多少錢。<span id="more"></span></p>
<p><strong>Input：</strong> 每組測資起始於一個整數 <code>n</code>，代表接下來有 <code>n</code> 行資料代表放入的帳單，若 <code>n</code> 為 0 代表結束，每行資料起始於一個整數 <code>num</code>，表示今天有 <code>num</code> 筆帳單要放入，中間以空格隔開。</p>
<p><strong>Output：</strong> 輸出每組測資經過 n 天後總共需要支付多少錢。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 Multiset 儲存帳單，接著每天從頭跟尾取出資料即可。使用 Multiset 的原因是可能會有兩張相同金額的帳單。<strong>需要注意的是因為測資的大小，所以結果使用 <code>long long</code> 儲存。</strong></p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num, tmp;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num; ++j) <span class="built_in">cin</span> &gt;&gt; tmp, s.insert(tmp);</span><br><span class="line">            <span class="keyword">auto</span> l = s.begin(), r = --s.end();</span><br><span class="line">            ret += *r - *l;</span><br><span class="line">            s.erase(l), s.erase(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/11136.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Multiset</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10972 解題紀錄</title>
    <url>/UVa-10972/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=1913">UVa - 10972 - RevolC FaeLoN</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個無向圖，現在要把圖轉換成有向圖，且邊可以任意定向 ( 即原本邊 <code>(u, v)</code>，可以變為 <code>u -&gt; v</code> 或 <code>v -&gt; u</code> )。求需要加幾條邊才能使得轉換後的圖形為強連通 ( 即在有向圖上任意選兩點 <code>u</code>、<code>v</code>，<code>u</code> 能夠走到 <code>v</code> 且 <code>v</code> 也能夠走到 <code>u</code> )。</p>
<span id="more"></span>

<p><strong>Input：</strong> 每組測資的第一行為兩個整數 <code>n</code>、<code>m</code>，分別代表 <code>點的數量</code>、<code>邊的數量</code>，後面 <code>m</code> 行每行有兩個整數 <code>u</code>、<code>v</code>，表示圖上有邊 <code>(u, v)</code>。</p>
<p><strong>Output：</strong> 輸出最少需要加幾條邊使得圖轉換成有向圖後會是強連通。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>我們可以發現，無向圖中的 Bridge Connected Component ( 以下簡稱 BCC，<strong>注意不是 Biconnected component</strong> )，在把邊任意定向後一定可以變成一個強連通分量，原因在於強連通分量其實類似於無向圖中的環，詳細說明可參考本篇文章：<a href="https://ppt.cc/fXERhx">【RevolC FaeLoN Uva 10972】 - 大米饼 - 博客园</a>。</p>
<p>所以可以得出圖上 BCC 內的點其實不影響我們求解的結論，因此我們把圖上的所有 BCC 各自視為一個點 ( 即縮點的概念 )，而原本的 Bridge 會將這些點連接起來，接下來我們要做的就是使這些點強連通，對於縮點後的所有葉子節點，我們需要 <code>(N + 1) / 2</code> 條邊才能連接起來，N 為葉子節點的數量，對於縮點後的孤立點 ( 因為題目的圖不保證連通，所以可能會產生沒有連接到其他 BCC 也沒有被其他 BCC 連入的 BCC )，則需要 <code>M</code> 條邊才能連接起來，<code>M</code> 為孤立點的數量。至於原因請參考本篇文章：<a href="https://ppt.cc/fXERhx">【RevolC FaeLoN Uva 10972】 - 大米饼 - 博客园</a>。</p>
<p>解法分為以下幾個步驟：</p>
<ol>
<li><p>讀取測資並建圖，記得建雙向，因為是無向圖。</p>
</li>
<li><p>DFS 找出 BCC 的數量，因為若整張圖本身就是一個 BCC 則不需要增加任何邊。</p>
</li>
<li><p>根據 DFS 算出的 low 值取得 BCC 的連接情況。</p>
</li>
<li><p>最後根據上面的方法算出需要增加的邊即可。</p>
</li>
</ol>
<p><strong>註：</strong> 根據 low 值判斷 BCC 的情況可能不是很正確，因為一個 BCC 內的所有節點的 low 值不一定全部一樣，但是在這個題目中不影響，因為一個被視為葉子節點的 BCC，若被視為兩個 BCC，則原本的 BCC 一定被誤認為的 BCC 所連接，因此葉子節點的數量不改變。<br>其實可以使用一個數組保存 BCC 的情況再求解應該會更好，不過現在有點懶，之後再寫吧。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* reference:</span></span><br><span class="line"><span class="comment">想法: https://ppt.cc/fXERhx</span></span><br><span class="line"><span class="comment">Code: https://ppt.cc/fNsXNx</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;      <span class="comment">// input</span></span><br><span class="line"><span class="keyword">int</span> TIME;</span><br><span class="line"><span class="keyword">int</span> bcnt;      <span class="comment">// bridge connected component 的數量</span></span><br><span class="line"><span class="keyword">int</span> dfn[<span class="number">1001</span>]; <span class="comment">// dfs 時的序號</span></span><br><span class="line"><span class="keyword">int</span> low[<span class="number">1001</span>]; <span class="comment">// dfs 時的 low 值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出 bridge connected component</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++TIME;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : G[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (v != parent) low[u] = min(dfn[v], low[u]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(v, u);</span><br><span class="line">        low[u] = min(low[v], low[u]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到一個橋，bridge connected component 的數量加一</span></span><br><span class="line">        <span class="keyword">if</span> (low[v] &gt; dfn[u]) ++bcnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果整張圖本身就是一個 bridge connected component ( 沒有橋 )，則不需要新增邊</span></span><br><span class="line">    <span class="keyword">if</span> (bcnt == <span class="number">1</span>) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每一組 bridge connected component 連接到的 bridge connected component 數量 -&gt; degree</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u)</span><br><span class="line">    &#123;</span><br><span class="line">        m[low[u]] += <span class="number">0</span>; <span class="comment">// 單獨一個 bridge connected component -&gt; degree = 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : G[u]) <span class="keyword">if</span> (low[v] != low[u]) ++m[low[u]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> alone = <span class="number">0</span>, leaves = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [__, de] : m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!de) ++alone;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (de == <span class="number">1</span>) ++leaves;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; alone + (leaves + <span class="number">1</span>) / <span class="number">2</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        TIME = <span class="number">0</span>;</span><br><span class="line">        bcnt = <span class="number">0</span>;</span><br><span class="line">        fill(dfn, dfn + <span class="number">1001</span>, <span class="number">0</span>);</span><br><span class="line">        fill(low, low + <span class="number">1001</span>, <span class="number">0</span>);</span><br><span class="line">        fill(G, G + <span class="number">1001</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            G[u].push_back(v);</span><br><span class="line">            G[v].push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出 bridge connected component 的數量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dfs(i, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 對於一個連通圖來說，若沒有橋則本身是 bridge connected component</span></span><br><span class="line">                <span class="comment">// 否則若圖中有一個橋，則圖會被分為兩個 bridge connected component</span></span><br><span class="line">                <span class="comment">// 所以這邊需要加一</span></span><br><span class="line">                ++bcnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/10972.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fXERhx">【RevolC FaeLoN Uva 10972】 - 大米饼 - 博客园</a><br><a href="https://ppt.cc/fNsXNx">uva 10972 RevolC FaeLoN - Titanium - 博客园</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Map</tag>
        <tag>Recursive</tag>
        <tag>Graph</tag>
        <tag>Vector</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11192 解題紀錄</title>
    <url>/UVa-11192/</url>
    <content><![CDATA[<p>題目： <a href="https://zerojudge.tw/ShowProblem?problemid=e267">UVa - 11192 - Group Reverse</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>每筆測資會有一個數字及一個字串，數字代表分割的組數，字串的長度會是該數的倍數，題目要求按照組數輸出其字串反轉的內容。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 String 讀取測資，將一組大小的字串反轉後放到另一個 String 並輸出，之後再將反轉過的資料 <code>erase()</code> 掉即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> groupNum, groupSize;</span><br><span class="line">    <span class="built_in">string</span> data, output;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; groupNum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!groupNum)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; data;</span><br><span class="line"></span><br><span class="line">        groupSize = data.size() / groupNum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (data.size() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            reverse(data.begin(), data.begin() + groupSize);</span><br><span class="line">            output.assign(data.begin(), data.begin() + groupSize);</span><br><span class="line">            data.erase(<span class="number">0</span>, groupSize);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; output;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/11192.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11286 解題紀錄</title>
    <url>/UVa-11286/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=2261">UVa - 11286 - Conformity</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>每組測資會給一個整數，代表接下來會有幾組課程代號，每組課程代號會有五個代號，代表某個學生選擇的五堂課，求最多人選擇的組合。<span id="more"></span></p>
<p><strong>Input：</strong> 每組測資起始於一個整數 <code>n</code>，若 <code>n</code> 為 0 代表結束。否則接下來 n 行中，每行會有 5 個 3 位數的整數代表課程代號，中間以空格隔開。<strong>每組測資中間沒有空行，整數與課程代號中也沒有空行。</strong></p>
<p><strong>Output：</strong> 求最多人選擇的那組課程代號的人數，若同時有超過一組最多人選擇的話則將人數相加，例如 Sample 的第二組資料，有三組不同的組合則答案為 <code>1 + 1 + 1 = 3</code>。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p><strong>想法：</strong> 整體思路為，將每個人選擇的課程代號以小到大排序，即可避免順序不同但組合相同的問題，接著使用 Unordered_map 記數，最後遍歷找出答案即可。</p>
<p><strong>作法：</strong> 先讀取 <code>n</code>，接下來每一行使用 <code>cin</code> 讀取課程代號，並先存放到一個 Vector，讀取 5 個後先對 Vector 進行排序，最後把它存放到一個 String 裡面當作 key，接著將 key 對應的 val 加一即可。讀取完後遍歷 map，使用 pair 來儲存結果，first 為當前選擇的組合的人數，second 為與 first 人數相同的課程代號的總和，每遍歷到一組資料，先判斷是否大於原本的 first，若大於則代表應該選擇當前的組合的人數，更新 first 及 second，否則若是與 first 相等，則將 second 加上當前的人數，最後輸出結果即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> str;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) <span class="built_in">cin</span> &gt;&gt; str, v.emplace_back(str);</span><br><span class="line">            sort(begin(v), end(v));</span><br><span class="line">            str.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; s : v) str += s;</span><br><span class="line">            ++m[str];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [k, v] : m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (v &gt; ret.first) ret = &#123; v, v &#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (v == ret.first) ret.second += v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/11286.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
        <tag>Unordered_map</tag>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11228 解題紀錄</title>
    <url>/UVa-11228/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=0&problem=2169">UVa - 11228 - Transportation system.</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>有一個國家，裡面有一些城市，現在想要使得這些城市相通，從任意的一個城市可以去到另一個城市，若兩城市的距離大於某個值則表示這兩個城市位於不同的州，需要使用鐵路才能連接，否則代表這兩個城市位於同一個州，使用公路連接即可，以建造公路為優先，求這個國家有幾個州，及需要多長的公路及鐵路才能使得所有城市相通。</p>
<span id="more"></span>

<p><strong>Input：</strong> 第一行為一整數 <code>T</code>，表示有 <code>T</code> 組測資，每組測資的第一行有兩個整數 <code>n</code>、<code>ts</code>，表示國家中城市的數量 <code>(0 ~ n - 1)</code>，及閥值 ( 若兩城市間的距離大於 <code>ts</code> 則需要建造鐵路 )，後面 <code>n</code> 行依序為城市的座標。</p>
<p><strong>Output：</strong> 輸出州的數量，需要建造的公路長度 ( 四捨五入 )，需要建造的鐵路長度 ( 四捨五入 )。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p><strong>這個解法需要有 Union Find 及 Kruskcal 演算法的概念。</strong></p>
<p>先讀取測資並將所有城市兩兩建邊，之後使用 Union Find 及 Kruskcal 演算法求解即可，有詳細的註解因此不多贅述。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/f4Hzex</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">double</span> w; <span class="comment">// 邊的權重 ( 兩城市之間的距離 )</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 將所有邊根據距離由小到大排序</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> edge&amp; r) &#123; <span class="keyword">return</span> w &lt; r.w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 計算兩城市的距離</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">distance</span><span class="params">(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; c1, <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; [x1, y1] = c1;</span><br><span class="line">    <span class="keyword">auto</span>&amp; [x2, y2] = c2;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// data</span></span><br><span class="line"><span class="keyword">int</span> Case = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; edges;</span><br><span class="line"><span class="keyword">int</span> parents[<span class="number">1001</span>]; <span class="comment">// 每個點的 parent</span></span><br><span class="line"><span class="keyword">int</span> ranks[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edges.clear();</span><br><span class="line">    <span class="comment">// 一開始每個節點的 parent 都是自己，而 rank 皆為 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) parents[i] = i, ranks[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> p == parents[p] ? p : parents[p] = Find(parents[p]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rx = Find(x), ry = Find(y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 x 跟 y 的 root 一樣，表示 x 和 y 接起會造成環</span></span><br><span class="line">    <span class="keyword">if</span> (rx == ry) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 將 rank 較小的接到 rank 較大的樹下面，因為這樣後面 Find 時消耗較小</span></span><br><span class="line">    <span class="keyword">if</span> (ranks[rx] &gt; ranks[ry]) parents[ry] = rx;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ranks[rx] &lt; ranks[ry]) parents[rx] = ry;</span><br><span class="line">    <span class="keyword">else</span> parents[ry] = rx, ++ranks[rx];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskcal</span><span class="params">(<span class="keyword">int</span> ts, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;        <span class="comment">// 州的數量</span></span><br><span class="line">    <span class="keyword">double</span> roadDis = <span class="number">0</span>; <span class="comment">// 需要建造的公路長度</span></span><br><span class="line">    <span class="keyword">double</span> railDis = <span class="number">0</span>; <span class="comment">// 需要建造的鐵路長度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先根據權重 ( 城市與城市的距離 ) 排序</span></span><br><span class="line">    sort(edges.begin(), edges.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 計算已經用了幾條邊，總共需要 n - 1 條</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [c1, c2, dis] : edges)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若 c1、c2 接起會造成環則不接</span></span><br><span class="line">        <span class="keyword">if</span> (!Union(c1, c2)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若兩城市距離大於 ts 表示需要建鐵路，同時表示兩城市不在同一個州</span></span><br><span class="line">        <span class="keyword">if</span> (dis &gt; ts) railDis += dis, ++cnt;</span><br><span class="line">        <span class="keyword">else</span> roadDis += dis;</span><br><span class="line"></span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最後需要將州的數量加一，因為州的數量等於 &quot;長度大於 ts 的邊的數量&quot; 加一</span></span><br><span class="line">    ++cnt;</span><br><span class="line">    <span class="comment">// 兩者都四捨五入</span></span><br><span class="line">    roadDis = (<span class="keyword">int</span>)(roadDis + <span class="number">0.5</span>);</span><br><span class="line">    railDis = (<span class="keyword">int</span>)(railDis + <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; ++Case &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; roadDis &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; railDis &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n, ts; <span class="comment">// 閥值 threshold</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; ts;</span><br><span class="line">        init(n);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; cities(n); <span class="comment">// 城市的座標</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            cities[i] = &#123; x, y &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將所有城市兩兩相連，並計算距離</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; c1 = &#123; cities[i].first, cities[i].second &#125;;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; c2 = &#123; cities[j].first, cities[j].second &#125;;</span><br><span class="line">                edges.push_back(&#123; i, j, distance(c1, c2) &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        kruskcal(ts, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/11228.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/f4Hzex">UVA 11228 - Transportation system._蚂蚁大战大象-CSDN博客</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Graph</tag>
        <tag>Vector</tag>
        <tag>Union Find</tag>
        <tag>Kruskcal</tag>
        <tag>Minimum Spanning Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 10986 解題紀錄</title>
    <url>/UVa-10986/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1927">UVa - 10986 - Sending email</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>有 <code>n</code> 台 SMTP 伺服器透過 <code>m</code> 條網絡線連接，每條網絡線連接兩台伺服器，透過每條網絡線發送電子郵件有一定的延遲時間（以毫秒為單位）。 假設伺服器本身不會造成延遲，請問沿著網絡線從伺服器 <code>s</code> 向伺服器 <code>t</code> 發送電子郵件所需的最短時間是多少？</p>
<p>引用自：<a href="https://ppt.cc/ffqNmx">【題解】UVa 10986 Sending email - Yui Huang 演算法學習筆記</a></p>
<span id="more"></span>

<p><strong>Input：</strong> 第一行為一整數，表示有幾組測資，每組測資第一行為四個整數，分別為 <code>n</code>、<code>m</code>、<code>s</code>、<code>t</code>，後面 m 行每行有三個整數 <code>u</code>、<code>v</code>、<code>w</code>，表示伺服器 <code>u</code>、<code>v</code> 可互相傳送電子郵件，且所需時間為 <code>w</code>。</p>
<p><strong>Output：</strong> 輸出沿著網絡線從伺服器 <code>s</code> 向伺服器 <code>t</code> 發送電子郵件所需的最短時間。若無法傳送到則輸出 <code>&quot;unreachable&quot;</code>。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p><strong>這個解法需要有 Dijkstra 演算法的概念。</strong></p>
<p>使用 Dijkstra 搭配 Priority_queue 求解即可。記得建雙向邊。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/ffqNmx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> point&amp; r) <span class="keyword">const</span> &#123; <span class="keyword">return</span> w &gt; r.w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; edges;</span><br><span class="line"><span class="keyword">int</span> value[<span class="number">20000</span>];</span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">20000</span>];</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;point, <span class="built_in">vector</span>&lt;point&gt;, greater&lt;point&gt;&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edges.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) value[i] = INT_MAX, visited[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pq.push(&#123; start, value[start] = <span class="number">0</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [u, val] = pq.top();</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        pq.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [v, w] : edges[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> tmp = val + w;</span><br><span class="line">            <span class="keyword">if</span> (value[v] &gt; tmp) pq.push(&#123; v, value[v] = tmp &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, Case = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m, s, t;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;</span><br><span class="line">        init(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, w;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 雙向建邊</span></span><br><span class="line">            edges[u].push_back(&#123; v, w &#125;);</span><br><span class="line">            edges[v].push_back(&#123; u, w &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dijkstra(s);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; ++Case &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (value[t] != INT_MAX) <span class="built_in">cout</span> &lt;&lt; value[t] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;unreachable\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/10986.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/ffqNmx">【題解】UVa 10986 Sending email - Yui Huang 演算法學習筆記</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Unordered_map</tag>
        <tag>Graph</tag>
        <tag>Priority_queue</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11378 解題紀錄</title>
    <url>/UVa-11378/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=2373">UVa - 11378 - Bey Battle</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><blockquote>
<p>給你點的位置，求出以各個點為中心的正方形，邊長最多可達多少？每個正方形邊長須一樣，可剛好接觸到。</p>
</blockquote>
<p><a href="https://ppt.cc/fZxscx">UVa 11378 - Bey Battle | NaiveRed’s Blog</a></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>Closet Pair Problem，可用 Divide and Conquer。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt; b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(c) memset(c, 0, sizeof(c))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fZxscx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MXN = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point P[MXN];</span><br><span class="line">Point tmp[MXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">const</span> Point&amp; l, <span class="keyword">const</span> Point&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max(<span class="built_in">abs</span>(l.x - r.x), <span class="built_in">abs</span>(l.y - r.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">const</span> Point&amp; l, <span class="keyword">const</span> Point&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l.x &lt; r.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">const</span> Point&amp; l, <span class="keyword">const</span> Point&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l.y &lt; r.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FOR(i, <span class="number">0</span>, N) <span class="built_in">cin</span> &gt;&gt; P[i].x &gt;&gt; P[i].y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DnC</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R) <span class="keyword">return</span> INF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> M = (L + R) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> d = min(DnC(L, M), DnC(M + <span class="number">1</span>, R));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M; i &gt;= L &amp;&amp; P[M].x - P[i].x &lt; d; --i) tmp[idx++] = P[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M + <span class="number">1</span>; i &lt;= R &amp;&amp; P[i].x - P[M].x &lt; d; ++i) tmp[idx++] = P[i];</span><br><span class="line"></span><br><span class="line">    sort(tmp, tmp + idx, cmp2);</span><br><span class="line"></span><br><span class="line">    FOR(i, <span class="number">0</span>, idx) FOR(j, <span class="number">1</span>, <span class="number">4</span> &amp;&amp; i + j &lt; idx) d = min(dist(tmp[i], tmp[i + j]), d);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(P, P + N, cmp1);</span><br><span class="line">    <span class="keyword">auto</span> ret = DnC(<span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N &amp;&amp; N)</span><br><span class="line">    &#123;</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fZxscx">UVa 11378 - Bey Battle | NaiveRed’s Blog</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Divide and Conquer</tag>
        <tag>Recursive</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11417 解題紀錄</title>
    <url>/UVa-11417/</url>
    <content><![CDATA[<p>題目： <a href="https://zerojudge.tw/ShowProblem?problemid=d255">UVa - 11417 - GCD</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>每筆測資會有一個大於 1 且小於 500 的數字，並按照題目的要求算出對應的數字。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>按照題目給的兩個 for 迴圈來做，GCD 透過輾轉相除法的概念來做即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (j % i == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GCD(j % i, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, G;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((<span class="built_in">cin</span> &gt;&gt; n) &amp;&amp; (n != <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        G = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                G += GCD(i, j);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; G &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/11417.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11380 解題紀錄</title>
    <url>/UVa-11380/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2375">UVa - 11380 - Down Went The Titanic</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><blockquote>
<p>給定一個圖，上面有薄冰 ‘.’ 或 ‘*‘, 厚冰 ‘@’, 木塊 ‘#’，一開始人都在 ‘*‘ 上，薄冰只能走一次就會沉掉，厚冰次數不限，如果人走到木塊上就獲救了，但是一個木塊的容量只有 p，求最多能有多少人獲救。</p>
</blockquote>
<p><a href="https://ppt.cc/fKhjIx">UVA 11380 - Down Went The Titanic（网络流）_Remilia’s-CSDN博客</a></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>最大流，依照上面的說明建邊後使用 Dinic 求解即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt; b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(c) memset(c, 0, sizeof(c))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">QPOP</span><span class="params">(<span class="built_in">queue</span>&lt;T&gt;&amp; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fKhjIx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MXN = <span class="number">2005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S, T;</span><br><span class="line"><span class="keyword">int</span> rn[MXN][MXN];</span><br><span class="line"><span class="keyword">int</span> l[MXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Y, X, P;</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="keyword">int</span> d[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLR(rn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot = Y * X;</span><br><span class="line">    T = <span class="number">2</span> * tot + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    FOR(y, <span class="number">0</span>, Y) FOR(x, <span class="number">0</span>, X)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = X * y + x + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> (c)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="comment">// 有人</span></span><br><span class="line">            rn[u][u + tot] = <span class="number">1</span>;</span><br><span class="line">            rn[S][u] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;.&#x27;</span>: <span class="comment">// 薄冰</span></span><br><span class="line">            rn[u][u + tot] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;@&#x27;</span>: <span class="comment">// 厚冰</span></span><br><span class="line">            rn[u][u + tot] = INF;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">            rn[u][u + tot] = INF;</span><br><span class="line">            rn[u + tot][T] = P;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FOR(i, <span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> dx = x + d[i];</span><br><span class="line">            <span class="keyword">int</span> dy = y + d[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (dx &lt; <span class="number">0</span> || dx &gt;= X || dy &lt; <span class="number">0</span> || dy &gt;= Y) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> v = X * dy + dx + <span class="number">1</span>;</span><br><span class="line">            rn[u + tot][v] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dinicBFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLR(l);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(S);</span><br><span class="line">    l[S] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = QPOP(q);</span><br><span class="line"></span><br><span class="line">        FOR(v, <span class="number">0</span>, T + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l[v] || !rn[u][v]) <span class="keyword">continue</span>;</span><br><span class="line">            l[v] = l[u] + <span class="number">1</span>;</span><br><span class="line">            q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l[T];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinicDFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> cp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == T) <span class="keyword">return</span> cp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp = cp;</span><br><span class="line"></span><br><span class="line">    FOR(v, <span class="number">0</span>, T + <span class="number">1</span> &amp;&amp; tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l[v] != l[u] + <span class="number">1</span> || !rn[u][v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> bt = dinicDFS(v, min(rn[u][v], tmp));</span><br><span class="line">        rn[u][v] -= bt;</span><br><span class="line">        rn[v][u] += bt;</span><br><span class="line">        tmp -= bt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cp - tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximumFlow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (dinicBFS()) mf += dinicDFS(S, INF);</span><br><span class="line">    <span class="keyword">return</span> mf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maximumFlow() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; Y &gt;&gt; X &gt;&gt; P)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fKhjIx">UVA 11380 - Down Went The Titanic（网络流）_Remilia’s-CSDN博客</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Queue</tag>
        <tag>Maximum Flow</tag>
        <tag>Dinic</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11418 解題紀錄</title>
    <url>/UVa-11418/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2413">UVa - 11418 - Clever Naming Patterns</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><blockquote>
<p>給一系列詞組，僅從每組中按字母表順序取一個詞，比如<br>有這三個組：<br>Dog Cat Big<br>Better<br>Answer Call<br>需要取 3 個詞，A, B, C, 開頭，每組取一詞。第二組的 B 必須用上，第三組的 A 必須用上，剩餘的第一組就必須取 Cat 了：<br>Answer<br>Better<br>Cat</p>
</blockquote>
<p><a href="https://ppt.cc/f2ZIex">请教‌‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‍‍‍‍‍‌‌‌‍‌‍‌‌‌‍‌一下我这个解法怎么不对了–UVa 11418 Clever Naming Patterns</a></p>
<p>這個說明不是很好理解，可是我也懶得寫。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>最大流，可使用 Edmonds-Karp 求解，也可使用 Dinic。</p>
<p>將每組詞組當作一個點，每個出現的詞也當作一個點，A ~ Z 各為一個點，從源點連到詞組再連到詞，再連到詞的第一個字母，最後流到匯點，之後最大流求解即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><p>Edmonds-Karp ( 將一開始的 Capacity 當作 Residual Network ) :</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt; b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(c) memset(c, 0, sizeof(c))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">QPOP</span><span class="params">(<span class="built_in">queue</span>&lt;T&gt;&amp; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/f1uJix</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MXN = <span class="number">555</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rn[MXN][MXN]; <span class="comment">// 剩餘網路</span></span><br><span class="line"><span class="keyword">int</span> p[MXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MXN];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; dict;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; reDict;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> S, T; <span class="comment">// Source, Sink</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLR(rn);</span><br><span class="line">    dict.clear();</span><br><span class="line">    reDict.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    FOR(i, <span class="number">1</span>, N + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">        <span class="keyword">while</span> (tmp--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; s : str) s = <span class="built_in">tolower</span>(s);</span><br><span class="line">            str[<span class="number">0</span>] = <span class="built_in">toupper</span>(str[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!dict.count(str))</span><br><span class="line">            &#123;</span><br><span class="line">                dict[str] = ++cnt;</span><br><span class="line">                reDict[cnt] = str;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> v = dict[str] + N;</span><br><span class="line">            rn[i][v] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build edges</span></span><br><span class="line">    T = N + dict.size() + <span class="number">26</span> + <span class="number">1</span>;</span><br><span class="line">    FOR(i, <span class="number">1</span>, N + <span class="number">1</span>) rn[S][i] = <span class="number">1</span>;</span><br><span class="line">    FOR(i, N + dict.size() + <span class="number">1</span>, T) rn[i][T] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [s, u] : dict)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = s[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span> + N + dict.size() + <span class="number">1</span>;</span><br><span class="line">        rn[u + N][v] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">augment</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> bottleNeck)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == S) <span class="keyword">return</span> bottleNeck;</span><br><span class="line">    bottleNeck = augment(p[u], u, min(rn[u][v], bottleNeck));</span><br><span class="line">    rn[u][v] -= bottleNeck;</span><br><span class="line">    rn[v][u] += bottleNeck;</span><br><span class="line">    <span class="keyword">return</span> bottleNeck;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Edmonds-Karp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxiumFlow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mf = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        CLR(vis);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(S);</span><br><span class="line">        vis[S] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty() &amp;&amp; !vis[T])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = QPOP(q);</span><br><span class="line"></span><br><span class="line">            FOR(v, <span class="number">0</span>, T + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (vis[v] || rn[u][v] &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                q.push(v);</span><br><span class="line">                vis[v] = <span class="literal">true</span>;</span><br><span class="line">                p[v] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!vis[T]) <span class="keyword">break</span>;</span><br><span class="line">        mf += augment(p[T], T, INF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> C = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">    maxiumFlow();</span><br><span class="line"></span><br><span class="line">    FOR(i, N + dict.size() + <span class="number">1</span>, T) FOR(j, N + <span class="number">1</span>, N + (<span class="keyword">int</span>)dict.size() + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (rn[j][i] == <span class="number">0</span> &amp;&amp; rn[i][j])</span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(reDict[j - N]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ret.begin(), ret.end());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; ++C &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; s : ret) <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dinic:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt; b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(c) memset(c, 0, sizeof(c))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">QPOP</span><span class="params">(<span class="built_in">queue</span>&lt;T&gt;&amp; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fXrOUx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MXN = <span class="number">555</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rn[MXN][MXN]; <span class="comment">// 剩餘網路</span></span><br><span class="line"><span class="keyword">int</span> l[MXN];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; dict;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; reDict;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> S, T; <span class="comment">// Source, Sink</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLR(rn);</span><br><span class="line">    dict.clear();</span><br><span class="line">    reDict.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    FOR(i, <span class="number">1</span>, N + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">        <span class="keyword">while</span> (tmp--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; s : str) s = <span class="built_in">tolower</span>(s);</span><br><span class="line">            str[<span class="number">0</span>] = <span class="built_in">toupper</span>(str[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!dict.count(str))</span><br><span class="line">            &#123;</span><br><span class="line">                dict[str] = ++cnt;</span><br><span class="line">                reDict[cnt] = str;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> v = dict[str] + N;</span><br><span class="line">            rn[i][v] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build edges</span></span><br><span class="line">    T = N + dict.size() + <span class="number">26</span> + <span class="number">1</span>;</span><br><span class="line">    FOR(i, <span class="number">1</span>, N + <span class="number">1</span>) rn[S][i] = <span class="number">1</span>;</span><br><span class="line">    FOR(i, N + dict.size() + <span class="number">1</span>, T) rn[i][T] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [s, u] : dict)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = s[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span> + N + dict.size() + <span class="number">1</span>;</span><br><span class="line">        rn[u + N][v] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dinicBFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLR(l);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(S);</span><br><span class="line">    l[S] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = QPOP(q);</span><br><span class="line"></span><br><span class="line">        FOR(v, <span class="number">1</span>, T + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l[v] || !rn[u][v]) <span class="keyword">continue</span>;</span><br><span class="line">            l[v] = l[u] + <span class="number">1</span>;</span><br><span class="line">            q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l[T];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinicDFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> cp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == T) <span class="keyword">return</span> cp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp = cp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= T &amp;&amp; tmp; ++v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l[v] != l[u] + <span class="number">1</span> || !rn[u][v]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> bottleNeck = dinicDFS(v, min(rn[u][v], tmp));</span><br><span class="line">        rn[u][v] -= bottleNeck;</span><br><span class="line">        rn[v][u] += bottleNeck;</span><br><span class="line">        tmp -= bottleNeck;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cp - tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Edmonds-Karp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxiumFlow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (dinicBFS()) mf += dinicDFS(S, INF);</span><br><span class="line">    <span class="keyword">return</span> mf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> C = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">    maxiumFlow();</span><br><span class="line"></span><br><span class="line">    FOR(i, N + dict.size() + <span class="number">1</span>, T) FOR(j, N + <span class="number">1</span>, N + (<span class="keyword">int</span>)dict.size() + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (rn[j][i] == <span class="number">0</span> &amp;&amp; rn[i][j])</span><br><span class="line">        &#123;</span><br><span class="line">            ret.push_back(reDict[j - N]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ret.begin(), ret.end());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; ++C &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; s : ret) <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/f2ZIex">请教‌‌‌‌‍‍‌‍‌‌‍‍‍‌‌‍‍‍‍‍‍‌‌‌‍‌‍‌‌‌‍‌一下我这个解法怎么不对了–UVa 11418 Clever Naming Patterns</a><br><a href="https://ppt.cc/f1uJix">MY_CODE_MANUAL: UVa 11418 - Clever Naming Patterns</a><br><a href="https://ppt.cc/fXrOUx">Dinic算法详解及实现 - 0giant - 博客园</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
        <tag>Queue</tag>
        <tag>Maximum Flow</tag>
        <tag>Dinic</tag>
        <tag>Vector</tag>
        <tag>Edmonds-Karp</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11420 解題紀錄</title>
    <url>/UVa-11420/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=2415">UVa - 11420 - Chest of Drawers</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p><a href="https://ppt.cc/f3J6Ox">d042. 11420 - Chest of Drawers - 高中生程式解題系統</a></p>
<span id="more"></span>

<p><strong>Input：</strong> 每組測資有兩個整數，依序為 <code>n</code>、<code>s</code>，若皆小於 0 表結束。</p>
<p><strong>Output：</strong> 輸出 <code>n</code> 個櫃子，確保剛好有 <code>s</code> 個櫃子是安全的所有情況數。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>動態規劃題，由於測資範圍不大，因此先算出所有情況的答案再輸出即可。</p>
<p>定義 <code>dp[i][j][k]</code>:</p>
<ul>
<li>若 <code>k = 0</code>，表有 <code>i</code> 個櫃子，<code>j</code> 個處於安全狀態，且最上層的櫃子沒有鎖。</li>
<li>若 <code>k = 1</code>，表有 <code>i</code> 個櫃子，<code>j</code> 個處於安全狀態，且最上層的櫃子有鎖。</li>
</ul>
<p>先設定初始狀態 <strong>dp[1][0][0] = 1</strong>，因為若只有一個櫃子，且櫃子是不安全的，表示只有最上層沒有鎖的這種可能，<strong>dp[1][1][1] = 1</strong>，因為若只有一個櫃子，且櫃子是安全的，表示只有最上層是有鎖的這種可能。</p>
<p>對於 <code>dp[i][j][k]</code>：</p>
<ul>
<li>若 <code>k = 0</code>，<code>dp[i][j][0] = dp[i - 1][j + 1][1] + dp[i - 1][j][0]</code>，<ol>
<li><code>dp[i - 1][j + 1][1]</code>，表有 <code>i - 1</code> 個櫃子，剛好 <code>j + 1</code> 個是安全的，且最上層有鎖。<br>可思考為在最上層加上一個沒鎖的櫃子，則原本的最上層會變得不安全，情況就變為 <code>i</code> 個櫃子，剛好 <code>j</code> 個是安全的，且最上層沒鎖。</li>
<li><code>dp[i - 1][j][0]</code>，表有 <code>i - 1</code> 個櫃子，剛好 <code>j</code> 個是安全的，且最上層沒鎖。<br>可思考為在最上層加上一個沒鎖的櫃子，則確保安全的櫃子數量不變，情況就變為 <code>i</code> 個櫃子，剛好 <code>j</code> 個是安全的，且最上層沒鎖。</li>
</ol>
</li>
<li>若 <code>k = 1</code>，<code>dp[i][j][1] = dp[i - 1][j - 1][1] + dp[i - 1][j - 1][0]</code>，<ol>
<li><code>dp[i - 1][j - 1][1]</code>，表有 <code>i - 1</code> 個櫃子，剛好 <code>j - 1</code> 個是安全的，且最上層有鎖。<br>可思考為在最上層加上一個有鎖的櫃子，則會加入一個確定安全的櫃子，情況就變為 <code>i</code> 個櫃子，剛好 <code>j</code> 個是安全的，且最上層有鎖。</li>
<li><code>dp[i - 1][j - 1][0]</code>，可思考為在最上層加上一個有鎖的櫃子，則會加入一個確定安全的櫃子，情況就變為 <code>i</code> 個櫃子，剛好 <code>j</code> 個是安全的，且最上層有鎖。</li>
</ol>
</li>
</ul>
<p>簡單來說就是不斷枚舉加入最上層的櫃子，若 <code>k = 0</code> 表示加入的沒鎖，若 <code>k = 1</code> 表示加入的有鎖，找出對應的關係即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fCBrlx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, s;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">67</span>][<span class="number">67</span>][<span class="number">2</span>]; <span class="comment">// dp[i][j][0] 表有 i 個櫃子，j 個處於安全狀態，且最上層的櫃子沒有鎖</span></span><br><span class="line">                         <span class="comment">// dp[i][j][1] 表有 i 個櫃子，j 個處於安全狀態，且最上層的櫃子有鎖</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">66</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 只有一個安全且最上層有鎖 -&gt; 加一層沒鎖</span></span><br><span class="line">        <span class="comment">// 沒有任何安全且最上層沒鎖 -&gt; 加一層沒鎖</span></span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 加一層沒鎖</span></span><br><span class="line">            dp[i][j][<span class="number">0</span>] = dp[i - <span class="number">1</span>][j + <span class="number">1</span>][<span class="number">1</span>] + dp[i - <span class="number">1</span>][j][<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 加一層有鎖</span></span><br><span class="line">            dp[i][j][<span class="number">1</span>] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">1</span>] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    compute();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s &amp;&amp; !(n &lt; <span class="number">0</span> &amp;&amp; s &lt; <span class="number">0</span>))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; dp[n][s][<span class="number">0</span>] + dp[n][s][<span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/f3J6Ox">d042. 11420 - Chest of Drawers - 高中生程式解題系統</a><br><a href="https://ppt.cc/fCBrlx">UVa 11420 - Chest of Drawers | NaiveRed’s Blog</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11456 解題紀錄</title>
    <url>/UVa-11456/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&category=26&page=show_problem&problem=2451">UVa - 11456 - Trainsorting</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p><a href="https://zerojudge.tw/ShowProblem?problemid=d052">d052. 11456 - Trainsorting - 高中生程式解題系統</a></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p><code>weighs[]</code> 存放依序車廂的重量，<code>n</code> 為車廂的總數量，之後遍歷陣列，核心想法為，由於新進的車廂只能放在頭尾，因此當遍歷到第 <code>i</code> 車廂時，若能找出 <code>i</code> 到 <code>n - 1</code> 的最長嚴格遞增子序列 ( Longest Increasing Subsequence ) 的長度及最長嚴格遞減子序列 ( Longest Decrease Subsequence )，就可以找到第一個車廂放 <code>i</code>，能組出的最大車廂重量，因為 LDS 遞減，每個位於 LDS 中的車廂都能放到最前面，而 LIS 遞增，每個位於 LIS 中的車廂都能放到最後面。</p>
<p>有了以上想法後，使用 DP 找出 LIS 及 LDS 即可，記得要從後面開始往前做。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/feem5x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> mx;</span><br><span class="line"><span class="keyword">int</span> weights[<span class="number">2001</span>];</span><br><span class="line"><span class="keyword">int</span> LIS[<span class="number">2001</span>];</span><br><span class="line"><span class="keyword">int</span> LDS[<span class="number">2001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mx = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">cin</span> &gt;&gt; weights[i], LIS[i] = LDS[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; i; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 若 j 能接在 i 後面 ( LIS )</span></span><br><span class="line">            <span class="keyword">if</span> (weights[i] &gt; weights[j]) LIS[i] = max(LIS[j] + <span class="number">1</span>, LIS[i]);</span><br><span class="line">            <span class="comment">// 若 j 能接在 i 後面 ( LDS )</span></span><br><span class="line">            <span class="keyword">if</span> (weights[i] &lt; weights[j]) LDS[i] = max(LDS[j] + <span class="number">1</span>, LDS[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        mx = max(LIS[i] + LDS[i] - <span class="number">1</span>, mx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mx &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/feem5x">【題解】ZeroJudge d052: 11456 - Trainsorting - Yui Huang 演算法學習筆記</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>UVa</tag>
        <tag>LIS</tag>
        <tag>LDS</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11498 解題紀錄</title>
    <url>/UVa-11498/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=2493">UVa - 11498 - Division of Nlogonia</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個參考點及一些座標，以參考點為原點，求其他座標位於參考點的哪個方向 ( 東北、西北、東南、西南 )，若座標位於 x 軸或 y 軸上則輸出 <code>&quot;divisa&quot;</code>。</p>
<span id="more"></span>

<p><strong>Input：</strong> 每組測資第一個整數 T，表示有 T 個點，若 T 為 0 表示結束。接下來兩個整數 N、M 表參考點的座標，後面 T 行，每行兩個數字，為要求方向的座標。</p>
<p><strong>Output：</strong> 輸出座標相對於參考點的方向。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>讀取測資並根據題目要求判斷即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, N, M, x, y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; T &amp;&amp; T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (T--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x == N || y == M) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;divisa\n&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; N &amp;&amp; y &gt; M) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NE\n&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; N &amp;&amp; y &lt; M) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;SE\n&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; N &amp;&amp; y &gt; M) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;SO\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>CPE - 2020/06/09</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11463 解題紀錄</title>
    <url>/UVa-11463/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2458">UVa - 11463 - Commandos</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個無向圖，每條邊的 cost 皆為 1，給一個起點及終點，求從起點到某一點後再到終點所需要的最大 cost。</p>
<p><strong>Input：</strong> 第一個整數 <code>T</code>，表示有 <code>T</code> 組測資，每組測資前兩個數字為 <code>n</code>、<code>m</code>，依序表示圖上有 <code>n</code> 個點 ( 0 ~ <code>n</code> - 1 )，及 <code>m</code> 條邊，後面 <code>m</code> 行，每行有兩個整數 <code>u</code>、<code>v</code>，表示 <code>u</code>、 <code>v</code> 兩點是連通的。</p>
<p><strong>Output：</strong> 輸出從起點到某一點後再到終點所需要的最大 cost。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>All Pair Shortest Path 題，讀測資並做 Floyd-Warshall Algorithm 求解即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fedUBx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> C;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) dist[i][j] = INF;</span><br><span class="line">        dist[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">while</span> (m--) <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v, dist[u][v] = dist[v][u] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FloydWarshall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            dist[i][j] = min(dist[i][k] + dist[k][j], dist[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b, e, mx = INT_MIN;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; b &gt;&gt; e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) mx = max(dist[b][k] + dist[k][e], mx);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; ++C &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; mx &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        read();</span><br><span class="line">        FloydWarshall();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fedUBx">UVa 11463 - Commandos_小白菜又菜-CSDN博客</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>UVa</tag>
        <tag>Floyd-Warshall</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11504 解題紀錄</title>
    <url>/UVa-11504/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2499">UVa - 11504 - Dominos</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一些骨牌的相對關係，求最少需要推倒幾個骨牌才能使得所有骨牌都倒下。</p>
<span id="more"></span>

<p><strong>Input：</strong> 第一行為一整數 <code>T</code>，表示總共有 <code>T</code> 組測資，每組測資的第一行為兩個整數 <code>n</code>、<code>m</code>，代表有 <code>n</code> 個骨牌 ( 序號為 <code>1 ~ n</code> )，及 <code>m</code> 個相對關係，後面 <code>m</code> 行每行會有兩個整數 <code>u</code>、<code>v</code>，表示若 <code>u</code> 倒下則 <code>v</code> 也會倒下。</p>
<p><strong>Output：</strong> 輸出最少需要推倒幾個骨牌才能使得所有骨牌都倒下。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>其實就是找 SCC ( Strongly Connected Component )，SCC 即在有向圖上任意選兩點 <code>u</code>、<code>v</code>，<code>u</code> 能夠走到 <code>v</code> 且 <code>v</code> 也能夠走到 <code>u</code>。因此我們在 SCC 中任意推倒一個骨牌就能使得整個 SCC 都倒下，之後把每個 SCC 都當成一個點 ( 即縮點的概念 )，之後找出每個 SCC 被幾個其他的 SCC 所接入，如果 SCC 有被其他的 SCC 接入，表示只要推倒那個 SCC，這個 SCC 也會被推倒，最後看有幾個 SCC 沒有被接入即是答案。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">reference:</span></span><br><span class="line"><span class="comment">https://ppt.cc/fMdaHx</span></span><br><span class="line"><span class="comment">https://ppt.cc/fnAeqx</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> TIME;</span><br><span class="line"><span class="keyword">int</span> cnt;         <span class="comment">// 計算目前有幾個 SCC</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dfn;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; low;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; com; <span class="comment">// 紀錄點屬於哪個 SCC</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; G;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; inStack;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++TIME;</span><br><span class="line">    s.push(u);</span><br><span class="line">    inStack.insert(u);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : G[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (inStack.count(v)) low[u] = min(dfn[v], low[u]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(v);</span><br><span class="line">        low[u] = min(low[v], low[u]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dfn[u] == low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            com[tmp] = cnt;</span><br><span class="line">            inStack.erase(tmp);</span><br><span class="line">        &#125; <span class="keyword">while</span> (tmp != u);</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        TIME = <span class="number">0</span>;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        dfn.assign(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        low.assign(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        com.assign(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        G.assign(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        inStack.clear();</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) s.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line"></span><br><span class="line">            G[u].push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出 SCC ( Strongly Connected Component )</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u) <span class="keyword">if</span> (!dfn[u]) dfs(u);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 計算 SCC 被幾個其他的 SCC 接入</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">degree</span><span class="params">(cnt)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= n; ++u) <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : G[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (com[u] != com[v]) ++degree[com[v]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果 SCC 沒有被其他的 SCC 接入則需要一次來推倒</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; de : degree) <span class="keyword">if</span> (!de) ++ret;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/11504.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fMdaHx">UVa 11504 - Dominos | 天邊。世界</a><br><a href="https://ppt.cc/fnAeqx">UVa 11504 - Dominos | NaiveRed’s Blog</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Stack</tag>
        <tag>Recursive</tag>
        <tag>Graph</tag>
        <tag>Vector</tag>
        <tag>Unordered_set</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11506 解題紀錄</title>
    <url>/UVa-11506/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=2501">UVa - 11506 - Angry Programmer</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><blockquote>
<p>有若干個節點跟雙向連接的網路線連接結點之間。你可以破壞節點或者破壞網路線，希望 1 號節點連不上 M 號節點。給你破壞每個物件的花費，問需要的最小總花費多少。</p>
</blockquote>
<p><a href="https://ppt.cc/fHGb9x">UVA 11506 - Angry Programmer ( Mincut, Flow ) - 0w1</a></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>最大流，依照上面的說明建邊後使用 Dinic 求解即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt; b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(c) memset(c, 0, sizeof(c))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">QPOP</span><span class="params">(<span class="built_in">queue</span>&lt;T&gt;&amp; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MXN = <span class="number">102</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S = <span class="number">1</span>, T;</span><br><span class="line"><span class="keyword">int</span> rn[MXN][MXN];</span><br><span class="line"><span class="keyword">int</span> l[MXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> M, W;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLR(rn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1 ~ M: out, M + 1 ~ 2M: in</span></span><br><span class="line">    T = M * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> u, v, c;</span><br><span class="line">    FOR(i, <span class="number">0</span>, M - <span class="number">2</span>) <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; c, rn[u + M][u] = rn[u][u + M] = c;</span><br><span class="line"></span><br><span class="line">    FOR(i, <span class="number">0</span>, W) <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; c, rn[u][v + M] = rn[v][u + M] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dinicBFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLR(l);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(S);</span><br><span class="line">    l[S] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = QPOP(q);</span><br><span class="line"></span><br><span class="line">        FOR(v, <span class="number">0</span>, T + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l[v] || !rn[u][v]) <span class="keyword">continue</span>;</span><br><span class="line">            l[v] = l[u] + <span class="number">1</span>;</span><br><span class="line">            q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l[T];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinicDFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> cp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == T) <span class="keyword">return</span> cp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp = cp;</span><br><span class="line"></span><br><span class="line">    FOR(v, <span class="number">0</span>, T + <span class="number">1</span> &amp;&amp; tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l[v] != l[u] + <span class="number">1</span> || !rn[u][v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> bt = dinicDFS(v, min(rn[u][v], tmp));</span><br><span class="line">        rn[u][v] -= bt;</span><br><span class="line">        rn[v][u] += bt;</span><br><span class="line">        tmp -= bt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cp - tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximumFlow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (dinicBFS()) mf += dinicDFS(S, INF);</span><br><span class="line">    <span class="keyword">return</span> mf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maximumFlow() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; M &gt;&gt; W &amp;&amp; !(!M &amp;&amp; !W))</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fHGb9x">UVA 11506 - Angry Programmer ( Mincut, Flow ) - 0w1</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Queue</tag>
        <tag>Maximum Flow</tag>
        <tag>Dinic</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11517 解題紀錄</title>
    <url>/UVa-11517/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=2512">UVa - 11517 - Exact Change</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p><a href="http://rubyacm.blogspot.com/2011/08/11517-exact-change.html">Unfortunate狗的ACM園地: 11517 - Exact Change</a></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>DP 的 Coin Change 問題，核心概念為枚舉每一個最後加入的面額。需要注意的是一種面額只能使用一次，因此做的時候要從後面往前做，避免同種金額使用多次。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fp0yAx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, P;</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="keyword">int</span> C[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">20001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sum; ++i) dp[i] = INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; P &gt;&gt; N;</span><br><span class="line">    sum = <span class="number">0</span>; <span class="comment">// 一種面額只能用一次，紀錄最多需要做到多少錢</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; C[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; P) sum += C[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CoinChange</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 反向做，避免多次使用相同的面額</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = sum; j &gt;= C[i]; --j) dp[j] = min(dp[j - C[i]] + <span class="number">1</span>, dp[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = P;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; sum &amp;&amp; dp[p] == INF) ++p;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; dp[p] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        read();</span><br><span class="line">        init();</span><br><span class="line">        CoinChange();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="http://rubyacm.blogspot.com/2011/08/11517-exact-change.html">Unfortunate狗的ACM園地: 11517 - Exact Change</a><br><a href="https://ppt.cc/fp0yAx">UVa 11517 - Exact Change_小白菜又菜-CSDN博客</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>UVa</tag>
        <tag>Coin Change</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11536 解題紀錄</title>
    <url>/UVa-11536/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=2531">UVa - 11536 - Smallest Sub-Array</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給三個整數 <code>N</code>、<code>M</code>、<code>K</code>，依據題目的要求建出一個陣列，從這個陣列中找出包含 1 ~ K 的最小子陣列的長度。</p>
<span id="more"></span>

<p><strong>Input：</strong> 第一行為一整數 T，表示有 T 組測資，後面 T 行每行有三個整數，依序為 <code>N</code>、<code>M</code>、<code>K</code>。</p>
<p><strong>Output：</strong> 輸出最小子陣列的長度。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先依照題目要求算出陣列，之後遍歷陣列，紀錄符合條件的數字最後出現的位置同時將符合條件的數字的位置推入 Queue 中，同時檢查，若 Queue 中最前面的數字在後面出現過就移除，原因在於，目前取到的子陣列其實是 **<code>Queue.front() ~ i</code>**，若 Queue 中最前面的數字在後面出現過就相當於前面一部份的元素是多餘的，可以捨去，使得子陣列縮小。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/foHacx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, K;</span><br><span class="line"><span class="keyword">int</span> Case = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> pos[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">1000001</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(pos, pos + <span class="number">101</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute</span></span><br><span class="line">    <span class="keyword">int</span> tmp = arr[<span class="number">1</span>] + arr[<span class="number">2</span>] + arr[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= N; ++i) arr[i] = tmp % M + <span class="number">1</span>, tmp += (arr[i] - arr[i - <span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">int</span> _min = INT_MAX, cnt = <span class="number">0</span>, cur;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cur = arr[i];</span><br><span class="line">        <span class="keyword">if</span> (cur &lt; <span class="number">1</span> || cur &gt; K) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        q.push(i);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!pos[cur]) ++cnt;</span><br><span class="line">        pos[cur] = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q.front() != pos[arr[q.front()]]) q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cnt == K) _min = min(i - q.front() + <span class="number">1</span>, _min);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; ++Case &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (cnt == K) <span class="built_in">cout</span> &lt;&lt; _min &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sequence nai\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; K;</span><br><span class="line">        init();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/foHacx">UVa 11536 - Smallest Sub-Array | 天邊。世界</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Queue</tag>
        <tag>CPE - 2020/12/22</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11566 解題紀錄</title>
    <url>/UVa-11566/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=2613">UVa - 11566 - Let’s Yum Cha!</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p><a href="http://unfortunatedog.blogspot.com/2013/07/11566-lets-yum-cha_23.html">Unfortunate狗的ACM園地: 11566 - Let’s Yum Cha!</a></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先算出總共可用的金額，之後 DP 求解即可。</p>
<p>定義 <code>dp[j][k]</code> 表示最多可以選擇 <code>j</code> 盤點心，共有 <code>k</code> 元預算。<br><code>dp[j][k] = max(dp[j - 1][k - price[i]], max(dp[j - 1][k], dp[j][k]))</code><br>最後的 <code>dp[j][k]</code> 也要取是因為縮減了一維，原本應為 <code>dp[i][j][k]</code>，縮減的那一維意義為只可選擇前 <code>i</code> 種點心，因此 <code>dp[j][k]</code> 也要放進來比較，意義為若多一種點心可選擇，但滿意度減少，則不如不多該選擇。</p>
<p>由於 DP 縮減了一維，所以計算時要從後面往前算。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fAhWWx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, X, T, K;</span><br><span class="line"><span class="keyword">int</span> V;</span><br><span class="line"><span class="keyword">int</span> favor[<span class="number">201</span>];</span><br><span class="line"><span class="keyword">int</span> price[<span class="number">201</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">23</span>][<span class="number">1001</span>]; <span class="comment">// dp[i][j] 表最多選擇了 i 盤點心，總價格為 j 元</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先將所有金額扣除茶費及服務費</span></span><br><span class="line">    ++N;</span><br><span class="line">    V = <span class="keyword">int</span>((X * N) / <span class="number">1.1</span> + <span class="number">1e-9</span>); <span class="comment">// + 1e-9 是為了避免浮點數誤差</span></span><br><span class="line">    V -= T * N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由於每個點心最多可點兩盤，所以放入兩個</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, tmp; i &lt; K; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// 滿意度總和</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">        price[i &lt;&lt; <span class="number">1</span>] = price[(i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>] = tmp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) <span class="built_in">cin</span> &gt;&gt; tmp, sum += tmp;</span><br><span class="line">        favor[i &lt;&lt; <span class="number">1</span>] = favor[(i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K * <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = N * <span class="number">2</span>; j &gt; <span class="number">0</span>; --j) <span class="keyword">for</span> (<span class="keyword">int</span> k = price[i]; k &lt;= V; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j][k] = max(dp[j - <span class="number">1</span>][k - price[i]] + favor[i], max(dp[j - <span class="number">1</span>][k], dp[j][k]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mx = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span> * N; ++i) mx = max(dp[i][V], mx);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; fixed &lt;&lt; (<span class="keyword">double</span>)mx / N &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; X &gt;&gt; T &gt;&gt; K &amp;&amp; (N || X || T || K))</span><br><span class="line">    &#123;</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fAhWWx">[UVA] 11566 - Let&#39;s Yum Cha! | 水泥城式</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>UVa</tag>
        <tag>0-1 Knapsack</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11572 解題紀錄</title>
    <url>/UVa-11572/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=2619">UVa - 11572 - Unique Snowflakes</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一串數字代表雪花的編號，編號不同的雪花代表形狀不同，求一次最多能裝出多少個不同的雪花，只能按照順序裝，不可跳過任意的雪花。<span id="more"></span></p>
<p><strong>Input：</strong> 測資起始於一個整數 <code>n</code>，代表有 <code>n</code> 組資料，每組資料起始於一個整數 <code>N</code>，代表有 <code>N</code> 片雪花，接下來 <code>N</code> 行每行會有一個數字，代表雪花的編號。</p>
<p><strong>Output：</strong> 輸出能最多能裝出的雪花的個數。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>題目其實就是在求一個陣列中最長的不重複子陣列，依此想法去解題即可。<code>r</code> 為當前讀取到的元素個數。</p>
<p>解法一：使用 DP 及 Sliding window 的概念，使用 Unordered_map 儲存每個數字最後出現的 index，每次讀取一個元素時，先判斷是否已經存在於 map，若存在則 Window 的 <code>l</code> 需更新為 <code>l</code>、及該 <code>index + 1</code> 兩者的較大者，此時 Window 的長度為 <code>r - l + 1</code>，接著更新該元素在 map 中的 index，並且更新 <code>ret</code>。</p>
<p>解法二：使用 Unordered_set 及 Vector 依序儲存讀取到的元素，使用一個整數 <code>l</code> 從 0 開始記數，每次讀取一個元素時，先判斷該元素是否在 set 中出現過，若出現則在 set 中刪除 <code>v[l]</code> 並將 <code>l</code> 加一，直到 set 中沒有該元素為止，此時 Window 的長度為 <code>r - l + 1</code>，接著將元素存入 set 中。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><p>解法一：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> N, tmp, l = <span class="number">0</span>, r = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">        <span class="keyword">while</span> (N--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">            <span class="keyword">if</span> (m.count(tmp)) l = max(l, m[tmp] + <span class="number">1</span>);</span><br><span class="line">            ret = max(ret, r - l + <span class="number">1</span>);</span><br><span class="line">            m[tmp] = r;</span><br><span class="line">            ++r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/11572-1.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<p>解法二：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> N, tmp, l = <span class="number">0</span>, r = <span class="number">0</span>, ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">        <span class="keyword">while</span> (N--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">            <span class="keyword">while</span> (s.count(tmp)) s.erase(v[l++]);</span><br><span class="line">            s.insert(tmp);</span><br><span class="line">            v.emplace_back(tmp);</span><br><span class="line">            ret = max(r - l + <span class="number">1</span>, ret);</span><br><span class="line">            ++r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/11572-2.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>UVa</tag>
        <tag>Unordered_map</tag>
        <tag>Vector</tag>
        <tag>Unordered_set</tag>
        <tag>Sliding Window</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11631 解題紀錄</title>
    <url>/UVa-11631/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=2678">UVa - 11631 - Dark roads</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>在一個國家中，城市間有很多條路相連，在路上每一公尺的路燈花費是 1，現在想要使路燈花費最少，且從任意的一個城市到另一個城市可以找到一條都開著路燈的路徑。</p>
<span id="more"></span>

<p><strong>Input：</strong> 每組測資的第一行為兩個整數 <code>m</code>、<code>n</code>，分別代表城市的數量及路的數量，若兩者皆為 0 則結束。後面 <code>n</code> 行，每行有三個整數 <code>u</code>、<code>v</code>、<code>w</code>，表示有一條 <code>(u, v)</code> 的路，且長 <code>w</code> 公尺。</p>
<p><strong>Output：</strong> 輸出所有路都開路燈的花費減去最少的花費。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p><strong>這個解法需要有 Union Find 及 Kruskcal 演算法的概念。</strong></p>
<p>先讀取測資同時記錄所有路燈的花費，之後建圖，使用 Union Find 及 Kruskcal 找出最小生成樹，樹的邊即是路燈花費最少的開法，所以在加入一條邊時減去花費，最後的結果即是答案。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fmw7gx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根據權重排序</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> edge&amp; r) &#123; <span class="keyword">return</span> w &lt; r.w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// data</span></span><br><span class="line"><span class="keyword">int</span> cost;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; edges;</span><br><span class="line"><span class="keyword">int</span> parents[<span class="number">200001</span>]; <span class="comment">// 每個點的 parent</span></span><br><span class="line"><span class="keyword">int</span> ranks[<span class="number">200001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cost = <span class="number">0</span>;</span><br><span class="line">    edges.clear();</span><br><span class="line">    <span class="comment">// 一開始每個節點的 parent 都是自己，而 rank 皆為 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) parents[i] = i, ranks[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> p == parents[p] ? p : parents[p] = Find(parents[p]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rx = Find(x), ry = Find(y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 x 跟 y 的 root 一樣，表示 x 和 y 接起會造成環</span></span><br><span class="line">    <span class="keyword">if</span> (rx == ry) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 將 rank 較小的接到 rank 較大的樹下面，因為這樣後面 Find 時消耗較小</span></span><br><span class="line">    <span class="keyword">if</span> (ranks[rx] &gt; ranks[ry]) parents[ry] = rx;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ranks[rx] &lt; ranks[ry]) parents[rx] = ry;</span><br><span class="line">    <span class="keyword">else</span> parents[ry] = rx, ++ranks[rx];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskcal</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [u, v, w] : edges)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若 u、v 接起會造成環則不接</span></span><br><span class="line">        <span class="keyword">if</span> (!Union(u, v)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將總花費減去實際花費</span></span><br><span class="line">        cost -= w;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n &amp;&amp; !(!n &amp;&amp; !m))</span><br><span class="line">    &#123;</span><br><span class="line">        init(m);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, w;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            cost += w; <span class="comment">// 先將總花費加起來</span></span><br><span class="line">            edges.push_back(&#123; u, v, w &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(edges.begin(), edges.end());</span><br><span class="line"></span><br><span class="line">        kruskcal(m);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cost &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/11631.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fmw7gx">[UVA] 11631 - Dark roads @ 程式碼備份區 :: 痞客邦 ::</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Graph</tag>
        <tag>Vector</tag>
        <tag>Union Find</tag>
        <tag>Kruskcal</tag>
        <tag>Minimum Spanning Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11633 解題紀錄</title>
    <url>/UVa-11633/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=2680">UVa - 11633 - Food portion sizes</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>學生餐廳為了不讓學生餓肚子，以及方便他們為每一個學生製作餐點，每一份餐點的量都會相同，然而一份餐點對於某些學生來說太少，因此必須多跑幾次餐廳才能吃飽，已知每位學生不會跑大於 3 次餐廳，而每位學生只會吃自己所需要的份量，剩餘的份量就是浪費。</p>
<span id="more"></span>

<p>請最小化 ax + by，其中 a, b 為給定的常數，x 為所有學生所製造的廚餘，y 為所有學生跑餐廳次數的總和。</p>
<p>引用自：<a href="https://ppt.cc/fOSfWx">UVa 11633 - Food portion sizes | Morris Blog</a></p>
<p><strong>Input：</strong> 每組測資第一個數字 <code>N</code>，表示有幾位學生，後面兩個整數分別代表 <code>a</code>、<code>b</code>，之後 <code>N</code> 個整數表示每位學生的食量。</p>
<p><strong>Output：</strong> 輸出 ax + by 的最小值，若不為整數，請輸出為約分後的分數型態。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>由於輸出格式的原因，所以要避免再計算的時候出現小數，因此先將所有學生的食量都乘以 6，因為每位學生可能會去餐廳 1 ~ 3 次，這樣每份餐點的量就會是整數。</p>
<p>之後暴力法模擬每位學生去餐廳 1 ~ 3 次的情況下每份餐點的量，計算出 ax + by 的值即可，需要注意的是，因為我們把每位學生的食量都乘以 6，因此拿取的次數也要先乘以 6，這樣 ax + by 的值即是我們計算出的結果除以 6。</p>
<p>最後再檢查結果是否有分數，若有分數則找出該值與 6 的最大公因數，之後輸出即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fOSfWx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y % x == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> GCD(y % x, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="keyword">int</span> mx;</span><br><span class="line"><span class="keyword">int</span> stus[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mx = INT_MIN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="built_in">cin</span> &gt;&gt; stus[i], mx = max(mx, stus[i] *= <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> mn = INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> q1, q2; <span class="comment">// 餐點量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; time : &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 有學生需要跑餐廳超過三次</span></span><br><span class="line">        <span class="keyword">if</span> ((q1 = stus[i] / time) * <span class="number">3</span> &lt; mx) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        x = y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            q2 = stus[j];</span><br><span class="line">            <span class="keyword">while</span> (q2 &gt; q1) q2 -= q1, ++y;</span><br><span class="line">            x += q1 - q2;</span><br><span class="line">            ++y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mn = min(a * x + <span class="number">6</span> * b * y, mn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 約分</span></span><br><span class="line">    <span class="keyword">int</span> _gcd = GCD(mn, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span> (_gcd == <span class="number">6</span>) <span class="built_in">cout</span> &lt;&lt; mn / <span class="number">6</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; mn / _gcd &lt;&lt; <span class="string">&quot; / &quot;</span> &lt;&lt; <span class="number">6</span> / _gcd &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N &amp;&amp; N)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fOSfWx">UVa 11633 - Food portion sizes | Morris Blog</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>CPE - 2020/12/22</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11689 解題紀錄</title>
    <url>/UVa-11689/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=2736">UVa - 11689 - Soda Surpler</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>有一個人很喜歡喝汽水，汽水可以使用空瓶兌換，每組測資給三個整數 <code>e</code>、<code>f</code>、<code>c</code>，分別代表 <code>初始擁有的空瓶數量</code>、<code>找到的空瓶數量</code>、<code>兌換一瓶汽水需要的空瓶數量</code>。</p>
<span id="more"></span>

<p><strong>Input：</strong> 第一個整數 <code>T</code> 代表有 <code>T</code> 組測資，每組一行，每行有三個整數分別代表 <code>e</code>、<code>f</code>、<code>c</code>。</p>
<p><strong>Output：</strong> 輸出最多能喝到幾瓶汽水。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>根據題意模擬即可，<code>e + f</code> 為一開始擁有的空瓶數量，<strong>需要注意的是，兌換到的汽水也要加進空瓶的數量</strong>。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// e -&gt; empty, f -&gt; found, c -&gt; cost</span></span><br><span class="line">    <span class="keyword">int</span> T, e, f, c, ret;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; e &gt;&gt; f &gt;&gt; c;</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">        e += f; <span class="comment">// total empty bottles</span></span><br><span class="line">        <span class="keyword">while</span> (e &gt;= c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> bottles = e / c;</span><br><span class="line">            ret += bottles;</span><br><span class="line">            e = bottles + e % c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>CPE - 2020/12/22</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11790 解題紀錄</title>
    <url>/UVa-11790/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=2890">UVa - 11790 - Murcia’s Skyline</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>依序給一些建築物的高及重量，求建築物高度嚴格遞增且最寬的寬度，及建築物高度嚴格遞減且最寬的寬度。</p>
<p><strong>Input：</strong> 第一個整數 <code>T</code>，表示有 <code>T</code> 組測資，每組測資第一個整數 <code>n</code>，表示有 <code>n</code> 個建築物，後面 <code>n</code> 個數字為建築物的高度，再後面 <code>n</code> 個數字為建築物的寬度。</p>
<p><strong>Output：</strong> 輸出 LIS 及 LDS 的寬度，若 LIS 較大則先輸出 LIS，否則先輸出 LDS。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 DP 找出 LIS 及 LDS 即可，記得 <code>LIS[i]</code> 及 <code>LDS[i]</code> 要初始化為 <code>wides[i]</code> 而不是 1。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Case;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> mxLIS;</span><br><span class="line"><span class="keyword">int</span> mxLDS;</span><br><span class="line"><span class="keyword">int</span> heights[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">int</span> wides[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">int</span> LIS[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">int</span> LDS[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mxLIS = mxLDS = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">cin</span> &gt;&gt; heights[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">cin</span> &gt;&gt; wides[i], LIS[i] = LDS[i] = wides[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 若 i 能接在 j 後面 ( LIS )</span></span><br><span class="line">            <span class="keyword">if</span> (heights[i] &gt; heights[j]) LIS[i] = max(LIS[j] + wides[i], LIS[i]);</span><br><span class="line">            <span class="comment">// 若 i 能接在 j 後面 ( LDS )</span></span><br><span class="line">            <span class="keyword">if</span> (heights[i] &lt; heights[j]) LDS[i] = max(LDS[j] + wides[i], LDS[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        mxLIS = max(LIS[i], mxLIS);</span><br><span class="line">        mxLDS = max(LDS[i], mxLDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; ++Case &lt;&lt; <span class="string">&quot;. &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (mxLIS &gt;= mxLDS) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Increasing (&quot;</span> &lt;&lt; mxLIS &lt;&lt; <span class="string">&quot;). Decreasing (&quot;</span> &lt;&lt; mxLDS &lt;&lt; <span class="string">&quot;).\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Decreasing (&quot;</span> &lt;&lt; mxLDS &lt;&lt; <span class="string">&quot;). Increasing (&quot;</span> &lt;&lt; mxLIS &lt;&lt; <span class="string">&quot;).\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>UVa</tag>
        <tag>LIS</tag>
        <tag>LDS</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11747 解題紀錄</title>
    <url>/UVa-11747/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=2847">UVa - 11747 - Heavy Cycle Edges</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個無向圖，使得所有點連通，並且優先選擇權重較小的邊，求多餘的邊。</p>
<span id="more"></span>

<p><strong>Input：</strong> 每組測資的第一行為兩個整數 <code>n</code>、<code>m</code>，分別代表點的數量及邊的數量，若兩者皆為 0 則結束。後面 <code>m</code> 行，每行有三個整數 <code>u</code>、<code>v</code>、<code>w</code>，表示有邊 <code>(u, v)</code>，權重為 <code>w</code>。</p>
<p><strong>Output：</strong> 輸出所有多餘的邊的權重，若沒有多餘的邊則輸出 <code>&quot;forest&quot;</code>。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p><strong>這個解法需要有 Union Find 及 Kruskcal 演算法的概念。</strong></p>
<p>使用 Union Find 及 Kruskcal 找出最小生成樹，所有不在樹裡面的邊即是多餘的邊，邊做邊輸出即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/f0psNx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根據權重排序</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> edge&amp; r) &#123; <span class="keyword">return</span> w &lt; r.w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// data</span></span><br><span class="line"><span class="keyword">int</span> n, m; <span class="comment">// input</span></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; edges;</span><br><span class="line"><span class="keyword">int</span> parents[<span class="number">1001</span>]; <span class="comment">// 每個點的 parent</span></span><br><span class="line"><span class="keyword">int</span> ranks[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edges.clear();</span><br><span class="line">    <span class="comment">// 一開始每個節點的 parent 都是自己，而 rank 皆為 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) parents[i] = i, ranks[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="keyword">return</span> p == parents[p] ? p : parents[p] = Find(parents[p]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rx = Find(x), ry = Find(y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 x 跟 y 的 root 一樣，表示 x 和 y 接起會造成環</span></span><br><span class="line">    <span class="keyword">if</span> (rx == ry) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 將 rank 較小的接到 rank 較大的樹下面，因為這樣後面 Find 時消耗較小</span></span><br><span class="line">    <span class="keyword">if</span> (ranks[x] &gt; ranks[y]) parents[ry] = rx;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ranks[x] &lt; ranks[y]) parents[rx] = ry;</span><br><span class="line">    <span class="keyword">else</span> parents[ry] = rx, ++ranks[rx];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskcal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isOut = <span class="literal">false</span>; <span class="comment">// 是否已經有輸出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [u, v, w] : edges)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Union(u, v)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若 u、v 已經連通了表示邊 (u, v) 是多餘的邊</span></span><br><span class="line">        <span class="keyword">if</span> (isOut) <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; w;</span><br><span class="line">        isOut = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isOut) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;forest&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; !(!n &amp;&amp; !m))</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, w;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            edges.push_back(&#123; u, v, w &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(edges.begin(), edges.end());</span><br><span class="line"></span><br><span class="line">        kruskcal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/11747.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/f0psNx">[UVA] 11747 - Heavy Cycle Edges @ 程式碼備份區 :: 痞客邦 ::</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Graph</tag>
        <tag>Vector</tag>
        <tag>Union Find</tag>
        <tag>Kruskcal</tag>
        <tag>Minimum Spanning Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11838 解題紀錄</title>
    <url>/UVa-11838/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=2938">UVa - 11838 - Come and Go</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給有向圖，求整張圖是否為一個 SCC ( Strongly Connected Component )。SCC 即在有向圖上任意選兩點 <code>u</code>、<code>v</code>，<code>u</code> 能夠走到 <code>v</code> 且 <code>v</code> 也能夠走到 <code>u</code>。</p>
<span id="more"></span>

<p><strong>Input：</strong> 每組測資第一行為兩個整數 <code>N</code>、<code>M</code>，分別代表 <code>點的數量 (1 ~ N)</code> 及 <code>邊的關係</code>，若 N、M 都為 0 則結束。接下來 <code>M</code> 行每行有三個整數 <code>u</code>、<code>v</code>、<code>P</code>，若 <code>P</code> 為 1 表示有 <code>u -&gt; v</code> 的邊，若 <code>P</code> 為 2 表示有 <code>u -&gt; v</code> 及 <code>v -&gt; u</code> 的邊。</p>
<p><strong>Output：</strong> 若整張圖為一個 SCC 則輸出 1，否則輸出 0。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>DFS 找 SCC 並紀錄 SCC 的個數即可。需要注意的是當我們知道 SCC 的個數大於一就可以直接輸出了不用繼續往下做。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fkxbXx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> TIME;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dfn;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; low;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; inStack;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; G;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++TIME;</span><br><span class="line">    s.push(u);</span><br><span class="line">    inStack.insert(u);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : G[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (inStack.count(v)) low[u] = min(dfn[v], low[u]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(v);</span><br><span class="line">        low[u] = min(low[v], low[u]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dfn[u] == low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            inStack.erase(tmp);</span><br><span class="line">        &#125; <span class="keyword">while</span> (tmp != u);</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &amp;&amp; !(!N &amp;&amp; !M))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        TIME = <span class="number">0</span>;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        dfn.assign(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        low.assign(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        inStack.clear();</span><br><span class="line">        G.assign(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) s.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (M--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, P; <span class="comment">// P 為 1 代表單向 u -&gt; v，為 2 代表雙向 u -&gt; v, v -&gt; u</span></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; P;</span><br><span class="line"></span><br><span class="line">            G[u].push_back(v);</span><br><span class="line">            <span class="keyword">if</span> (P == <span class="number">2</span>) G[v].push_back(u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= N; ++u) <span class="keyword">if</span> (!dfn[u] &amp;&amp; cnt &lt; <span class="number">2</span>) dfs(u);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (cnt == <span class="number">1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/11838.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fkxbXx">Programming學習筆記: UVa 11838 Come and Go</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Stack</tag>
        <tag>Recursive</tag>
        <tag>Graph</tag>
        <tag>Vector</tag>
        <tag>Unordered_set</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11906 解題紀錄</title>
    <url>/UVa-11906/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=99999999&page=show_problem&category=0&problem=3057">UVa - 11906 - Knight in a War Grid</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>有一個騎士在一個 <code>R x C</code> 的棋盤上移動，從 <strong>(0, 0)</strong> 開始，每次可以從該點移動到 <code>(±M, ±N)</code> 及 <code>(±N, ±M)</code> 的點，有些點有水則不能跳。如果一個點能從偶數個點跳過來則標記為 <code>偶</code>，如果能從奇數個點跳過來則標記為 <code>奇</code>。求整個棋盤上 <code>奇</code> 跟 <code>偶</code> 的個數。</p>
<span id="more"></span>

<p><strong>Input：</strong> 第一行為一整數 <code>T</code>，代表有 <code>T</code> 組測資，每組測資的第一行為 4 個整數 <code>R</code>、<code>C</code>、<code>M</code>、<code>N</code>，接下來一行為一個整數 <code>W</code>，代表有 <code>W</code> 個有水的點，接下來 <code>W</code> 行，每行有兩個整數，代表有水的點的座標 **(x, y)**。</p>
<p><strong>Output：</strong> 輸出每組測資的 <code>偶</code>、<code>奇</code> 個數。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 DFS 模擬，紀錄每個點被走到的次數，最後再計算 <code>奇</code>、<code>偶</code> 的個數即可，需要注意的是若 <code>M</code>、<code>N</code> 皆大於 0 且不相同，每次會有 8 個點可以走，若 <code>M</code>、<code>N</code> 相同或是兩者中有一個為 0 則每次只會有 4 個點可以走。還有若是 <strong>(0, 0)</strong> 除了一開始走到之外都沒有被走到的話會被歸類在 <code>even</code> 裡面。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOOP(n) for(int I = 0; I &lt; n; ++I)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/f7N4Ix</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, Case = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    LOOP(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> R, C, M, N, W;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; R &gt;&gt; C &gt;&gt; M &gt;&gt; N &gt;&gt; W;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0 沒走過，&gt;= 1 走過，-1 有水 ( 不能走 )</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; maps(R, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(C));</span><br><span class="line"></span><br><span class="line">        LOOP(W)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            maps[x][y] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= R || y &lt; <span class="number">0</span> || y &gt;= C || maps[x][y] == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果當前的點已經有往下走過的話就只要增加可以走到當前的點的次數即可</span></span><br><span class="line">            <span class="keyword">if</span> (maps[x][y]++ != <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> _x = M, _y = N;</span><br><span class="line">            LOOP(<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dfs(x + _x, y + _y);</span><br><span class="line">                dfs(x - _x, y - _y);</span><br><span class="line">                <span class="keyword">if</span> (_x &amp;&amp; _y)</span><br><span class="line">                &#123;</span><br><span class="line">                    dfs(x + _x, y - _y);</span><br><span class="line">                    dfs(x - _x, y + _y);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (_x == _y) <span class="keyword">break</span>;</span><br><span class="line">                swap(_x, _y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        --maps[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> odd = <span class="number">0</span>, even = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : maps) <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            i &amp; <span class="number">1</span> ? ++odd : ++even;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若 (0, 0) 只有在一開始的時候走到過，代表為 even</span></span><br><span class="line">        <span class="keyword">if</span> (!maps[<span class="number">0</span>][<span class="number">0</span>]) ++even;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; ++Case &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; even &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; odd &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/11906.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/f7N4Ix">UVa 11906 - Knight in a War Grid</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Recursive</tag>
        <tag>Graph</tag>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11951 解題紀錄</title>
    <url>/UVa-11951/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3102">UVa - 11951 - Area</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 <code>N</code> * <code>M</code> 的矩陣，矩陣上有一些數字，求最大的子矩陣面積，且子矩陣和不可超過 <code>K</code>。若有相同面積的子矩陣，取子矩陣和最小的那個子矩陣和。</p>
<p><strong>Input：</strong> 第一個整數為 <code>T</code>，表示有 <code>T</code> 組測資，每組測資前三個整數依序為 <code>N</code>、<code>M</code>、<code>K</code>，後面 <code>N</code> * <code>M</code> 個整數為矩陣中的數字。</p>
<p><strong>Output：</strong> 求最大的子矩陣面積，且子矩陣和不可超過 <code>K</code>。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>Kadane’s Algorithm 題，將二維壓成一維之後使用 Kadane’s Algorithm 求解即可。</p>
<p>由於有不可超過 <code>K</code> 的限制，且要求的是子矩陣的最大面積，因此修改一下，<code>l</code> 為左端點，遍歷到的 <code>sum[i]</code> 視為右端點，當總和超過 <code>K</code> 時不斷將左端點往左移，接著計算面積即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fXQTNx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> C;</span><br><span class="line"><span class="keyword">int</span> N, M, K;</span><br><span class="line"><span class="keyword">int</span> t, b;</span><br><span class="line"><span class="keyword">int</span> price, mxArea;</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> table[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; K;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; ++j) <span class="built_in">cin</span> &gt;&gt; table[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max1D</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, s = <span class="number">0</span>, area;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        s += sum[i];</span><br><span class="line">        <span class="keyword">while</span> (s &gt; K) s -= sum[l++];</span><br><span class="line"></span><br><span class="line">        area = (b - t + <span class="number">1</span>) * (i - l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (area &gt; mxArea) mxArea = area, price = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (area == mxArea) price = min(s, price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mxArea = <span class="number">0</span>;</span><br><span class="line">    price = INT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// max2D</span></span><br><span class="line">    <span class="keyword">for</span> (t = <span class="number">0</span>; t &lt; N; ++t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (b = t; b &lt; N; ++b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) sum[i] += table[b][i];</span><br><span class="line">            max1D();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; ++C &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; mxArea &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; price &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fXQTNx">UVa 11951 - Area · geniustanley</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>UVa</tag>
        <tag>Kadane</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11960 解題紀錄</title>
    <url>/UVa-11960/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=3111">UVa - 11960 - Divisor Game</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個整數 <code>N</code>，求小於等於 <code>N</code> 的正整數中，因數最多的數字，若有相同則取較大者。</p>
<span id="more"></span>

<p><strong>Input：</strong> 第一個整數 <code>T</code>，表示有 <code>T</code> 組測資，後面 <code>T</code> 行每行都有一個整數，代表 <code>N</code>。</p>
<p><strong>Output：</strong> 輸出小於等於 <code>N</code> 的正整數中，因數最多的數字，若有相同則取較大者。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p><strong>解法一:</strong></p>
<p>想知道每個數字的因數個數，可以使用一個數組保存並初始化為 1，因為每個數都至少有一個因數，接著遍歷陣列，將所有數字的倍數都加一，最後就可以得到所有數的因數個數，最後根據題目的要求更新數組並輸出答案即可。</p>
<p><strong>解法二:</strong></p>
<p>一個正整數的所有因數其實都是該數質因數的組合 ( 可參考本篇文章: <a href="https://hackmd.io/@SCIST/BasicMath3#UVa-11960">演算法課程題解 - 基礎數論 3 - HackMD</a> )，因此要知道該數因數的個數，需要先做質因數分解，可以先使用質數篩 ( 可參考本篇文章: <a href="http://web.ntnu.edu.tw/~algo/Prime.html#3">演算法筆記 - Prime</a> )，找出每個數的最小質因數，接著遍歷陣列，將數字不斷除以自己的最小質因數即可完成質因數分解。接著根據題目的要求更新數組並輸出答案即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fxmaAx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = (<span class="keyword">int</span>)<span class="number">1e6</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> ans[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preProcessing</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxN; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; maxN; j += i) ++ans[j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">2</span>, _max = ans[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; maxN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i] &gt;= _max) _max = ans[i], n = i;</span><br><span class="line">        ans[i] = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, tmp;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[tmp] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    preProcessing();</span><br><span class="line">    solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">reference:</span></span><br><span class="line"><span class="comment">    https://hackmd.io/@SCIST/BasicMath3#UVa-11960</span></span><br><span class="line"><span class="comment">    質數篩: http://web.ntnu.edu.tw/~algo/Prime.html#3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxN = (<span class="keyword">int</span>)<span class="number">1e6</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> prime[maxN];  <span class="comment">// 紀錄每個數字的最小質因數</span></span><br><span class="line"><span class="keyword">int</span> ans[maxN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preProcessing</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 質數篩</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">2</span>; i &lt; maxN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (prime[i]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        prime[i] = (<span class="keyword">int</span>)i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> j = i * i; j &lt; maxN; j += i)</span><br><span class="line">            <span class="keyword">if</span> (!prime[j]) prime[j] = (<span class="keyword">int</span>)i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 計算每個數的因數個數，找出每個質因數的最大次方，可能性就是最大次方加一 ( 可不選 )</span></span><br><span class="line">    fill(ans, ans + maxN, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = i;</span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p = prime[tmp], cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!(tmp % p)) tmp /= p, ++cnt;</span><br><span class="line">            ans[i] *= ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">2</span>, _max = ans[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; maxN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i] &gt;= _max) _max = ans[i], n = i;</span><br><span class="line">        ans[i] = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, tmp;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[tmp] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    preProcessing();</span><br><span class="line">    solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fxmaAx">範例程式碼 uva11960</a><br><a href="https://hackmd.io/@SCIST/BasicMath3#UVa-11960">演算法課程題解 - 基礎數論 3 - HackMD</a><br><a href="http://web.ntnu.edu.tw/~algo/Prime.html#3">演算法筆記 - Prime</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Queue</tag>
        <tag>CPE - 2020/12/22</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11995 解題紀錄</title>
    <url>/UVa-11995/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=3146">UVa - 11995 - I Can Guess the Data Structure!</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個整數 <code>n</code>，代表接下來有 <code>n</code> 行的指令，若指令為 <code>1</code> 加上一個數字，代表將該數字放入容器中，若為 2 加上一個數字，代表容器的 <code>top()</code> 或 <code>front()</code> 為該數字，同時將該數字 <code>pop()</code> 出。<span id="more"></span>結束後判斷該容器為 Stack 或 Queue 還是 Priority_queue，若三者都不是則輸出 <code>&quot;impossible&quot;</code>，若兩者以上的容器皆可則輸出 <code>&quot;not sure&quot;</code>。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用三個容器去模擬操作即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, cmd, val;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> S = <span class="literal">true</span>, Q = <span class="literal">true</span>, PQ = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line">        <span class="keyword">while</span> (n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; cmd &gt;&gt; val;</span><br><span class="line">            <span class="keyword">switch</span> (cmd)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                s.push(val), q.push(val), pq.push(val);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> (S)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!s.empty() &amp;&amp; s.top() == val) s.pop();</span><br><span class="line">                    <span class="keyword">else</span> S = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (Q)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!q.empty() &amp;&amp; q.front() == val) q.pop();</span><br><span class="line">                    <span class="keyword">else</span> Q = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PQ)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!pq.empty() &amp;&amp; pq.top() == val) pq.pop();</span><br><span class="line">                    <span class="keyword">else</span> PQ = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((S &amp;&amp; Q) || (S &amp;&amp; PQ) || (Q &amp;&amp; PQ)) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not sure\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (S) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;stack\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Q) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;queue\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (PQ) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;priority queue\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;impossible\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/11995.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Vector</tag>
        <tag>Priority_queue</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 1203 解題紀錄</title>
    <url>/UVa-1203/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=3644">UVa - 1203 - Argus</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一些 Register 的編號及週期，根據題目要求前 <code>K</code> 個被執行的 Register。若有執行相同的 Register 則編號小的優先執行。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>建造一個 Structure 並 Overload operator&lt; 之後使用 Priority_queue 實作即可，每次 Register 執行後將時間加上週期後重新推入。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> period;</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> reg&amp; r) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (time &gt; r.time || (time == r.time &amp;&amp; num &gt; r.num));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num, time;</span><br><span class="line">    <span class="built_in">string</span> in;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;reg&gt; pq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; in &amp;&amp; in != <span class="string">&quot;#&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num &gt;&gt; time;</span><br><span class="line">        pq.push(&#123; num, time, time &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = pq.top();</span><br><span class="line">        pq.pop();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tmp.num &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        pq.push(&#123; tmp.num, tmp.period, tmp.time + tmp.period &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/01203.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Priority_queue</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 11988 解題紀錄</title>
    <url>/UVa-11988/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=3139">UVa - 11988 - Broken Keyboard (a.k.a. Beiju Text)</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給 String，模擬鍵盤輸入的情況，<code>&#39;[&#39;</code> 為 home 鍵，<code>&#39;]&#39;</code> 為 end 鍵，求模擬輸出後的字串為何。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 List 儲存結果，使用 iterator 紀錄目前游標的位置，遍歷 String，當碰到 <code>&#39;[&#39;</code> 將 <code>it</code> 更新為 <code>begin()</code>，碰到 <code>&#39;]&#39;</code> 將 <code>it</code> 更新為 <code>end()</code>，其餘情況則使用 <code>insert()</code> 將字元放入即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, str) &amp;&amp; !str.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt; l;</span><br><span class="line">        <span class="keyword">auto</span> it = l.begin();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : str)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (ch)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">                it = l.begin();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                it = l.end();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                l.insert(it, ch);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : l) <span class="built_in">cout</span> &lt;&lt; ch;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/11988.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 1206 解題紀錄</title>
    <url>/UVa-1206/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=3647">UVa - 1206 - Boundary Points</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一些在二維平面的座標點，求包住所有座標點的最小多邊形的頂點座標。</p>
<p><strong>Input：</strong> 每行為一組測資，每組括號為一個座標點。</p>
<p><strong>Output：</strong> 依照 Input 的格式輸出那些點的座標，起點在最後必須再輸出一次。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p><strong>此解法需要有 Convex Hull 及 Graham Scan 演算法的概念</strong></p>
<p>簡單的凸包題，使用 Graham Scan 演算法找出所有頂點即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt; b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(c) memset(c, 0, sizeof(c))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MXN = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> d; <span class="comment">// 與第一個點的距離</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point P[MXN];</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> top; <span class="comment">// 凸包頂點數</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 兩點間的距離</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">const</span> Point&amp; l, <span class="keyword">const</span> Point&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(l.x - r.x, <span class="number">2</span>) + <span class="built_in">pow</span>(l.y - r.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">crossProduct</span><span class="params">(<span class="keyword">const</span> Point&amp; o, <span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.x - o.x) * (b.y - o.y) - (b.x - o.x) * (a.y - o.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 選出最下面的點，若有相同 y 的點則選擇 x 較小的那個</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">const</span> Point&amp; l, <span class="keyword">const</span> Point&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l.y == r.y ? l.x &lt; r.x : l.y &lt; r.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 極角排序，cp &gt; 0: ol -&gt; or 逆時針</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">const</span> Point&amp; l, <span class="keyword">const</span> Point&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cp = crossProduct(P[<span class="number">0</span>], l, r);</span><br><span class="line">    <span class="keyword">return</span> cp == <span class="number">0</span> ? l.d &lt; r.d : cp &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    N = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; c &gt;&gt; P[N].x &gt;&gt; c &gt;&gt; P[N].y &gt;&gt; c) ++N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convex Hull</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GrahamScan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找出第一個點，並將其他點依照極角排序</span></span><br><span class="line">    sort(P, P + N, cmp1);</span><br><span class="line">    FOR(i, <span class="number">1</span>, N) P[i].d = dist(P[<span class="number">0</span>], P[i]);</span><br><span class="line">    sort(P + <span class="number">1</span>, P + N, cmp2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找凸包</span></span><br><span class="line">    top = <span class="number">1</span>;</span><br><span class="line">    P[N++] = P[<span class="number">0</span>];</span><br><span class="line">    FOR(i, <span class="number">2</span>, N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">0</span> &amp;&amp; crossProduct(P[top - <span class="number">1</span>], P[top], P[i]) &lt;= <span class="number">0</span>) --top;</span><br><span class="line">        P[++top] = P[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FOR(i, <span class="number">0</span>, top + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i) <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; P[i].x &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; P[i].y &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, str))</span><br><span class="line">    &#123;</span><br><span class="line">        read();</span><br><span class="line">        GrahamScan();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
        <tag>Convex Hull</tag>
        <tag>Graham Scan</tag>
        <tag>Computational Geometry</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 12125 解題紀錄</title>
    <url>/UVa-12125/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=3277">UVa - 12125 - March of the Penguins</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><blockquote>
<p>給定一些冰塊，每個冰塊上有一些企鵝，每個冰塊有一個可以跳出的次數限制，每個冰塊位於一個坐標，現在每個企鵝跳躍力為d，問所有企鵝能否跳到一點上，如果可以輸出所有落腳冰塊，如果沒有方案就打印 -1。</p>
</blockquote>
<p><a href="https://ppt.cc/fHi3ax">UVA 12125 - March of the Penguins（最大流）_Remilia’s-CSDN博客</a></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>最大流，依照上面的說明建邊後使用 Dinic 求解即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt; b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(c) memset(c, 0, sizeof(c))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">QPOP</span><span class="params">(<span class="built_in">queue</span>&lt;T&gt;&amp; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123; <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; n &gt;&gt; m; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fHi3ax</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MXN = <span class="number">205</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S, T;</span><br><span class="line"><span class="keyword">int</span> rn[MXN][MXN];</span><br><span class="line"><span class="keyword">int</span> l[MXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">double</span> D;</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line">Point p[MXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">const</span> Point&amp; l, <span class="keyword">const</span> Point&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(l.x - r.x, <span class="number">2</span>) + <span class="built_in">pow</span>(l.y - r.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; D;</span><br><span class="line"></span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    T = N * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    FOR(i, <span class="number">1</span>, N + <span class="number">1</span>) p[i].read(), tot += p[i].n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLR(rn);</span><br><span class="line"></span><br><span class="line">    FOR(i, <span class="number">1</span>, N + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rn[S][i] = p[i].n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 冰塊的跳出限制</span></span><br><span class="line">        <span class="keyword">if</span> (i == u) rn[u][u + N] = INF;</span><br><span class="line">        <span class="keyword">else</span> rn[i][i + N] = p[i].m;</span><br><span class="line"></span><br><span class="line">        FOR(j, i + <span class="number">1</span>, N + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist(p[i], p[j]) &gt; D) <span class="keyword">continue</span>;</span><br><span class="line">            rn[i + N][j] = INF;</span><br><span class="line">            rn[j + N][i] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rn[u + N][T] = INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dinicBFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLR(l);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(S);</span><br><span class="line">    l[S] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = QPOP(q);</span><br><span class="line"></span><br><span class="line">        FOR(v, <span class="number">0</span>, T + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l[v] || !rn[u][v]) <span class="keyword">continue</span>;</span><br><span class="line">            l[v] = l[u] + <span class="number">1</span>;</span><br><span class="line">            q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l[T];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinicDFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> cp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == T) <span class="keyword">return</span> cp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp = cp;</span><br><span class="line"></span><br><span class="line">    FOR(v, <span class="number">0</span>, T + <span class="number">1</span> &amp;&amp; tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l[v] != l[u] + <span class="number">1</span> || !rn[u][v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> bt = dinicDFS(v, min(rn[u][v], tmp));</span><br><span class="line">        rn[u][v] -= bt;</span><br><span class="line">        rn[v][u] += bt;</span><br><span class="line">        tmp -= bt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cp - tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximumFlow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (dinicBFS()) mf += dinicDFS(S, INF);</span><br><span class="line">    <span class="keyword">return</span> mf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    FOR(i, <span class="number">1</span>, N + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        build(i);</span><br><span class="line">        <span class="keyword">if</span> (maximumFlow() == tot)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt++) <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cnt) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fHi3ax">UVA 12125 - March of the Penguins（最大流）_Remilia’s-CSDN博客</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Queue</tag>
        <tag>Maximum Flow</tag>
        <tag>Dinic</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 1213 解題紀錄</title>
    <url>/UVa-1213/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3654">UVa - 1213 - Sum of Different Primes</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個整數 <code>n</code>、<code>k</code>，求將 <code>n</code> 拆為 <code>k</code> 個質數相加的結果有幾種。</p>
<p><strong>Input：</strong> 每行兩個整數依序代表 <code>n</code>、<code>k</code>，若皆為 0 表結束。</p>
<p><strong>Output：</strong> 輸出將 <code>n</code> 拆為 <code>k</code> 個質數相加的結果有幾種。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>因為 <code>n</code> &lt;= 1120，所以先使用質數篩找出小於等於 1120 的所有質數。</p>
<p>定義 <code>dp[i][j]</code>，表將 <code>i</code> 拆為 <code>j</code> 個質數相加的情況數。</p>
<p>之後 DP，對於 <code>dp[i][j]</code> 來說，<code>dp[i][j] += dp[i - v][j - 1]</code>，對於所有 <code>v</code> 為小於等於 <code>i</code> 的質數。<br>可思考成 <code>v</code> 為最後加入的質數。</p>
<p>由於 DP 縮減了一維，所以計算時要從後面往前算。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fAybWx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> primeCnt;      <span class="comment">// 質數個數</span></span><br><span class="line"><span class="keyword">int</span> primes[<span class="number">187</span>];   <span class="comment">// 只有 187 個質數</span></span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">1121</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1121</span>][<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// get all primes</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">1120</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">        primes[primeCnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= <span class="number">1120</span>; j += i) visited[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : primes) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1120</span>; i &gt;= v; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == v) dp[v][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= <span class="number">14</span>; ++j) dp[i][j] += dp[i - v][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &amp;&amp; n &amp;&amp; k) <span class="built_in">cout</span> &lt;&lt; dp[n][k] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   sieve();</span><br><span class="line">   compute();</span><br><span class="line">   solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fAybWx">UVa 1213 - Sum of Different Primes_小白菜又菜-CSDN博客</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>UVa</tag>
        <tag>0-1 Knapsack</tag>
        <tag>Sieve</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 12195 解題紀錄</title>
    <url>/UVa-12195/</url>
    <content><![CDATA[<p>題目： <a href="https://zerojudge.tw/ShowProblem?problemid=e504">UVa - 12195 - Jingle Composing</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>每筆測資會有代表音符的字母及 <code>/</code> ，每個音符分別代表不同的持續時間，兩個 <code>/</code> 包起來的字母代表一次的測資。題目要求輸出持續時間為 1 的測資數量。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 String 讀取測資，從 Size = 1 時開始，利用 Switch 判斷字符並加入與其相對應的時間。當 Switch 執行到 Default 時代表目前字符為 <code>/</code> ( 每一行資料只有代表音符的字母及 <code>/</code> )，此時若時間為 64 ( 將每個音符持續時間都乘以 64，方便運算 ) 則將 <code>ans + 1</code>。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> input;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((<span class="built_in">cin</span> &gt;&gt; input) &amp;&amp; input != <span class="string">&quot;*&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, time = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; input.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (input[i])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">                time += <span class="number">64</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">                time += <span class="number">32</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">                time += <span class="number">16</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">                time += <span class="number">8</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">                time += <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>:</span><br><span class="line">                time += <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">                time += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">if</span> (time == <span class="number">64</span>)</span><br><span class="line">                    ++ans;</span><br><span class="line">                time = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/12195.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 12207 解題紀錄</title>
    <url>/UVa-12207/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=3359">UVa - 12207 - That is Your Queue</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個數字，<code>P</code>、<code>C</code>，<code>P</code> 代表列表中的序號個數，從 1 開始，一開始的排序為升冪排序，例如 <code>P = 3</code> 則列表為 <code>&#123;1, 2, 3&#125;</code>。<span id="more"></span><code>C</code> 代表接下來有幾行指令，若指令為 <code>N</code> 表示輸出列表最前面的序號並且將此序號移到列表的尾端，若為 <code>E</code> 加上一個序號代表將該序號代表將該序號移到列表的前端。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 List 模擬操作並且使用 Unordered_map 提升搜尋速度即可。需要注意的是，若 <code>C</code> 的值小於 <code>P</code> 的值則我們一開始只需要推入 <code>C</code> 個序號即可，因為後面的序號除非被往前移動，否則絕對不會使用到。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> P, C, tmp, Case = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; P &gt;&gt; C &amp;&amp; (P || C))</span><br><span class="line">    &#123;</span><br><span class="line">        l.clear(), m.clear();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; ++Case &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min(P, C); i++) m[i] = l.insert(l.end(), i);</span><br><span class="line">        <span class="keyword">while</span> (C--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;N&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; l.front() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                m[l.front()] = l.insert(l.end(), l.front());</span><br><span class="line">                l.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">                <span class="keyword">if</span> (m.find(tmp) != m.end()) l.erase(m[tmp]);</span><br><span class="line">                m[tmp] = l.insert(l.begin(), tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/12207.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Unordered_map</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 12319 解題紀錄</title>
    <url>/UVa-12319/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=3741">UVa - 12319 - Edgetown’s Traffic Jams</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個無向圖及一個有向圖，兩圖上的點數量一樣，求任兩點的最短路徑在有向圖上是否大於在無向圖上的 <code>A</code> 倍加 <code>B</code>。</p>
<span id="more"></span>

<p><strong>Input：</strong> 每組測資第一個整數 <code>N</code> 表示有 <code>N</code> 個點 **( 編號為 1 ~ N )**，後面 <code>N</code> 行依序為無向圖的連接情況，再後面 <code>N</code> 行依序為有向圖的連接情況，每行至少有一個整數 <code>u</code>，後面的數字表示有 <code>u</code> 到該數字的邊，且邊的路徑長為 1。</p>
<p><strong>Output：</strong> 若任兩點的最短路徑在有向圖上大於在無向圖上的 <code>A</code> 倍加 <code>B</code> 輸出 “Yes”，否則輸出 “No”。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p><strong>這個解法需要有 Floyd-Warshall 演算法的概念。</strong></p>
<p>先讀取測資，若任兩點沒有邊連接，則路徑長初始化為無限大( 1e9 )，之後使用 Floyd-Warshall 演算法找出圖上任兩點的最短路徑，再依照題目要求判斷即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">reference:</span></span><br><span class="line"><span class="comment">    https://ppt.cc/fJv50x</span></span><br><span class="line"><span class="comment">    Floyd-Warshall Algorithm:</span></span><br><span class="line"><span class="comment">        https://ppt.cc/fstMux</span></span><br><span class="line"><span class="comment">        https://ppt.cc/fsQm1x</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="keyword">int</span> G1[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> G2[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(G1[<span class="number">0</span>], G1[<span class="number">0</span>] + <span class="number">101</span> * <span class="number">101</span>, inf);</span><br><span class="line">    fill(G2[<span class="number">0</span>], G2[<span class="number">0</span>] + <span class="number">101</span> * <span class="number">101</span>, inf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readGraph</span><span class="params">(<span class="keyword">int</span> (*G)[<span class="number">101</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        getline(<span class="built_in">cin</span>, str);</span><br><span class="line">        ss.clear();</span><br><span class="line">        ss.str(str);</span><br><span class="line">        ss &gt;&gt; tmp;</span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; tmp) G[i][tmp] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FloydWarshall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            G1[i][j] = min(G1[i][j], G1[i][k] + G1[k][j]);</span><br><span class="line">            G2[i][j] = min(G2[i][j], G2[i][k] + G2[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">        <span class="keyword">if</span> (i != j &amp;&amp; G2[i][j] &gt; G1[i][j] * a + b) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="built_in">cin</span> &gt;&gt; N).ignore() &amp;&amp; N)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        readGraph(G1);</span><br><span class="line">        readGraph(G2);</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">        FloydWarshall();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (solve()) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fJv50x">Uva 12319 Edgetown’s Traffic Jams @ louisfghbvc的部落格 :: 痞客邦 ::</a><br><a href="https://ppt.cc/fstMux">[演算法] 最短路徑 (Floyd-Warshall 演算法) - iT 邦幫忙::一起幫忙解決難題，拯救 IT 人的一天</a><br><a href="https://ppt.cc/fsQm1x">All-Pairs Shortest Path：Floyd-Warshall Algorithm</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
        <tag>Floyd-Warshall</tag>
        <tag>CPE - 2020/12/22</tag>
        <tag>Graph</tag>
        <tag>Stringstream</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 12442 解題紀錄</title>
    <url>/UVa-12442/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&category=0&problem=3873">UVa - 12442 - Forwarding Emails</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>有一個小鎮，裡面的居民每個人都只會給另一個人寄信，求把信寄給哪位居民可以讓最多人看到這封信，若有相同者則取較小者。</p>
<span id="more"></span>

<p><strong>Input：</strong> 第一行為一整數 <code>T</code>，代表有 <code>T</code> 組測資，每組測資的第一行為一整數 <code>N</code>，接下來 <code>N</code> 行每行都有兩個整數 <code>u</code>、<code>v</code>，代表居民 <code>u</code> 會把信寄給居民 <code>v</code>。</p>
<p><strong>Output：</strong> 輸出寄信給誰可以讓最多的居民看到這封信，若有相同者則取較小者。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>DFS 模擬即可，由於會 TLE，所以進行一點剪枝，多使用一個陣列紀錄某位居民是否已經被模擬過了，若在前面被模擬過了則就不需要在模擬第一個寄信給這位居民了，因為前面模擬的是另一個居民會寄給這位居民，一定會比直接寄信給這位居民的人數還要多。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">若居民有 <span class="number">3</span> 人，且寄信關係為：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">則寄信給第一位居民時會再寄給第三位居民，那遍歷到第三位居民時就不需要在模擬一次了，</span><br><span class="line">因為由第一位寄給第三位，一定會比直接寄給第三位多。</span><br></pre></td></tr></table></figure>

<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOOP(n) for(int I = 0; I &lt; n; ++I)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fXuBwx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    LOOP(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">adj</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line">        LOOP(N)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            adj[u] = v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> _max = INT_MIN, ret = <span class="number">0</span>;</span><br><span class="line">        vector&lt;bool&gt; visited(N + 1), dfsV;</span><br><span class="line"></span><br><span class="line">        function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u) -&gt; <span class="keyword">int</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果已經寄過了就直接回傳，避免環</span></span><br><span class="line">            <span class="keyword">if</span> (dfsV[u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            visited[u] = dfsV[u] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + dfs(adj[u]);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果 i 在前面被做過一次那就不用再做一次了，因為前面是從某個人寄到 i，</span></span><br><span class="line">            <span class="comment">// 一定會比直接寄到 i 還要多人</span></span><br><span class="line">            <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            dfsV.assign(N + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">int</span> tmp = dfs(i);</span><br><span class="line">            <span class="keyword">if</span> (tmp &gt; _max) _max = tmp, ret = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; I + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/12442.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fXuBwx">[UVA] 12442 - Forwarding Emails</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Recursive</tag>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 12503 解題紀錄</title>
    <url>/UVa-12503/</url>
    <content><![CDATA[<p>題目： <a href="https://zerojudge.tw/ShowProblem?problemid=e567">UVa - 12503 - Robot Instructions</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>第一個數字代表有幾筆測資，每筆測資會有一個數字，代表會有幾條字串，根據字串內容移動機器人的座標。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 String 讀取測資，只需要判斷第一個字是哪個字並做出對應的動作即可，使用 Vector 來儲存做過的指令。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, p, temp, moveNum;</span><br><span class="line">    <span class="built_in">string</span> move;</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; moveTemp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; moveNum;</span><br><span class="line">        moveTemp.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (moveNum--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; move;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (move[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">                --p;</span><br><span class="line">                moveTemp.push_back(<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">                ++p;</span><br><span class="line">                moveTemp.push_back(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; move &gt;&gt; temp;</span><br><span class="line">                p += moveTemp[temp - <span class="number">1</span>];</span><br><span class="line">                moveTemp.push_back(moveTemp[temp - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/12503.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 12873 解題紀錄</title>
    <url>/UVa-12873/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4738">UVa - 12873 - The Programmers</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><blockquote>
<p>給 P 個隊伍、S 個賽區，每隊分別都有可以去的賽區，而每一個賽區最多容納 C 個隊伍。<br>請問參加的總隊伍數量最大為何？</p>
</blockquote>
<p><a href="https://ppt.cc/fwPNIx">UVa 12873 - The Programmers | Morris’ Blog</a></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>最大流，可使用 Edmonds-Karp 求解，也可使用 Dinic。這題使用 Edmonds-Karp 執行時間會非常久，但還是可以過，建議使用 Dinic。</p>
<p>將每個隊伍及賽區各自視為一個點，從源點連到隊伍再連到賽區最後連到匯點，之後最大流求解即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><p>Edmonds-Karp:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt; b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(c) memset(c, 0, sizeof(c))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">QPOP</span><span class="params">(<span class="built_in">queue</span>&lt;T&gt;&amp; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fwPNIx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MXN = <span class="number">530</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MXN][MXN];</span><br><span class="line"><span class="keyword">int</span> c[MXN][MXN];</span><br><span class="line"><span class="keyword">int</span> p[MXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// source: 0, sink: P + S + 1</span></span><br><span class="line"><span class="keyword">int</span> P, S, C, m;</span><br><span class="line"><span class="keyword">int</span> source = <span class="number">0</span>, sink;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLR(f);</span><br><span class="line">    CLR(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; P &gt;&gt; S &gt;&gt; C &gt;&gt; m;</span><br><span class="line">    sink = P + S + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        c[u][P + v] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build edges</span></span><br><span class="line">    FOR(i, <span class="number">1</span>, P + <span class="number">1</span>) c[source][i] = <span class="number">1</span>;</span><br><span class="line">    FOR(i, <span class="number">1</span>, S + <span class="number">1</span>) c[i + P][sink] = C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">augment</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> bottleNeck)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == source) <span class="keyword">return</span> bottleNeck;</span><br><span class="line">    bottleNeck = augment(p[u], u, min(c[u][v] - f[u][v], bottleNeck));</span><br><span class="line">    f[u][v] += bottleNeck;</span><br><span class="line">    f[v][u] -= bottleNeck;</span><br><span class="line">    <span class="keyword">return</span> bottleNeck;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Edmonds-Karp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxiumFlow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mf = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        CLR(vis);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(source);</span><br><span class="line">        vis[source] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty() &amp;&amp; !vis[sink])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = QPOP(q);</span><br><span class="line"></span><br><span class="line">            FOR(v, <span class="number">0</span>, sink + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (vis[v] || f[u][v] &gt;= c[u][v]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                q.push(v);</span><br><span class="line">                vis[v] = <span class="literal">true</span>;</span><br><span class="line">                p[v] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!vis[sink]) <span class="keyword">break</span>;</span><br><span class="line">        mf += augment(p[sink], sink, INF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxiumFlow() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的作法將 Flow 跟 Capacity 分開，主要是希望可以保留 Capacity，若沒此需求也可以直接將一開始的 Capacity 當作 Residual Network 來做，可以省去一個陣列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt; b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(c) memset(c, 0, sizeof(c))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">QPOP</span><span class="params">(<span class="built_in">queue</span>&lt;T&gt;&amp; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fwPNIx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MXN = <span class="number">530</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rn[MXN][MXN];</span><br><span class="line"><span class="keyword">int</span> p[MXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// source: 0, sink: P + S + 1</span></span><br><span class="line"><span class="keyword">int</span> P, S, C, m;</span><br><span class="line"><span class="keyword">int</span> source = <span class="number">0</span>, sink;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLR(rn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; P &gt;&gt; S &gt;&gt; C &gt;&gt; m;</span><br><span class="line">    sink = P + S + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        rn[u][P + v] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build edges</span></span><br><span class="line">    FOR(i, <span class="number">1</span>, P + <span class="number">1</span>) rn[source][i] = <span class="number">1</span>;</span><br><span class="line">    FOR(i, <span class="number">1</span>, S + <span class="number">1</span>) rn[i + P][sink] = C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">augment</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> bottleNeck)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == source) <span class="keyword">return</span> bottleNeck;</span><br><span class="line">    bottleNeck = augment(p[u], u, min(rn[u][v], bottleNeck));</span><br><span class="line">    rn[u][v] -= bottleNeck;</span><br><span class="line">    rn[v][u] += bottleNeck;</span><br><span class="line">    <span class="keyword">return</span> bottleNeck;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Edmonds-Karp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxiumFlow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mf = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        CLR(vis);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(source);</span><br><span class="line">        vis[source] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty() &amp;&amp; !vis[sink])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = QPOP(q);</span><br><span class="line"></span><br><span class="line">            FOR(v, <span class="number">0</span>, sink + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (vis[v] || !rn[u][v]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                q.push(v);</span><br><span class="line">                vis[v] = <span class="literal">true</span>;</span><br><span class="line">                p[v] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!vis[sink]) <span class="keyword">break</span>;</span><br><span class="line">        mf += augment(p[sink], sink, INF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxiumFlow() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dinic:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt; b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(c) memset(c, 0, sizeof(c))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">QPOP</span><span class="params">(<span class="built_in">queue</span>&lt;T&gt;&amp; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fXrOUx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MXN = <span class="number">530</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rn[MXN][MXN];</span><br><span class="line"><span class="keyword">int</span> l[MXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// source: 0, sink: P + S + 1</span></span><br><span class="line"><span class="keyword">int</span> P, S, C, m;</span><br><span class="line"><span class="keyword">int</span> source = <span class="number">0</span>, sink;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLR(rn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; P &gt;&gt; S &gt;&gt; C &gt;&gt; m;</span><br><span class="line">    sink = P + S + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        rn[u][P + v] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build edges</span></span><br><span class="line">    FOR(i, <span class="number">1</span>, P + <span class="number">1</span>) rn[source][i] = <span class="number">1</span>;</span><br><span class="line">    FOR(i, <span class="number">1</span>, S + <span class="number">1</span>) rn[i + P][sink] = C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dinicBFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLR(l);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(source);</span><br><span class="line">    l[source] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = QPOP(q);</span><br><span class="line"></span><br><span class="line">        FOR(v, <span class="number">1</span>, sink + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l[v] || !rn[u][v]) <span class="keyword">continue</span>;</span><br><span class="line">            l[v] = l[u] + <span class="number">1</span>;</span><br><span class="line">            q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l[sink];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinicDFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> cp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == sink) <span class="keyword">return</span> cp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> tmp = cp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= sink &amp;&amp; tmp; ++v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l[v] != l[u] + <span class="number">1</span> || !rn[u][v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> bottleNeck = dinicDFS(v, min(rn[u][v], tmp));</span><br><span class="line">        rn[u][v] -= bottleNeck;</span><br><span class="line">        rn[v][u] += bottleNeck;</span><br><span class="line">        tmp -= bottleNeck;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cp - tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dinic</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxiumFlow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (dinicBFS()) mf += dinicDFS(source, INF);</span><br><span class="line">    <span class="keyword">return</span> mf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxiumFlow() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fwPNIx">UVa 12873 - The Programmers | Morris’ Blog</a><br><a href="https://ppt.cc/fXrOUx">Dinic算法详解及实现 - 0giant - 博客园</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Queue</tag>
        <tag>Maximum Flow</tag>
        <tag>Dinic</tag>
        <tag>Edmonds-Karp</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 165 解題紀錄</title>
    <url>/UVa-165/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=101">UVa - 165 - Stamps</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個整數 <code>h</code>、<code>k</code>，分別代表最多能貼 <code>h</code> 張郵票，及最多能使用 <code>k</code> 種面額的郵票，求最多能組出從 1 開始數到多少的價格。</p>
<span id="more"></span>

<p>如 <code>1 3 -&gt; 7</code>，表示使用面額 1 和 3 的郵票，可以組出 1 ~ 7 這 7 種價格。</p>
<p><strong>Input：</strong> 每行兩個整數，分別代表 <code>h</code>、<code>k</code>，若皆為 0 表示結束。</p>
<p><strong>Output：</strong> 輸出選取的 <code>k</code> 種面額，及最多能組出從 1 開始數到多少的價格。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>由於數據量較少，所以暴力法模擬即可。</p>
<p>先模擬出 <code>k</code> 個面額，<code>stamp</code> 儲存目前模擬的面額，<code>maxVal[i]</code> = d 表示 i + 1 張郵票能組出 1 ~ d 的價格，第一個面額一定是 1 也就是 <code>stamp[0]</code> = 1，而 <code>maxVal[0]</code> 一定是 <code>h</code>，由於我們的目標是組出 1 ~ 多少的價格，因此後面的金額範圍為 <code>stamp[i - 1] + 1</code> ~ <code>maxVal[i - 1] + 1</code>，依此想法做 DFS 模擬出 <code>k</code> 個面額，而 maxVal 也是使用 DFS 取得。</p>
<p>最後根據題目要求輸出答案即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fFRd4x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h, k;</span><br><span class="line"><span class="keyword">int</span> mx;</span><br><span class="line"><span class="keyword">int</span> stamp[<span class="number">10</span>] = &#123; <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> maxVal[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> check[<span class="number">180</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mx = <span class="number">0</span>;</span><br><span class="line">    maxVal[<span class="number">0</span>] = h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getVal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (check[++i]) ++cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> idx, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    check[sum] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == h) <span class="keyword">return</span>; <span class="comment">// 若已選了 h 張郵票</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= idx; ++i) dfs(n + <span class="number">1</span>, idx, sum + stamp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模擬最多 k 種面額的郵票組合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">int</span> idx = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idx == k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxVal[idx - <span class="number">1</span>] &gt; mx)</span><br><span class="line">        &#123;</span><br><span class="line">            mx = maxVal[idx - <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">memcpy</span>(ans, stamp, <span class="keyword">sizeof</span>(stamp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = stamp[idx - <span class="number">1</span>] + <span class="number">1</span>; i &lt;= maxVal[idx - <span class="number">1</span>] + <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        stamp[idx] = i;</span><br><span class="line">        <span class="built_in">memset</span>(check, <span class="number">0</span>, <span class="keyword">sizeof</span>(check));</span><br><span class="line">        dfs(<span class="number">0</span>, idx, <span class="number">0</span>);</span><br><span class="line">        maxVal[idx] = getVal();</span><br><span class="line">        execute(idx + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) <span class="built_in">cout</span> &lt;&lt; setw(<span class="number">3</span>) &lt;&lt; ans[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; -&gt;&quot;</span> &lt;&lt; setw(<span class="number">3</span>) &lt;&lt; mx &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; h &gt;&gt; k &amp;&amp; (h || k))</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        execute();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fFRd4x">uva 165 Stamps_@fei-CSDN博客</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>CPE - 2020/10/20</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 168 解題紀錄</title>
    <url>/UVa-168/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&category=0&problem=104">UVa - 168 - Theseus and the Minotaur</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>有一個迷宮，一個勇者跟一個怪物，怪物會怕光，所以勇者拿著蠟燭在追逐怪物，勇者每走一定的步數後會插上蠟燭，並繼續走，所以怪物一定會被逼到無路可走，求勇者有插上蠟燭的地方及最後怪物被抓到的地方。在每個地點怪物都會優先往字典序小的地方走。</p>
<span id="more"></span>

<p><strong>Input：</strong> 一組測資為一行字串，前面為每個地點能繼續往下走的地點 ( 單向 )，後面為兩個字元及一個數字，分別代表怪物一開始的位置及勇者一開始的位置及勇者每走幾步會插上蠟燭。勇者一開始一定會在怪物的附近一個點。</p>
<p><strong>Output：</strong> 勇者插上蠟燭的地方及怪物最後被抓到的地方。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>讀取資料後先建立圖，遍歷字串，若碰到 <code>&#39;:&#39;</code> 代表前面一個字元為某個地點，後面接的是某個地點能繼續往下走的地點，直到遇到 <code>&#39;;&#39;</code> 或 <code>&#39;.&#39;</code> 為止。定義 <code>candle</code> 紀錄插上蠟燭的位置，<code>steps</code> 為勇者走的步數，<code>M</code> 為怪物當前的位置，<code>T</code> 為勇者當前的位置，之後 DFS 求解即可，先判斷是否插上蠟燭，接著找怪物能繼續往下走的位置，若有可以走的地方則 <code>M</code> 更新為該位置，<code>T</code> 更新為原本 <code>M</code> 的位置，否則代表怪物無路可走。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE(c) int(c.size())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> diff(ch) (ch - <span class="meta-string">&#x27;A&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fMYpGx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str &amp;&amp; str != <span class="string">&quot;#&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">char</span> m, t;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; t &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 讀取資料並建立圖</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">auto</span> read = [&amp;](<span class="keyword">int</span> j) &#123; <span class="keyword">return</span> str[j] != <span class="string">&#x27;;&#x27;</span> &amp;&amp; str[j] != <span class="string">&#x27;.&#x27;</span>; &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE(str);)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (read(j)) G[diff(str[i - <span class="number">1</span>])].push_back(diff(str[j++]));</span><br><span class="line">                i = j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ++i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> candle[<span class="number">26</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> M, <span class="keyword">int</span> T)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 放蠟燭</span></span><br><span class="line">            <span class="keyword">if</span> (steps &amp;&amp; steps % k == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="keyword">char</span>(T + <span class="string">&#x27;A&#x27;</span>) &lt;&lt; <span class="string">&quot; &quot;</span>, candle[T] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span>&amp; v = G[M];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE(v); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果 v[i] 沒有蠟燭且 t 不在 v[i] 那 M 就可以往 V[i] 走</span></span><br><span class="line">                <span class="keyword">if</span> (v[i] != T &amp;&amp; !candle[v[i]])</span><br><span class="line">                &#123;</span><br><span class="line">                    ++steps;</span><br><span class="line">                    dfs(v[i], M);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 m 無路可走，代表會在 M 被抓到</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; <span class="keyword">char</span>(M + <span class="string">&#x27;A&#x27;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        dfs(m - <span class="string">&#x27;A&#x27;</span>, t - <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/00168.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fMYpGx">ACM Plan UVa - 168 Theseus and the Minotaur(图的遍历，深度优先)</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
        <tag>Recursive</tag>
        <tag>Graph</tag>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 1746 解題紀錄</title>
    <url>/UVa-1746/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=5013">UVa - 1746 - String Theory</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一些整數表示括號的個數，求最大的 k 值。</p>
<span id="more"></span>

<p>k-quotation 的定義為:</p>
<ul>
<li>若 k = 1，表示字串頭尾各有一個 <code>&#39;</code> 號，而中間沒有任何 <code>&#39;</code> 號。</li>
<li>若 k &gt;= 2，表示字串頭尾各有 k 個 <code>&#39;</code> 號，而中間是 k-1-quotation。</li>
</ul>
<p>如 <code>&#39;&#39;All &#39;work&#39; and no &#39;play&#39;&#39;&#39;</code>，最外層的 <code>&#39;</code> 號為 2 個，而中間的字串為 1 個，則 k = 2。</p>
<p>解釋的不是很好，可能看題目原文會比較好理解。</p>
<blockquote>
<p>For k &gt; 1, a k-quotation is a string that begins with k quote characters, ends with another k quote characters and contains a nested string in-between. The nested string is a non-empty sequence of (k − 1)-quotations, which may be preceded, separated, and/or succeeded by any number of non-quote characters. For example, ‘’All ‘work’ and no ‘play’’’ is a 2-quotation.</p>
</blockquote>
<p><a href="https://ppt.cc/fpIyrx">1746.pdf</a></p>
<p><strong>Input：</strong> 每組測資第一個整數 N，表示有 N 個整數，依序為 <code>a1, a2, ..., aN</code>，表示字串的開頭為 <code>a1</code> 個 <code>&#39;</code> 號，後面接著一些正整數個非 <code>&#39;</code> 號的字元，接著 <code>a2</code> 個 <code>&#39;</code> 號，後面接著一些正整數個非 <code>&#39;</code> 號的字元，…，直到最後為 <code>aN</code> 個 <code>&#39;</code> 號結尾。</p>
<p>需要注意的是，若 <code>N = 1</code>，表示 <code>a1</code> 就是 <code>aN</code>，應該是只有 <code>&#39;</code> 號的意思，或是前面可能有一些非 <code>&#39;</code> 號的字元，後面接 <code>&#39;</code> 號，不太確定，題目看不是很懂。</p>
<p><strong>Output：</strong> 求最大的 <code>k</code> 值為何，若找不到則輸出 <code>&quot;no quotation&quot;</code>，注意 <code>k &gt;= 1</code>。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>暴力法，找出可能的 <code>k</code> 值，並減去 <code>&#39;</code> 號的個數，模擬將 <code>&#39;</code> 號分組，當做到最後一層時，判斷剩下的 <code>&#39;</code> 號是否是偶數個，若為偶數個才可以一一配對，若不是則不符合。</p>
<p>需要注意的是:</p>
<ul>
<li><code>k</code> 的最大值為 <code>a1</code> 及 <code>aN</code> 兩者的較小者，因為字串頭尾都必須有 <code>k</code> 個 <code>&#39;</code> 號。</li>
<li>若 <code>k = 1</code>，則最後剩下的 <code>&#39;</code> 號個數需為 0。</li>
</ul>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fqz3Sx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> quotes[<span class="number">101</span>]; <span class="comment">// 題目給的測資</span></span><br><span class="line"><span class="keyword">int</span> dummy[<span class="number">101</span>];  <span class="comment">// 用來模擬的陣列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="built_in">cin</span> &gt;&gt; quotes[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模擬 k，暴力法檢查 k 是否可行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = min(quotes[<span class="number">0</span>], quotes[N - <span class="number">1</span>]); k &gt; <span class="number">0</span>; --k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(dummy, quotes, N * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = N - <span class="number">1</span>, tmp = k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt; N &amp;&amp; r &gt;= <span class="number">0</span> &amp;&amp; dummy[l] &gt;= tmp &amp;&amp; dummy[r] &gt;= tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((dummy[l] -= tmp) == <span class="number">0</span>) ++l;</span><br><span class="line">            <span class="keyword">if</span> ((dummy[r] -= tmp) == <span class="number">0</span>) --r;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (--tmp &gt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">auto</span> sum = accumulate(dummy, dummy + N, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; k != <span class="number">1</span> || sum == <span class="number">0</span> &amp;&amp; k == <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;no quotation\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N)</span><br><span class="line">    &#123;</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fpIyrx">1746.pdf</a><br><a href="https://ppt.cc/fqz3Sx">uva1746</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>CPE - 2020/10/20</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 200 解題紀錄</title>
    <url>/UVa-200/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=136">UVa - 200 - Rare Order</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一些依據某種字典序排序的字串，求該字典序為何。</p>
<span id="more"></span>

<p><strong>Input：</strong> 測資裡面有好幾行字串，以 <code>&quot;#&quot;</code> 為終止，字串的順序為升冪排序。</p>
<p><strong>Output：</strong> 輸出測資以什麼字典序排序。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>讀取測資，每次取兩個字串來比較，將比字元 A 大的字元推入 <code>G[0]</code> 表示 A 指向該字元，…，以此類推來建圖，同時使用一個陣列紀錄字元的狀態，因為 DFS 時需要以沒有大於其他字元的為起點，之後使用 DFS 做 Topological sort 即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, n) for(int i = 0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOOP(n) for(int I = 0; I &lt; n; ++I)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> diff(ch) (ch - <span class="meta-string">&#x27;A&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">reference:</span></span><br><span class="line"><span class="comment">https://ppt.cc/fAirPx</span></span><br><span class="line"><span class="comment">https://ppt.cc/flbLOx</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1, str2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mem[<span class="number">26</span>] = &#123;&#125;; <span class="comment">// 1 -&gt; 沒有小於其他字元，2 -&gt; 有小於其他字元</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[<span class="number">26</span>]; <span class="comment">// 比 A 大的字元都會被推入 G[0]，...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str2 &amp;&amp; str2 != <span class="string">&quot;#&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = min(str1.length(), str2.length());</span><br><span class="line">        FOR(i, l)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mem[diff(str1[i])]) mem[diff(str1[i])] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!mem[diff(str2[i])]) mem[diff(str2[i])] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (str1[i] != str2[i])</span><br><span class="line">            &#123;</span><br><span class="line">                G[diff(str1[i])].push_back(diff(str2[i]));</span><br><span class="line">                mem[diff(str2[i])] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        str1 = str2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> visited[<span class="number">26</span>] = &#123;&#125;; <span class="comment">// 1 -&gt; 正在被 DFS，2 -&gt; 已經 DFS 過了</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[n] == <span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">// 碰到環</span></span><br><span class="line">        visited[n] = <span class="number">1</span>; <span class="comment">// 正在被 DFS</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 visited[i] != 2 表示還沒被 DFS 過</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : G[n]) <span class="keyword">if</span> (visited[i] != <span class="number">2</span>) dfs(i);</span><br><span class="line">        visited[n] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        ret.push_front(n + <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 從沒有大於其他字元的字元開始 DFS</span></span><br><span class="line">    FOR(i, <span class="number">26</span>) <span class="keyword">if</span> (mem[i] == <span class="number">1</span>) dfs(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : ret) <span class="built_in">cout</span> &lt;&lt; ch;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/00200-1.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<p>由於依照題目測資建好的圖必為 DAG，所以可以不用判斷碰到環的情況，因此也可以這樣寫。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, n) for(int i = 0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOOP(n) for(int I = 0; I &lt; n; ++I)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> diff(ch) (ch - <span class="meta-string">&#x27;A&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">reference:</span></span><br><span class="line"><span class="comment">https://ppt.cc/fAirPx</span></span><br><span class="line"><span class="comment">https://ppt.cc/flbLOx</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1, str2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mem[<span class="number">26</span>] = &#123;&#125;; <span class="comment">// 1 -&gt; 沒有小於其他字元，2 -&gt; 有小於其他字元</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[<span class="number">26</span>]; <span class="comment">// 比 A 大的字元都會被推入 G[0]，...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str2 &amp;&amp; str2 != <span class="string">&quot;#&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = min(str1.length(), str2.length());</span><br><span class="line">        FOR(i, l)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mem[diff(str1[i])]) mem[diff(str1[i])] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!mem[diff(str2[i])]) mem[diff(str2[i])] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (str1[i] != str2[i])</span><br><span class="line">            &#123;</span><br><span class="line">                G[diff(str1[i])].push_back(diff(str2[i]));</span><br><span class="line">                mem[diff(str2[i])] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        str1 = str2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> visited[<span class="number">26</span>]&#123;&#125;;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[n]) <span class="keyword">return</span>;</span><br><span class="line">        visited[n] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : G[n]) dfs(i);</span><br><span class="line">        ret.push_front(n + <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 從沒有大於其他字元的字元開始 DFS</span></span><br><span class="line">    FOR(i, <span class="number">26</span>) <span class="keyword">if</span> (mem[i] == <span class="number">1</span>) dfs(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : ret) <span class="built_in">cout</span> &lt;&lt; ch;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/00200-2.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fAirPx">[UVa] 200 Rare Order.cpp</a><br><a href="https://ppt.cc/flbLOx">UVA 200 /RARE ORDER</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
        <tag>Recursive</tag>
        <tag>Topological Sort</tag>
        <tag>Graph</tag>
        <tag>Vector</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 247 解題紀錄</title>
    <url>/UVa-247/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=183">UVa - 247 - Calling Circles</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>有一家電信公司記錄了所有人之間打電話的紀錄，他們想找出所有的通話圈圈 ( Calling Circles )<br>舉例來說，如果 A 打給 B，B 打給 C，C 又打給 A，A、B、C之間就可以跟任何一個人互相溝通，他們就形成一個 Calling Circle。但假如 D 可以打給 A，但 A 不能打給 D，D 跟 A 就不算 Calling Circle。</p>
<span id="more"></span>

<p><strong>Input：</strong> 每筆測資先給你總共的人數 <code>n</code>，和通話紀錄 <code>m</code> 筆，接下來 <code>m</code> 行會有兩個人名 ( 25字元以內 )，代表前面的人可以打給後面的人 ( 單向 )。</p>
<p><strong>Output：</strong> 每筆測資先輸出一行 “Calling circles for data set x:” ( x 代表第幾筆 )，接下來每行輸出一個 Calling Circle 中的所有人名，之間以逗號和空白隔開，順序都可以。</p>
<p>引用自：<a href="https://ppt.cc/fc2nLx">愚人隨筆: UVA 247 - Calling Circles</a></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>題目的 Calling Circles 其實就是 SCC ( Strongly Connected Component )，SCC 即在有向圖上任意選兩點 <code>u</code>、<code>v</code>，<code>u</code> 能夠走到 <code>v</code> 且 <code>v</code> 也能夠走到 <code>u</code>。所以我們只需要讀取測資並建圖，之後 DFS 找 SCC 並直接輸出即可。比較特別的是因為名字是字串，所以使用 Map 建圖。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">reference:</span></span><br><span class="line"><span class="comment">想法: https://ppt.cc/fc2nLx</span></span><br><span class="line"><span class="comment">Code: https://ppt.cc/fOJQux</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, Case = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> TIME;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; dfn;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; low;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; inStack; <span class="comment">// 紀錄目前存在 Stack 中的點</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; G;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出 strong connected component</span></span><br><span class="line">    function&lt;<span class="keyword">void</span>(<span class="built_in">string</span>)&gt; dfs = [&amp;](<span class="built_in">string</span> u)</span><br><span class="line">    &#123;</span><br><span class="line">        dfn[u] = low[u] = ++TIME;</span><br><span class="line">        s.push(u);</span><br><span class="line">        inStack.insert(u);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : G[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfn[v])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (inStack.count(v)) low[u] = min(dfn[v], low[u]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dfs(v);</span><br><span class="line">            low[u] = min(low[v], low[u]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dfn[u] == low[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                inStack.erase(tmp);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; tmp;</span><br><span class="line">                <span class="keyword">if</span> (tmp != u) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; !(!n &amp;&amp; !m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        TIME = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty()) s.pop();</span><br><span class="line">        dfn.clear();</span><br><span class="line">        low.clear();</span><br><span class="line">        G.clear();</span><br><span class="line">        inStack.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> u, v;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            G[u].push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Case) <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Calling circles for data set &quot;</span> &lt;&lt; ++Case &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [u, __] : G) <span class="keyword">if</span> (!dfn[u]) dfs(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/00247.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fc2nLx">愚人隨筆: UVA 247 - Calling Circles</a><br><a href="https://ppt.cc/fOJQux">Programming學習筆記: UVa 247 Calling Circles</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
        <tag>Stack</tag>
        <tag>Map</tag>
        <tag>Recursive</tag>
        <tag>Graph</tag>
        <tag>Vector</tag>
        <tag>Unordered_set</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 315 解題紀錄</title>
    <url>/UVa-315/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=0&problem=251">UVa - 315 - Network</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個所有點都有接通的無向圖，找出 Articulation Points ( 也叫 Cut Vertex、割點 ) 的數量。</p>
<span id="more"></span>

<p>Articulation Points 的定義：</p>
<blockquote>
<ol>
<li>對於根節點 <code>root</code>，若其有兩棵或兩棵以上的子樹 ( degree &gt;= 2 )，則該根節點 <code>root</code> 為割點。</li>
<li>對於非葉子節點 <code>u</code> ( 非根節點 )，若其 child 存在一個節點 <code>v</code> 或 <code>v</code> 的 descendant 沒有指向 <code>u</code> 的 proper ancestor ( 不包含 <code>u</code> ) 的 Back edge，則節點 <code>u</code> 為割點。</li>
</ol>
</blockquote>
<p><strong>Input：</strong> 每組測資的第一行為一整數 N，表示有 N 個節點，若 N 為 0 代表結束，接下來最多 N 行為以空格隔開的數字，若為 0 則代表這筆測資結束，否則代表邊。如 <code>5 1 2 3 4</code> 表示有 <code>( 5, 1 )</code>、<code>( 5, 2 )</code>、<code>( 5, 3 )</code>、<code>( 5, 4 )</code> 這些邊。</p>
<p><strong>Output：</strong> 輸出 Articulation Points 的數量。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先讀取測資並建圖 ( 因為是無向圖，所以建雙向 )，之後 DFS，紀錄 DFS 時的序號及 low 值 ( 記錄節點 <code>u</code> 或 <code>u</code> 的子樹通過非父子邊追溯到最早的祖先節點 ( 即 DFS 的序號最小 ) )，之後根據割點的定義判斷並記錄數量即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* reference:</span></span><br><span class="line"><span class="comment">https://ppt.cc/fuwZGx</span></span><br><span class="line"><span class="comment">https://ppt.cc/fUny8x</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N; <span class="comment">// 點的數量</span></span><br><span class="line">    <span class="keyword">int</span> time; <span class="comment">// dfs 的順序</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; G;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dfsD;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; low;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parent 為 0 表示 n 為 root</span></span><br><span class="line">    function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> n, <span class="keyword">int</span> parent)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        dfsD[n] = low[n] = ++time;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : G[n])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果不為 0 表示遍歷過了</span></span><br><span class="line">            <span class="keyword">if</span> (dfsD[i])</span><br><span class="line">            &#123;   <span class="comment">// 若 i 不為 n 的 parent 才能更新 low 值</span></span><br><span class="line">                <span class="keyword">if</span> (parent != i) low[n] = min(dfsD[i], low[n]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ++child;</span><br><span class="line">            dfs(i, n);</span><br><span class="line">            low[n] = min(low[i], low[n]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (low[i] &gt;= dfsD[n]) flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 n 為根節點，則 child &gt;= 2 就是割點</span></span><br><span class="line">        <span class="comment">// 否則只要 n 存在一個的 child，i 或 i 的 descendant 沒有 backedge ( 即 low[i] &gt;= dfsD[n] ) 則 n 為割點</span></span><br><span class="line">        <span class="keyword">if</span> (flag &amp;&amp; (child &gt;= <span class="number">2</span> || parent)) ++ret;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N &amp;&amp; N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>.ignore();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        G.assign(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        dfsD.assign(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        low.assign(N + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        time = <span class="number">0</span>;</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 題目說最多 N 行，本來用 for 0 ~ N - 1 不知道為什麼會 WA，換成 0 ~ N 又會對，所以直接換成這樣</span></span><br><span class="line">        <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, str) &amp;&amp; str != <span class="string">&quot;0&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ss.clear();</span><br><span class="line">            ss.str(str);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> a, b;</span><br><span class="line">            ss &gt;&gt; a;</span><br><span class="line">            <span class="keyword">while</span> (ss &gt;&gt; b)</span><br><span class="line">            &#123;   <span class="comment">// 因為是無向圖，所以雙向都要建邊</span></span><br><span class="line">                G[a].push_back(b);</span><br><span class="line">                G[b].push_back(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/00315.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fuwZGx">UVa 315 &amp; POJ 1144 Network</a><br><a href="https://ppt.cc/fUny8x">圖論（二）：圖的割點(cut vertex)與連通度(connectivity)</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
        <tag>Recursive</tag>
        <tag>Graph</tag>
        <tag>Vector</tag>
        <tag>Tarjan</tag>
        <tag>Stringstream</tag>
        <tag>Articulation Points</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 357 解題紀錄</title>
    <url>/UVa-357/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=293">UVa - 357 - Let Me Count The Ways</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>有面額 [1, 5, 10, 25, 50] 的錢幣，給一個 <code>n</code>，求 <code>n</code> 有幾種不同的組合方式。</p>
<p><strong>Input：</strong> 每行為一組測資，一個整數表示 <code>n</code>。</p>
<p><strong>Output：</strong> 輸出 <code>n</code> 有幾種不同的組合方式。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>DP 的 Coin Change 問題，核心概念為枚舉每一個最後加入的面額。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> money[] = &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>, <span class="number">50</span> &#125;;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">30001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CoinChange</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; m : money) <span class="keyword">for</span> (<span class="keyword">auto</span> i = m; i &lt;= <span class="number">30000</span>; ++i)</span><br><span class="line">        dp[i] += dp[i - m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[n] == <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;There is only 1 way &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;There are &quot;</span> &lt;&lt; dp[n] &lt;&lt; <span class="string">&quot; ways &quot;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;to produce &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; cents change.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CoinChange();</span><br><span class="line">    solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>UVa</tag>
        <tag>Coin Change</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 389 解題紀錄</title>
    <url>/UVa-389/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=325">UVa - 389 - Basically Speaking</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個字串表示數值，及 <code>n</code>、<code>m</code>，表示該值是 <code>n</code> 進位，要求轉換為 <code>m</code> 進位。</p>
<span id="more"></span>

<p>除此之外，有三個要求:</p>
<ul>
<li>轉換後不可超過 7 位數，若超過則輸出 <code>&quot;ERROR&quot;</code>。</li>
<li>字串只會出現 A ~ F 及 0 ~ 9。</li>
<li>n、m 的範圍為 2 ~ 16。</li>
</ul>
<p>且輸出時需靠右對齊。</p>
<p><strong>Input：</strong> 每行有三個變數，分別為該字串、<code>n</code>、<code>m</code></p>
<p><strong>Output：</strong> 輸出轉換後的數值。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>根據題目要求做轉換，先轉換為十進位再轉換成題目要求的進位數，需要注意的是要靠右對齊，所以不足 7 位的要補上空白。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> orgin;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> Dec;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt; ret;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(orgin)</span></span>;</span><br><span class="line">    ss &gt;&gt; orgin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvtToDec</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : orgin)</span><br><span class="line">        Dec = Dec * n + (<span class="built_in">isalpha</span>(ch) ? ch - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span> : ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cvtToAns</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ret.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (Dec)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = Dec % m;</span><br><span class="line">        ret.push_front(tmp &lt; <span class="number">10</span> ? tmp + <span class="string">&#x27;0&#x27;</span> : tmp - <span class="number">10</span> + <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        Dec /= m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret.empty()) ret.push_back(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ret.size() &gt; <span class="number">7</span>) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  ERROR\n&quot;</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ret.size() &lt; <span class="number">7</span>) ret.push_front(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : ret) <span class="built_in">cout</span> &lt;&lt; ch;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, orgin))</span><br><span class="line">    &#123;</span><br><span class="line">        split();</span><br><span class="line">        cvtToDec();</span><br><span class="line">        cvtToAns();</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
        <tag>CPE - 2020/10/20</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 429 解題紀錄</title>
    <url>/UVa-429/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&category=0&problem=370">UVa - 429 - Word Transformation</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一些在字典裡面的字串，在這些字串中，若兩個字串只相差了一個字元，就可以進行轉換，給原本的字串跟目標字串，求轉換幾次後能得到目標字串。</p>
<span id="more"></span>

<p><strong>Input：</strong> 第一行為一整數 <code>T</code>，代表有 <code>T</code> 組測資，後面接一個空行，之後每行會有一個字串，代表字典裡面的字，直到讀到 <code>&quot;*&quot;</code> 為止，之後每行會有兩個字串，分別代表原本的字串跟目標字串，直到讀到空行為止。空行後就是下一組測資。</p>
<p><strong>Output：</strong> 輸出原本的字串及目標字串，及轉換的次數 ( 題目應該是保證會有答案 )。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>可以透過建圖，將題目的問題轉換成最短路徑的問題，先讀取測資，並將字串兩兩判斷，若兩字串只相差一個字元就建邊 ( <strong>注意這裡要建雙向，因為兩者可相互轉換</strong> )，之後讀取原本的字串跟目標字串，從原本的字串開始 BFS 求解即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE(c) int(c.size())</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fJFcMx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> orgin;</span><br><span class="line"><span class="built_in">string</span> target;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; G;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">    q.push(orgin);</span><br><span class="line">    visited.insert(orgin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (size--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (u == target) <span class="keyword">return</span> dis;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : G[u]) <span class="keyword">if</span> (!visited.count(v)) q.push(v), visited.insert(v);</span><br><span class="line">        &#125;</span><br><span class="line">        ++dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="built_in">cin</span>.ignore();</span><br><span class="line">    getline(<span class="built_in">cin</span>, str); <span class="comment">// avoid blank</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        G.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 讀取字典並儲存</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> tmp[<span class="number">200</span>];</span><br><span class="line">        <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, str) &amp;&amp; str != <span class="string">&quot;*&quot;</span>) tmp[cnt++] = str;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次找兩個字串比對，若只相差一個字元則建邊</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; cnt; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 若兩字串不等長就不做</span></span><br><span class="line">            <span class="keyword">if</span> (SIZE(tmp[i]) != SIZE(tmp[j])) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> dif = <span class="number">0</span>; <span class="comment">// 兩字串相差的字元數</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; SIZE(tmp[i]); ++k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmp[i][k] != tmp[j][k]) ++dif;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因為可互相轉換，所以建雙向</span></span><br><span class="line">            <span class="keyword">if</span> (dif == <span class="number">1</span>) G[tmp[i]].push_back(tmp[j]), G[tmp[j]].push_back(tmp[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, str) &amp;&amp; !str.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            visited.clear();</span><br><span class="line">            <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">            ss &gt;&gt; orgin &gt;&gt; target;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; orgin &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; target &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; bfs() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (T) <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/00429.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fJFcMx">UVa 429 /Word Transformation</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
        <tag>Unordered_map</tag>
        <tag>Queue</tag>
        <tag>Graph</tag>
        <tag>Vector</tag>
        <tag>Unordered_set</tag>
        <tag>BFS</tag>
        <tag>Stringstream</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 458 解題紀錄</title>
    <url>/UVa-458/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=399">UVa - 458 - The Decoder</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個加密後的字串，找出加密的規則並且輸出解密後的字串。</p>
<span id="more"></span>

<p><strong>Input：</strong> 每行都是一個加密的字串。</p>
<p><strong>Output：</strong> 輸出解密後的字串。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先觀察 Sample I/O，找一些相同的字比對，可以發現加密方法應該是加上某個偏移量而成。找任意一組字串相減可以知道偏移量為 7，最後對每個字元做偏移即可得到解密後的字串。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, str))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : str) ch -= <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
        <tag>CPE - 2020/10/20</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 481 解題紀錄</title>
    <url>/UVa-481/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=422">UVa - 481 - What Goes Up</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>依序給一些數字，找出這些數字的最長嚴格遞增子序列 ( Longest Increasing Subsequence ) 長度及最長嚴格遞增子序列。若有相同長度的 LIS 的話，以選擇後面的元素的 LIS 優先。</p>
<p><strong>Input：</strong> 只有一組測資，每行一個整數直到 EOF。</p>
<p><strong>Output：</strong> 輸出最長嚴格遞增子序列長度及最長嚴格遞增子序列。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>基本的 LIS 題目，直接讀取數字同時處理，與先讀取後遍歷陣列的意思相同。</p>
<p>每次讀取 <code>nums[i]</code> 後，先在 <code>seq[]</code> 中找到一個最接近且大於等於 <code>nums[i]</code> 的數，並取得其位置 <code>pos</code>，意義為以 <code>nums[i]</code> 做結尾的 LIS 的最大長度為 <code>pos + 1</code>，<code>L</code> 表示目前能夠找到的最大 LIS 長度，因此若 <code>pos == L</code>，表示以 <code>nums[i]</code> 做結尾的 LIS 是目前能夠找到的 LIS 最大長度，因此更新 <code>lastIdx</code>，由於題目要求，若 <code>pos == L - 1</code> 即以 <code>nums[i]</code> 結尾的 LIS 與目前能找到的最長 LIS 的長度相同，因此也要更新 <code>lastIdx</code>。同時維護 <code>id[]</code> 及 <code>pre[]</code> 最後才能輸出 LIS。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fDPncx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = (<span class="keyword">int</span>)<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> L;</span><br><span class="line"><span class="keyword">int</span> lastIdx; <span class="comment">// 最長的 LIS 中的最後一個元素的 index</span></span><br><span class="line"><span class="keyword">int</span> nums[N];</span><br><span class="line"><span class="keyword">int</span> seq[N];</span><br><span class="line"><span class="keyword">int</span> id[N];   <span class="comment">// seq[] 中相應位置元素的 index，即若 seq[0] = nums[5]，id[0] = 5</span></span><br><span class="line"><span class="keyword">int</span> pre[N];  <span class="comment">// pre[i] 表包含 nums[i] 的 LIS，位於 nums[i] 的前一個元素在 nums[] 中的 index</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LIS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; <span class="built_in">cin</span> &gt;&gt; nums[i]; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = lower_bound(seq, seq + L, nums[i]) - seq;</span><br><span class="line">        seq[pos] = nums[i];</span><br><span class="line">        id[pos] = i;</span><br><span class="line">        pre[i] = pos &gt; <span class="number">0</span> ? id[pos - <span class="number">1</span>] : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos == L - <span class="number">1</span>) lastIdx = i;</span><br><span class="line">        <span class="keyword">if</span> (pos == L) ++L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    Print(pre[idx]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; nums[idx] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; L &lt;&lt; <span class="string">&quot;\n-\n&quot;</span>;</span><br><span class="line">    Print(lastIdx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LIS();</span><br><span class="line">    solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fDPncx">UVA 481: What goes up - Algorithm challenge</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>UVa</tag>
        <tag>LIS</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 514 解題紀錄</title>
    <url>/UVa-514/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=0&problem=455">UVa - 514 - Rails</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個整數 <code>n</code>，代表有 <code>1, 2, ..., n</code> 個火車，每個火車入站可以直接出站或是等後面的火車入站並出站後再出站，簡單來講就是像 Stack 一樣。給一串數字代表火車出站的順序，若可以達成則輸出 <code>&quot;Yes&quot;</code> 否則輸出 <code>&quot;No&quot;</code>。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 Stack 模擬火車入站出站，使用 Queue 儲存出站順序，若是 Stack 的 <code>top()</code> 與 Queue 的 <code>front()</code> 相同則兩者都不斷 <code>pop()</code>，直到兩者不相同或是 Stack 為空，結束後若 Stack 為空則表示這個順序是可行的。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, tmp;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; T &amp;&amp; T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; tmp &amp;&amp; tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">            <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">            q.push(tmp);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; T; ++i) <span class="built_in">cin</span> &gt;&gt; tmp, q.push(tmp);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(i);</span><br><span class="line">                <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() == q.front()) s.pop(), q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; (s.empty() ? <span class="string">&quot;Yes\n&quot;</span> : <span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/00514.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Stack</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 558 解題紀錄</title>
    <url>/UVa-558/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=499">UVa - 558 - Wormholes</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一張有權重的向圖，求圖上是否有負環。</p>
<span id="more"></span>

<p><strong>Input：</strong> 第一行為一整數，表示有幾組測資，每組測資第一行為兩個整數 <code>n</code>、<code>m</code>，表示有 <code>n</code> 個點及 <code>m</code> 條邊，後面 <code>m</code> 行，每行有三個整數 <code>u</code>、<code>v</code>、<code>w</code>，表示有 <code>u -&gt; v</code> 的邊且權重為 <code>w</code>。</p>
<p><strong>Output：</strong> 若圖上有負環則輸出 <code>&quot;possible&quot;</code>，否則輸出 <code>&quot;not possible&quot;</code>。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p><strong>這個解法需要有 Bellman Ford 演算法的概念。</strong></p>
<p>先讀取測資並建圖，之後先執行 Bellman Ford，之後再遍歷所有邊，若任意點還能再更短則表示有負環。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// data</span></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; edges;</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edges.clear();</span><br><span class="line">    fill(dist, dist + n, INT_MAX);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有負環則回傳 true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bellman</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 從 0 開始</span></span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若不存在負環，則做 n - 1 次後 dist 會儲存 0 到每個點的最短路徑</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [u, v, w] : edges)</span><br><span class="line">        <span class="keyword">if</span> (dist[u] != INT_MAX) dist[v] = min(dist[u] + w, dist[v]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若任意點還能再更短則表示有負環</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [u, v, w] : edges) <span class="keyword">if</span> (dist[v] &gt; dist[u] + w) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        init(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建圖</span></span><br><span class="line">        <span class="keyword">while</span> (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u, v, w;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            edges.push_back(&#123; u, v, w &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bellman(n)) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;possible\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not possible\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/00558.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Graph</tag>
        <tag>Vector</tag>
        <tag>Bellman Ford</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 615 解題紀錄</title>
    <url>/UVa-615/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=556">UVa - 615 - Is It A Tree?</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個有向圖，求該圖是否是一個 Tree。</p>
<span id="more"></span>

<p>根據題目的敘述，Tree 需要滿足以下三個條件:</p>
<ul>
<li>只有一個沒有被其他節點接入的節點，稱為 root</li>
<li>除了 root 以外的所有節點，都只會被一個邊接入</li>
<li>從根到任一節點，都只有一條唯一的路徑</li>
</ul>
<p><strong>Input：</strong> 每組測資包含許多組邊，每組邊以兩個整數表示，<code>u</code>、<code>v</code> 表示有一條 <code>u</code> 指向 <code>v</code> 的邊，若為 0 0 表示此組測資結束，若一組測資以 -1 -1 開始表示程式結束。</p>
<p><strong>Output：</strong> 輸出該組測資是否是一個 Tree。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>建圖，先判斷是否沒有任何節點，若沒有任何節點也是 Tree，否則隨便挑一個沒有被接入的節點開始 DFS 判斷是否有環，最後判斷是否所有節點都有被遍歷到即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; G;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; inDegree;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    G.clear();</span><br><span class="line">    inDegree.clear();</span><br><span class="line">    visited.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!(!u &amp;&amp; !v))</span><br><span class="line">    &#123;</span><br><span class="line">        G[u].push_back(v);</span><br><span class="line">        inDegree[u] += <span class="number">0</span>;</span><br><span class="line">        ++inDegree[v];</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有環則回傳 false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    visited.insert(u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : G[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.count(v)) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 有環</span></span><br><span class="line">        <span class="keyword">if</span> (!dfs(v)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 沒有節點也是樹</span></span><br><span class="line">    <span class="keyword">if</span> (inDegree.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [u, deg] : inDegree)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (deg) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!dfs(u)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 檢查是否有節點還沒有遍歷過</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [u, _] : inDegree)</span><br><span class="line">        <span class="keyword">if</span> (!visited.count(u)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Case = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &amp;&amp; !(u == <span class="number">-1</span> &amp;&amp; v == <span class="number">-1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        readGraph();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; ++Case &lt;&lt; <span class="string">&quot; is &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (solve()) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a tree.\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;not a tree.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/f7mmqx">c131. 00615 - Is It A Tree? - 高中生程式解題系統</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>CPE - 2020/10/20</tag>
        <tag>Unordered_map</tag>
        <tag>Graph</tag>
        <tag>Unordered_set</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 673 解題紀錄</title>
    <url>/UVa-673/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=614">UVa - 673 - Parentheses Balance</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個只包含括弧的字串 (<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、<code>&#39;[&#39;</code>、<code>&#39;]&#39;</code>)，成對的相鄰括弧可以相互消除，如：</p>
<span id="more"></span>

<p>“([<code>()</code><a href=""></a>])()” -&gt; “([<code>[]</code>()])()” -&gt; “([<code>()</code>])()” -&gt; “(<code>[]</code>)()” -&gt; “<code>()</code>()” -&gt; “<code>()</code>“ -&gt; “”</p>
<p>若消除後的字串為空或原本就為空字串則輸出 <code>&quot;Yes&quot;</code>，否則輸出 <code>&quot;No&quot;</code>。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>基本的 Stack 觀念，使用 Stack 模擬操作即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : str) <span class="keyword">switch</span> (ch)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> (s.empty() || s.top() != <span class="string">&#x27;(&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> (s.empty() || s.top() != <span class="string">&#x27;[&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        s.push(ch);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.empty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="built_in">cin</span>.ignore();</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        getline(<span class="built_in">cin</span>, str);</span><br><span class="line">        <span class="keyword">if</span> (solve()) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/00673.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 681 解題紀錄</title>
    <url>/UVa-681/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=622">UVa - 681 - Convex Hull Finding</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一些在二維平面的座標點，求包住所有座標點的最小多邊形的頂點座標。</p>
<p><strong>Input：</strong> 第一個整數 <code>T</code>，表示有 <code>T</code> 組測資，每組測資第一個整數 <code>N</code>，表示有 <code>N</code> 個點，後面 <code>N</code> 行，每行有兩個整數，表示座標點。<strong>每組測資中間以 -1 隔開。</strong></p>
<p><strong>Output：</strong> 先輸出 <code>T</code>，之後每組測資先輸出最小多邊形的頂點個數，之後逆時針輸出那些點的座標，起點在最後必須再輸出一次。<strong>每組測資中間以 -1 隔開。</strong></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p><strong>此解法需要有 Convex Hull 及 Graham Scan 演算法的概念</strong></p>
<p>簡單的凸包題，使用 Graham Scan 演算法找出所有頂點即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt; b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(c) memset(c, 0, sizeof(c))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fDYULx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MXN = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">double</span> d; <span class="comment">// 與第一個點的距離</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point P[MXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> top; <span class="comment">// 凸包頂點數</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 兩點間的距離</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">const</span> Point&amp; l, <span class="keyword">const</span> Point&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(l.x - r.x, <span class="number">2</span>) + <span class="built_in">pow</span>(l.y - r.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">crossProduct</span><span class="params">(<span class="keyword">const</span> Point&amp; o, <span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.x - o.x) * (b.y - o.y) - (b.x - o.x) * (a.y - o.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 選出最下面的點，若有相同 y 的點則選擇 x 較小的那個</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">const</span> Point&amp; l, <span class="keyword">const</span> Point&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l.y == r.y ? l.x &lt; r.x : l.y &lt; r.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 極角排序，cp &gt; 0: ol -&gt; or 逆時針</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">const</span> Point&amp; l, <span class="keyword">const</span> Point&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cp = crossProduct(P[<span class="number">0</span>], l, r);</span><br><span class="line">    <span class="keyword">return</span> cp == <span class="number">0</span> ? l.d &lt; r.d : cp &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    FOR(i, <span class="number">0</span>, N) <span class="built_in">cin</span> &gt;&gt; P[i].x &gt;&gt; P[i].y;</span><br><span class="line">    <span class="keyword">if</span> (T) <span class="built_in">cin</span> &gt;&gt; tmp; <span class="comment">// read -1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convex Hull</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GrahamScan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找出第一個點，並將其他點依照極角排序</span></span><br><span class="line">    sort(P, P + N, cmp1);</span><br><span class="line">    FOR(i, <span class="number">1</span>, N) P[i].d = dist(P[<span class="number">0</span>], P[i]);</span><br><span class="line">    sort(P + <span class="number">1</span>, P + N, cmp2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找凸包</span></span><br><span class="line">    top = <span class="number">1</span>;</span><br><span class="line">    P[N++] = P[<span class="number">0</span>];</span><br><span class="line">    FOR(i, <span class="number">2</span>, N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">0</span> &amp;&amp; crossProduct(P[top - <span class="number">1</span>], P[top], P[i]) &lt;= <span class="number">0</span>) --top;</span><br><span class="line">        P[++top] = P[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top &lt; <span class="number">2</span>) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;0\n&quot;</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; top + <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    FOR(i, <span class="number">0</span>, top + <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; P[i].x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; P[i].y &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (T) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; T &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        read();</span><br><span class="line">        GrahamScan();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fDYULx">UVa 681 - Convex Hull Finding_小白菜又菜-CSDN博客</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Convex Hull</tag>
        <tag>Graham Scan</tag>
        <tag>Computational Geometry</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 732 解題紀錄</title>
    <url>/UVa-732/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&category=0&problem=673">UVa - 732 - Anagrams by Stack</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個字串，<code>str</code>、<code>target</code>，求 <code>str</code> 透過 Stack 的 <code>push()</code> 及 <code>pop()</code> 後能否轉換成 <code>target</code>，若可以則輸出所有能達成的操作順序。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 DFS 即可，對於每層 DFS，可以 <code>push()</code> 進 Stack 也可以 <code>pop()</code> 出 Stack，先直接 <code>push()</code> 並往下執行，接著判斷，若 Stack 的 <code>top()</code> 等於當前檢查到的字元則 <code>pop()</code> 並往下執行。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str, target;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="built_in">string</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> i1, <span class="keyword">int</span> i2, <span class="built_in">string</span> ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i2 == target.length()) &#123; <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i1 &lt; str.length())</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(str[i1]);</span><br><span class="line">            dfs(i1 + <span class="number">1</span>, i2, ret + (ret.empty() ? <span class="string">&quot;i&quot;</span> : <span class="string">&quot; i&quot;</span>));</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!s.empty() &amp;&amp; s.top() == target[i2])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            dfs(i1, i2 + <span class="number">1</span>, ret + (ret.empty() ? <span class="string">&quot;o&quot;</span> : <span class="string">&quot; o&quot;</span>));</span><br><span class="line">            s.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str &gt;&gt; target)</span><br><span class="line">    &#123;</span><br><span class="line">        s = <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt;();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;[\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (str.length() == target.length() &amp;&amp; !str.empty()) dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/00732.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Stack</tag>
        <tag>Recursive</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 796 解題紀錄</title>
    <url>/UVa-796/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=737">UVa - 796 - Critical Links</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個無向圖，求 Bridge 的數量 及 Bridge。</p>
<span id="more"></span>

<p>Bridge 的定義：</p>
<blockquote>
<ol>
<li>對於一個連通的無向圖來說，若拿掉某一邊會導致原本連通的圖變得不連通，則該邊為 Bridge。</li>
<li>對於任意邊 <code>(u, v)</code>，若 <code>v</code> 及 <code>v</code> 的 descendant 不存在一條連接到 <code>u</code> 的 ancestor 的 Back edge，則 <code>(u, v)</code> 為 Bridge。</li>
</ol>
</blockquote>
<p><strong>Input：</strong> 每組測資的第一行為一整數 <code>N</code>，表示圖有幾個點 <code>(0 ~ N - 1)</code>，接下來 <code>N</code> 行為每個點的連接情況，第一個數字為該點，後面接一個用左右括號括起來的數字 <code>n</code>，表示連接到 <code>n</code> 個點，後面 <code>n</code> 個數字為連接到的點，中間都以空格隔開。</p>
<p><strong>Output：</strong> 輸出 Bridge 的數量及 Bridge。Bridge 要求輸出時是小的點連接到大的點 ( 如 <code>(1, 5)</code> 需輸出為 <code>&quot;1 - 5&quot;</code>，不可輸出為 <code>&quot;5 - 1&quot;</code> )，並且先依照前面的數字小到大排序，若前面一樣則依照後面的數字小到大排序 ( 即為 pair 的比較方法 )。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先讀取測資並建圖，之後 DFS，紀錄 DFS 時的序號及 low 值 ( 記錄節點 <code>u</code> 或 <code>u</code> 的子樹通過非父子邊追溯到最早的祖先節點 ( 即 DFS 的序號最小 ) )，之後根據 Bridge 的定義判斷並記錄即可。</p>
<p><strong>註：</strong> 測資提供的是所有點的**<code>所有連接情況</code>**，如 1 和 5 相連，則在 1 的時候會出現 5 代表 1 連到 5，在 5 的時候也會出現 1 代表 5 連到 1。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fzjSzx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; G;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dfsD;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; low;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, greater&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; pq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parent 為 -1 代表沒有 parent</span></span><br><span class="line">    function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> n, <span class="keyword">int</span> parent)</span><br><span class="line">    &#123;</span><br><span class="line">        dfsD[n] = low[n] = ++time;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : G[n])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfsD[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != i) low[n] = min(dfsD[i], low[n]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dfs(i, n);</span><br><span class="line">            low[n] = min(low[i], low[n]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 low[i] 大於 dfsD[n] 表示 i 及 i 的 descendant 沒有 backedge</span></span><br><span class="line">            <span class="comment">// 連接到 n 的 ancestor ( 包含 n )，則 ( u, v ) 為 bridge</span></span><br><span class="line">            <span class="comment">// 由於題目要求較小的放在前面，所以這樣存入</span></span><br><span class="line">            <span class="keyword">if</span> (low[i] &gt; dfsD[n]) pq.push(&#123; min(n, i), max(n, i) &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        time = <span class="number">0</span>;</span><br><span class="line">        G.assign(N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        dfsD.assign(N, <span class="number">0</span>);</span><br><span class="line">        low.assign(N, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// pq 每次結束後都會清空</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, n;</span><br><span class="line">            <span class="keyword">char</span> ch;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; ch &gt;&gt; n &gt;&gt; ch;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 雖然是無向圖，但是測資給的是點的所有連接情況，如果這邊建雙向的話會造成重複</span></span><br><span class="line">            <span class="comment">// 如 (1, 5) 及 (5, 1) 所以這裡建單向即可，這樣建出來的圖最後即是雙向的</span></span><br><span class="line">            <span class="keyword">while</span> (n--) <span class="built_in">cin</span> &gt;&gt; b, G[a].push_back(b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="keyword">if</span> (!dfsD[i]) dfs(i, <span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pq.size() &lt;&lt; <span class="string">&quot; critical links&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pq.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; pq.top().first &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; pq.top().second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/00796.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fzjSzx">UVa 796 - Critical Links | NaiveRed’s Blog</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Recursive</tag>
        <tag>Graph</tag>
        <tag>Vector</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 820 解題紀錄</title>
    <url>/UVa-820/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=761">UVa - 820 - Internet Bandwidth</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><blockquote>
<p>求 S 到 T 的最大流量為多少。網路是雙向連接的，但共用頻寬，例如 A B 10，則 A 到 B 的流量 + B 到 A 的流量要小於等於 10。另外這題給測資的方式會有可能給你很多組 A B Xi，所以 A 到 B 的頻寬要把 Xi 全部加起來，例如底下例子 1 ~ 2 的頻寬為 30。<br>2<br>1 2 2<br>1 2 10<br>1 2 20</p>
</blockquote>
<p><a href="https://ppt.cc/f182Jx">Programming學習筆記: UVa 820 Network Bandwidth</a></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>最大流基本題，可使用 Edmonds-Karp 求解，也可使用 Dinic。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><p>Edmonds-Karp:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt; b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(c) memset(c, 0, sizeof(c))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">QPOP</span><span class="params">(<span class="built_in">queue</span>&lt;T&gt;&amp; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fv1Gvx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MXN = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MXN][MXN];</span><br><span class="line"><span class="keyword">int</span> c[MXN][MXN];</span><br><span class="line"><span class="keyword">int</span> p[MXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, S, T, C; <span class="comment">// S: Source, T: Sink</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLR(f);</span><br><span class="line">    CLR(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; S &gt;&gt; T &gt;&gt; C;</span><br><span class="line">    <span class="keyword">while</span> (C--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        c[u][v] += w;</span><br><span class="line">        c[v][u] += w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">augment</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> bottleNeck)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == S) <span class="keyword">return</span> bottleNeck;</span><br><span class="line">    bottleNeck = augment(p[u], u, min(c[u][v] - f[u][v], bottleNeck));</span><br><span class="line">    f[u][v] += bottleNeck;</span><br><span class="line">    f[v][u] -= bottleNeck;</span><br><span class="line">    <span class="keyword">return</span> bottleNeck;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Edmonds-Karp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxiumFlow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mf = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        CLR(vis);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(S);</span><br><span class="line">        vis[S] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty() &amp;&amp; !vis[T])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = QPOP(q);</span><br><span class="line"></span><br><span class="line">            FOR(v, <span class="number">1</span>, N + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (vis[v] || f[u][v] &gt;= c[u][v]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                q.push(v);</span><br><span class="line">                vis[v] = <span class="literal">true</span>;</span><br><span class="line">                p[v] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!vis[T]) <span class="keyword">break</span>; <span class="comment">// no path</span></span><br><span class="line">        mf += augment(p[T], T, INF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> C = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Network &quot;</span> &lt;&lt; ++C &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The bandwidth is &quot;</span> &lt;&lt; maxiumFlow() &lt;&lt; <span class="string">&quot;.\n\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N &amp;&amp; N)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的作法將 Flow 跟 Capacity 分開，主要是希望可以保留 Capacity，若沒此需求也可以直接將一開始的 Capacity 當作 Residual Network 來做，可以省去一個陣列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt; b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(c) memset(c, 0, sizeof(c))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">QPOP</span><span class="params">(<span class="built_in">queue</span>&lt;T&gt;&amp; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fv1Gvx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MXN = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rn[MXN][MXN];</span><br><span class="line"><span class="keyword">int</span> p[MXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, S, T, C; <span class="comment">// S: Source, T: Sink</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLR(rn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; S &gt;&gt; T &gt;&gt; C;</span><br><span class="line">    <span class="keyword">while</span> (C--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        rn[u][v] += w;</span><br><span class="line">        rn[v][u] += w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">augment</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> bottleNeck)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == S) <span class="keyword">return</span> bottleNeck;</span><br><span class="line">    bottleNeck = augment(p[u], u, min(rn[u][v], bottleNeck));</span><br><span class="line">    rn[u][v] -= bottleNeck;</span><br><span class="line">    rn[v][u] += bottleNeck;</span><br><span class="line">    <span class="keyword">return</span> bottleNeck;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Edmonds-Karp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxiumFlow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mf = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        CLR(vis);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(S);</span><br><span class="line">        vis[S] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty() &amp;&amp; !vis[T])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = QPOP(q);</span><br><span class="line"></span><br><span class="line">            FOR(v, <span class="number">1</span>, N + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (vis[v] || !rn[u][v]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                q.push(v);</span><br><span class="line">                vis[v] = <span class="literal">true</span>;</span><br><span class="line">                p[v] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!vis[T]) <span class="keyword">break</span>; <span class="comment">// no path</span></span><br><span class="line">        mf += augment(p[T], T, INF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> C = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Network &quot;</span> &lt;&lt; ++C &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The bandwidth is &quot;</span> &lt;&lt; maxiumFlow() &lt;&lt; <span class="string">&quot;.\n\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N &amp;&amp; N)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dinic:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt; b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(c) memset(c, 0, sizeof(c))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">QPOP</span><span class="params">(<span class="built_in">queue</span>&lt;T&gt;&amp; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fXrOUx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MXN = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rn[MXN][MXN];</span><br><span class="line"><span class="keyword">int</span> l[MXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, S, T, C; <span class="comment">// S: Source, T: Sink</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLR(rn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; S &gt;&gt; T &gt;&gt; C;</span><br><span class="line">    <span class="keyword">while</span> (C--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        rn[u][v] += w;</span><br><span class="line">        rn[v][u] += w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dinicBFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLR(l);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(S);</span><br><span class="line">    l[S] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = QPOP(q);</span><br><span class="line"></span><br><span class="line">        FOR(v, <span class="number">1</span>, N + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l[v] || !rn[u][v]) <span class="keyword">continue</span>;</span><br><span class="line">            l[v] = l[u] + <span class="number">1</span>;</span><br><span class="line">            q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l[T];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinicDFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> cp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == T) <span class="keyword">return</span> cp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp = cp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= N &amp;&amp; tmp; ++v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l[v] != l[u] + <span class="number">1</span> || !rn[u][v]) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> bottleNeck = dinicDFS(v, min(rn[u][v], tmp));</span><br><span class="line">        rn[u][v] -= bottleNeck;</span><br><span class="line">        rn[v][u] += bottleNeck;</span><br><span class="line">        tmp -= bottleNeck;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cp - tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxiumFlow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (dinicBFS()) mf += dinicDFS(S, INF);</span><br><span class="line">    <span class="keyword">return</span> mf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> C = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Network &quot;</span> &lt;&lt; ++C &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The bandwidth is &quot;</span> &lt;&lt; maxiumFlow() &lt;&lt; <span class="string">&quot;.\n\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; N &amp;&amp; N)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/f182Jx">Programming學習筆記: UVa 820 Network Bandwidth</a><br><a href="https://ppt.cc/fv1Gvx">UVa 820 - Internet Bandwidth | NaiveRed’s Blog</a><br><a href="https://ppt.cc/fXrOUx">Dinic算法详解及实现 - 0giant - 博客园</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Queue</tag>
        <tag>Maximum Flow</tag>
        <tag>Dinic</tag>
        <tag>Edmonds-Karp</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 821 解題紀錄</title>
    <url>/UVa-821/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=762">UVa - 821 - Page Hopping</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個有向圖，求所有可連通的任意兩點的最短路徑平均。</p>
<p><strong>Input：</strong> 每組測資裡面有許多兩個數字的 pair，<code>u</code>、<code>v</code>，表示點 <code>u</code> 與點 <code>v</code> 連通，若皆為 0 表示該組測資結束，若測資的第一組 <code>u</code>、<code>v</code> 皆為 0 表程式結束。</p>
<p><strong>Output：</strong> 輸出所有可連通的任意兩點的最短路徑平均。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>All Pair Shortest Path 題，讀測資並做 Floyd-Warshall Algorithm 求解即可。需要注意的是點的編號並不是集中的，所以需要紀錄點的最大編號。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/f6R74x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> C;</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    N = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">101</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">101</span>; ++j) dist[i][j] = INF;</span><br><span class="line">        dist[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        dist[u][v] = <span class="number">1</span>;</span><br><span class="line">        N = (max(max(u, v), N));</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &amp;&amp; (u || v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FloydWarshall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">            dist[i][j] = min(dist[i][k] + dist[k][j], dist[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">        <span class="keyword">if</span> (dist[i][j] &lt; INF &amp;&amp; dist[i][j]) sum += dist[i][j], ++cnt;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; ++C &lt;&lt; <span class="string">&quot;: average length between pages = &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; fixed &lt;&lt; sum / cnt &lt;&lt; <span class="string">&quot; clicks\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &amp;&amp; (u || v))</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        read();</span><br><span class="line">        FloydWarshall();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/f6R74x">UVa 821 - Page Hopping_小白菜又菜-CSDN博客</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>UVa</tag>
        <tag>Floyd-Warshall</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 872 解題紀錄</title>
    <url>/UVa-872/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=813">UVa - 872 - Ordering</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一些字母，及一些規則，如 <code>A &lt; B</code>，表示 B 一定要排在 A 後面。求符合規則所有排序情況，並依照字典序輸出。</p>
<span id="more"></span>

<p><strong>Input：</strong> 第一行為一整數，代表有幾組測資，每組測資的第一行為所有字母 ( 中間以空格隔開 )，第二行為排序規則 ( 一定是 <code>&lt;</code> 的形式，中間以空格隔開 )。每組測資中間以空行隔開，整數及第一筆測資間也以空行隔開。</p>
<p><strong>Output：</strong> 輸出所有排序情況並按照字典序排序。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>讀取所有字母並按照字典序排序 ( 確保後面做 DFS 時先輸出的會是字典序較小的 )，之後讀取規則，將 <code>G[A][B]</code> 設為 1 表示 A 指向 B，…，以此類推來建圖，之後 DFS 做 Topological Sort，同時搭配 Back Tracking 來排出所有情況即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i, n) for(int i = 0; i &lt; n; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> diff(ch) (ch - <span class="meta-string">&#x27;A&#x27;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE(c) int(c.size())</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fqUhHx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> print = [](<span class="built_in">string</span>&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; SIZE(str); ++i) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; str[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Data</span></span><br><span class="line">    <span class="keyword">int</span> G[<span class="number">26</span>][<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> visited[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> track;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">string</span> str, S;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="built_in">cin</span>.ignore();</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="keyword">void</span>(<span class="built_in">string</span>)&gt; dfs = [&amp;](<span class="built_in">string</span> ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret.length() == S.length()) &#123; print(ret), track = <span class="literal">true</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">        FOR(i, SIZE(S))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[diff(S[i])]) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; SIZE(ret); ++j) <span class="keyword">if</span> (G[diff(S[i])][diff(ret[j])]) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果 j 不等於 ret 的長度表示 ret 裡面出現了必須要出現在 s[i] 後面的字元</span></span><br><span class="line">            <span class="keyword">if</span> (j != SIZE(ret)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// back tracking</span></span><br><span class="line">            visited[diff(S[i])] = <span class="number">1</span>;</span><br><span class="line">            dfs(ret + S[i]);</span><br><span class="line">            visited[diff(S[i])] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        getline(<span class="built_in">cin</span>, str); <span class="comment">// avoid space</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        track = <span class="literal">false</span>;</span><br><span class="line">        fill(G[<span class="number">0</span>], G[<span class="number">0</span>] + <span class="number">676</span>, <span class="number">0</span>);</span><br><span class="line">        fill(visited, visited + <span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        S.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 讀取英文字母</span></span><br><span class="line">        getline(<span class="built_in">cin</span>, str);</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; str) S += str;</span><br><span class="line">        sort(begin(S), end(S));</span><br><span class="line"></span><br><span class="line">        getline(<span class="built_in">cin</span>, str);</span><br><span class="line">        ss.clear();</span><br><span class="line">        ss.str(str);</span><br><span class="line">        <span class="comment">// 紀錄不能出現在 str[0] 前面的字元</span></span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; str) G[diff(str[<span class="number">0</span>])][diff(str[<span class="number">2</span>])] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!track) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (T) <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/00872.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fqUhHx">872 - Ordering.cpp</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>String</tag>
        <tag>Recursive</tag>
        <tag>Topological Sort</tag>
        <tag>Graph</tag>
        <tag>Stringstream</tag>
        <tag>Back Tracking</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 924 解題紀錄</title>
    <url>/UVa-924/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=865">UVa - 924 - Spreading The News</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>在一個組織裡面散布消息，組織裡面的員工都有跟自己比較好的朋友，每位員工收到消息後會在隔天跟所有比較好的朋友說，現在將消息告訴一位員工，求在哪一天消息會被最多原本不知道的人知道。</p>
<span id="more"></span>

<p><strong>Input：</strong> 不太好解釋，所以直接拿題目的 Sample I/O 來解釋。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span>          表示有 <span class="number">6</span> 位員工 ( 序號為 <span class="number">0</span> ~ <span class="number">5</span> )</span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2</span>      第零位員工的朋友，第一個整數為朋友數，後面接的是朋友的序號，意思為，若 <span class="number">0</span> 號收到消息，會在隔天跟 <span class="number">1</span> 號還有 <span class="number">2</span> 號說</span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span>      第一位員工的朋友，第一個整數為朋友數，後面接的是朋友的序號，意思為，若 <span class="number">1</span> 號收到消息，會在隔天跟 <span class="number">3</span> 號還有 <span class="number">4</span> 號說</span><br><span class="line"><span class="number">3</span> <span class="number">0</span> <span class="number">4</span> <span class="number">5</span>    .</span><br><span class="line"><span class="number">1</span> <span class="number">4</span>        .</span><br><span class="line"><span class="number">0</span>          .</span><br><span class="line"><span class="number">2</span> <span class="number">0</span> <span class="number">2</span>      第一位員工的朋友，第一個整數為朋友數，後面接的是朋友的序號，意思為，若 <span class="number">5</span> 號收到消息，會在隔天跟 <span class="number">0</span> 號還有 <span class="number">2</span> 號說</span><br><span class="line"><span class="number">3</span>          幾組測試</span><br><span class="line"><span class="number">0</span>          若先將消息跟 <span class="number">0</span> 號員工說</span><br><span class="line"><span class="number">4</span>          若先將消息跟 <span class="number">4</span> 號員工說</span><br><span class="line"><span class="number">5</span>          若先將消息跟 <span class="number">5</span> 號員工說</span><br></pre></td></tr></table></figure>

<p><strong>Output：</strong> 輸出在哪一天消息會被最多原本不知道的人知道的人數及天數，如答案若為 3 2，表示在第二天有 3 個原本不知道的人知道了。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先根據朋友的關係建圖，之後 BFS 求解，由於題目要求每天的傳播人數，所以每次都取在隊列中的所有人進行傳播，模擬一天的情況。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">reference:</span></span><br><span class="line"><span class="comment">https://ppt.cc/fdJC2x</span></span><br><span class="line"><span class="comment">https://ppt.cc/fQY21x</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; G;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(n);</span><br><span class="line">    visited.insert(n);</span><br><span class="line">    <span class="keyword">int</span> day = <span class="number">1</span>, cnt;</span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; _max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.size();</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一天可以往外傳播的人數</span></span><br><span class="line">        <span class="keyword">while</span> (size--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : G[u])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited.count(v)) <span class="keyword">continue</span>;</span><br><span class="line">                q.push(v);</span><br><span class="line">                visited.insert(v);</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; _max.second) _max = &#123; day, cnt &#125;;</span><br><span class="line">        ++day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!_max.second) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; _max.second &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; _max.first &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> E;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; E)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// init</span></span><br><span class="line">        G.assign(E, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n, v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; E; ++u)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">            <span class="keyword">while</span> (n--) <span class="built_in">cin</span> &gt;&gt; v, G[u].push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> T;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">        <span class="keyword">while</span> (T--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">            visited.clear();</span><br><span class="line">            bfs(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/00924.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fdJC2x">UVA 924/SPREADING THE NEWS</a><br><a href="https://ppt.cc/fQY21x">UVa 924 - Spreading The News | NaiveRed’s Blog</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Queue</tag>
        <tag>Graph</tag>
        <tag>Vector</tag>
        <tag>Unordered_set</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa - 929 解題紀錄</title>
    <url>/UVa-929/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=870">UVa - 929 - Number Maze</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一張地圖，每個格子中都有一些數字，求從起點走到終點且沿途的數字和為最小值。</p>
<span id="more"></span>

<p><strong>Input：</strong> 第一行為一個整數 <code>T</code>，表示有 <code>T</code> 組測資，後面兩行分別為兩個整數 <code>N</code>、<code>M</code>，表示地圖為 <code>N</code> * <code>M</code>，後面 <code>N</code> 行，每行會有 <code>M</code> 個數字，表示地圖。</p>
<p><strong>Output：</strong> 輸出從起點走到終點最小的數字和。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p><strong>這個解法需要有 Dijkstra 演算法的概念。</strong></p>
<p>使用 Dijkstra 搭配 Priority_queue 求解即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/fDEWex</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Val</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Val&amp; r) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cost &gt; r.cost; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// data</span></span><br><span class="line"><span class="keyword">int</span> N, M;                     <span class="comment">// matrix is N * M</span></span><br><span class="line"><span class="keyword">int</span> maze[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> value[<span class="number">1001</span>][<span class="number">1001</span>];        <span class="comment">// 從起點走到每個點的最短路徑</span></span><br><span class="line"><span class="keyword">int</span> d[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span> &#125;; <span class="comment">// 偏移量</span></span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;Val, <span class="built_in">vector</span>&lt;Val&gt;, greater&lt;Val&gt;&gt; pq; <span class="comment">// min heap</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 一開始將距離都設為最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; ++j) value[i][j] = INT_MAX;</span><br><span class="line">    fill(visited[<span class="number">0</span>], visited[<span class="number">0</span>] + <span class="number">1001</span> * <span class="number">1001</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pq.push(&#123; <span class="number">0</span>, <span class="number">0</span>, value[<span class="number">0</span>][<span class="number">0</span>] = maze[<span class="number">0</span>][<span class="number">0</span>] &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [x, y, val] = pq.top();</span><br><span class="line">        visited[y][x] = <span class="literal">true</span>;</span><br><span class="line">        pq.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> dx = x + d[i], dy = y + d[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果超出範圍或是走過</span></span><br><span class="line">            <span class="keyword">if</span> (dx &lt; <span class="number">0</span> || dx &gt;= M || dy &lt; <span class="number">0</span> || dy &gt;= N || visited[dy][dx]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> tmp = val + maze[dy][dx];</span><br><span class="line">            <span class="keyword">if</span> (value[dy][dx] &gt; tmp) pq.push(&#123; dx, dy, value[dy][dx] = tmp &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; value[N - <span class="number">1</span>][M - <span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建圖</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> val;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; val;</span><br><span class="line">            maze[i][j] = val;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        dijkstra();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/00929.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fDEWex">UVa/UVa 929 - Number Maze.cpp at master · ajahuang/UVa</a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Graph</tag>
        <tag>Priority_queue</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>Homework 1 - Unordered_set</title>
    <url>/1091DS-HW1/</url>
    <content><![CDATA[<p>課程名稱：資料結構 CS203 A<br>授課教師：林基成<span id="more"></span><br>發放時間：2020-09-16<br>截止時間：2020-09-22</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>完成 Unordered_set 的部分函式。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>下面是依照我寫的順序來排序的。</p>
<ol>
<li><p><code>void assignGrow(const size_type cells, const value_type val)</code></p>
<ul>
<li><strong>函式功能：</strong> 將動態陣列的大小擴張為 <code>cells</code>，並且將值都設為 <code>val</code>。</li>
<li><strong>參考作法：</strong> 先判斷原本的動態陣列是否存在，若存在則先刪除，接著重新宣告一個 <code>cells</code> 大小的動態陣列，再將值一一放入，最後將 pointer 的位置更新即可。</li>
<li><strong>參考解法：</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set the elements stored here to cells copies of val</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assignGrow</span><span class="params">( <span class="keyword">const</span> size_type cells, <span class="keyword">const</span> value_type val )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (myData.myFirst) <span class="keyword">delete</span>[] myData.myFirst;</span><br><span class="line">    myData.myLast = myData.myEnd = myData.myFirst = <span class="keyword">new</span> value_type[cells];</span><br><span class="line">    <span class="keyword">do</span> *myData.myLast++ = val; <span class="keyword">while</span> (++myData.myEnd != myData.myFirst + cells);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>size_type bucket_size(size_type n) const</code></p>
<ul>
<li><strong>函式功能：</strong> 回傳第 <code>n</code> 個 bucket 的元素個數。</li>
<li><strong>參考作法：</strong> 先找出第 <code>n</code> 個 bucket 的頭部的 iterator，即為 <code>*(myVec.myData.myFirst + n * 2)</code>，因為 <code>myVec</code> 會儲存每個 bucket 的頭部及尾端的 iterator，所以 <code>n</code> 需要乘以 2。接著使用迴圈直到 <code>iter</code> 到了第 <code>n</code> 個 bucket 的尾端，最後判斷 <code>iter</code> 是否等於 <code>myList.end()</code> 若是相等代表這個 bucket 是空的，否則回傳 <code>++tmp</code>，因為迴圈到了尾巴就退出了，會少算一個元素。</li>
<li><strong>參考解法：</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns the number of elements in bucket n.</span></span><br><span class="line"><span class="function">size_type <span class="title">bucket_size</span><span class="params">( size_type n )</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> head = &amp;myVec.myData.myFirst[n * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> *head == myList.end() ? <span class="number">0</span> : <span class="built_in">std</span>::distance(*head, *(head + <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//int cnt&#123;&#125;;</span></span><br><span class="line">    <span class="comment">//auto iter = myVec.myData.myFirst[n * 2];</span></span><br><span class="line">    <span class="comment">//while (iter != myVec.myData.myFirst[n * 2 + 1]) ++cnt, ++iter;</span></span><br><span class="line">    <span class="comment">//return iter == myList.end() ? 0 : ++cnt;</span></span><br><span class="line">    <span class="comment">// also be fine</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>iterator find(const key_type &amp;keyVal)</code></p>
<ul>
<li><strong>函式功能：</strong> 若是 <code>keyVal</code> 存在則回傳該值位於的 node 的 iterator，否則回傳 <code>myList.end()</code>。</li>
<li><strong>參考作法：</strong> 先找出 <code>keyVal</code> 的 hashCode，代表位於第幾個 bucket，接著遍歷這個 bucket 直到尾端或是找到值與 <code>keyVal</code> 相同的 node，最後判斷 <code>iter</code> 是否與 <code>myList.end()</code> 相等，若相等代表這個 bucket 是空的，則值也不會存在。否則判斷 <code>*iter</code> 是否與 <code>keyVal</code> 相等，若相等回傳 iter，否則回傳 <code>myList.end()</code>。這樣寫的同時確保了 bucket 的尾巴也會判斷到。</li>
<li><strong>參考解法：</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Searches the unordered_set for an element with keyVal as value and</span></span><br><span class="line"><span class="comment">// returns an iterator to it if found, otherwise it returns myList.end()</span></span><br><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">( <span class="keyword">const</span> key_type &amp;keyVal )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = bucket(keyVal);</span><br><span class="line">    <span class="keyword">auto</span> iter = myVec.myData.myFirst[hash * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span> (iter != myVec.myData.myFirst[hash * <span class="number">2</span> + <span class="number">1</span>] &amp;&amp; *iter != keyVal) ++iter;</span><br><span class="line">    <span class="keyword">return</span> iter == myList.end() ? myList.end() : *iter == keyVal ? iter : myList.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>void putIn(const value_type &amp;val)</code></p>
<ul>
<li><strong>函式功能：</strong> 將 <code>val</code> 放入 <code>myList</code>，同時位於 <code>myVec</code> 的 iterator 也需更新。</li>
<li><strong>參考作法：</strong> 先找出 <code>val</code> 應該放入的 bucket，接著將 val 放入 bucket 的最前面，最後判斷 <code>*head</code> 是否等於 <code>myList.end()</code>，若相等代表這個 bucket 還是空的，此時值會被放在 <code>myList</code> 的尾端，將頭部跟尾端的 iterator 往前移恰好會指到該值。否則將頭部的 iterator 往前移即可。</li>
<li><strong>參考解法：</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// put a new element in the unordered_set when myVec is large enough</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putIn</span><span class="params">( <span class="keyword">const</span> value_type &amp;val )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> head = &amp;myVec.myData.myFirst[bucket(val) * <span class="number">2</span>];</span><br><span class="line">    myList.insert(*head, val);</span><br><span class="line">    <span class="keyword">if</span> ((*head)-- == myList.end())--* ++head;</span><br><span class="line">    <span class="comment">//*head == myList.end() ? -- * head, --* ++head : --* head; // also be fine</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>void insert(const value_type &amp;val)</code></p>
<ul>
<li><strong>函式功能：</strong> 將 <code>val</code> 放入 unordered_set，若是大小超過需要擴張大小 ( 當元素個數等於 <code>maxidx</code> 時)。</li>
<li><strong>參考作法：</strong> 先判斷 <code>val</code> 是否已經存在，若存在則直接回傳避免重複插入。接著判斷大小是否已經超過，若超過則需要更新 <code>maxidx</code> ( 初始值為 8，前兩次擴張都乘以 8，後面擴張則都乘以 2 ) 及 <code>mask</code> ( 永遠為 <code>maxidx - 1</code>)，接著將 <code>myList</code> 備份並清除 <code>myList</code>，接著擴張 <code>myVec</code> ( 呼叫 <code>assignGrow()</code> )，再遍歷剛剛備份的 <code>myList</code> 將原本存在的 key 放入新的 <code>List</code> ( 呼叫 <code>putIn()</code> )，最後將 <code>val</code> 放入即可。</li>
<li><strong>參考解法：</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Inserts a new element in the unordered_set.</span></span><br><span class="line"><span class="comment">// The element is inserted only if it is not equivalent to any other element</span></span><br><span class="line"><span class="comment">// already in the container ( elements in an unordered_set have unique values ).</span></span><br><span class="line"><span class="comment">// This effectively increases the container size by one.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">( <span class="keyword">const</span> value_type &amp;val )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (find(val) != myList.end()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size() == maxidx &amp;&amp; (mask = (maxidx *= maxidx &lt; <span class="number">512</span> ? <span class="number">8</span> : <span class="number">2</span>) - <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = myList;</span><br><span class="line">        myList.clear();</span><br><span class="line">        myVec.assignGrow(maxidx * <span class="number">2</span>, myList.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; key : tmp) putIn(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    putIn(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>void erase(const key_type &amp;keyVal)</code></p>
<ul>
<li><strong>函式功能：</strong> 將 <code>keyVal</code> 從 unordered_set 中刪除。</li>
<li><strong>參考作法：</strong> 先判斷 <code>keyVal</code> 是否存在，接著取得 <code>keyVal</code> 位於的 node 的 iterator。判斷此 bucket 的大小是否為 1，若為 1 代表刪除後此 bucket 會為空，需要將 <code>myVec</code> 中的 iterator 更新 ( 將頭部跟尾端的 iterator 都設為 <code>myList.end()</code> 即可 )。否則判斷這個 node 是否在 bucket 的頭部或尾端，若在頭部則頭部的 itertor 需要往後移，若在尾端則尾端的 iterator 需要往前移。最後從 <code>myList</code> 中刪除即可。</li>
<li><strong>參考解法：</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Removes from the unordered_set a single element.</span></span><br><span class="line"><span class="comment">// This effectively reduces the container size by one.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">( <span class="keyword">const</span> key_type &amp;keyVal )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> iter = find(keyVal);</span><br><span class="line">    <span class="keyword">if</span> (iter == myList.end()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> head = &amp;myVec.myData.myFirst[bucket(keyVal) * <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (*head == *(head + <span class="number">1</span>)) *head = *head++ = myList.end();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*head == iter || *(head + <span class="number">1</span>) == iter) *head == iter ? ++ * head : -- * ++head;</span><br><span class="line"></span><br><span class="line">    myList.erase(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<p><a href="https://github.com/larrylai19/1091YzuCse/tree/master/DataStructures/HW01"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>1091DataStructures-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>Homework 10 - UVa (Breadth-First Search, Minimum Spanning Tree)</title>
    <url>/1091DS-HW10/</url>
    <content><![CDATA[<p>課程名稱：資料結構 CS203 A<br>授課教師：林基成<span id="more"></span><br>發放時間：2020-11-30<br>截止時間：2020-12-07</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>這次的作業是 UVa 中的 6 題題目。三題與 BFS 相關，三題與 Minimum Spanning Tree 相關。</p>
<p><strong>與 BFS 相關</strong></p>
<ul>
<li>UVa - 429 - Word Transformation：<a class="lilink" href="../UVa-429/" target="_blank">UVa - 429 解題紀錄</a></li>
<li>UVa - 924 - Spreading The News：<a class="lilink" href="../UVa-924/" target="_blank">UVa - 924 解題紀錄</a></li>
<li>UVa - 10653 - Bombs! NO they are Mines!!：<a class="lilink" href="../UVa-10653/" target="_blank">UVa - 10653 解題紀錄</a></li>
</ul>
<p><strong>與 Minimum Spanning Tree 相關</strong></p>
<ul>
<li>UVa - 11228 - Transportation system.：<a class="lilink" href="../UVa-11228/" target="_blank">UVa - 11228 解題紀錄</a></li>
<li>UVa - 11631 - Dark roads：<a class="lilink" href="../UVa-11631/" target="_blank">UVa - 11631 解題紀錄</a></li>
<li>UVa - 11747 - Heavy Cycle Edges：<a class="lilink" href="../UVa-11747/" target="_blank">UVa - 11747 解題紀錄</a></li>
</ul>
<p><a href="https://github.com/larrylai19/1091YzuCse/tree/master/DataStructures/HW10"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>1091DataStructures-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>Homework 11 - UVa (Dijkstra’s Algorithm, The Bellman-Ford Algorithm)</title>
    <url>/1091DS-HW11/</url>
    <content><![CDATA[<p>課程名稱：資料結構 CS203 A<br>授課教師：林基成<span id="more"></span><br>發放時間：2020-11-30<br>截止時間：2020-12-07</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>這次的作業是 UVa 中的 6 題題目。三題與 Dijkstra’s Algorithm 相關，三題與 The Bellman-Ford Algorithm 相關。</p>
<p><strong>與 Dijkstra’s Algorithm 相關</strong></p>
<ul>
<li>UVa - 929 - Number Maze：<a class="lilink" href="../UVa-929/" target="_blank">UVa - 929 解題紀錄</a></li>
<li>UVa - 1112 - Mice and Maze：<a class="lilink" href="../UVa-1112/" target="_blank">UVa - 1112 解題紀錄</a></li>
<li>UVa - 10986 - Sending email：<a class="lilink" href="../UVa-10986/" target="_blank">UVa - 10986 解題紀錄</a></li>
</ul>
<p><strong>與 The Bellman-Ford Algorithm 相關</strong></p>
<ul>
<li>UVa - 558 - Wormholes：<a class="lilink" href="../UVa-558/" target="_blank">UVa - 558 解題紀錄</a></li>
<li>UVa - 10449 - Traffic：<a class="lilink" href="../UVa-10449/" target="_blank">UVa - 10449 解題紀錄</a></li>
<li>UVa - 10557 - XYZZY：<a class="lilink" href="../UVa-10557/" target="_blank">UVa - 10557 解題紀錄</a></li>
</ul>
<p><a href="https://github.com/larrylai19/1091YzuCse/tree/master/DataStructures/HW11"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>1091DataStructures-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>Homework 2 - Priority_queue</title>
    <url>/1091DS-HW2/</url>
    <content><![CDATA[<p>課程名稱：資料結構 CS203 A<br>授課教師：林基成<span id="more"></span><br>發放時間：2020-09-22<br>截止時間：2020-09-29</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>完成 Priority_queue 中使用到的 heap 中的部分函式。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>這次作業的結構主要是用陣列來模擬的二元樹，若樹節點比下面的樹節點的值都大為 max heap，若比下面的樹節點都小為 min heap，<code>first</code> 為陣列開頭的指標，<code>pred</code> 為比較的方法，若 <code>perd</code> 為 less 則為 max heap，若為 greater 則為 min heap。</p>
<p>下面是依照我寫的順序來排序的。</p>
<ol>
<li><p><code>inline void pushHeapByIndex(RanIt first, ptrdiff_t hole, ptrdiff_t top, Ty&amp; val, Pr pred)</code></p>
<ul>
<li><strong>函式功能：</strong> 從 hole 開始，找到 val 應該填入的正確位置。</li>
<li><strong>參考作法：</strong> 定義 <code>i</code> 為當前 <code>hole</code> 的 parent，接著判斷若是 <code>hole &gt; top</code> 且 <code>pred(first[i], val)</code>，表示 parent 的值需要往下移，最後更新使 <code>hole = i</code> 以及 <code>i = (hole - 1) / 2</code> 接著再繼續做，最後將 <code>val</code> 放入 <code>first[hole]</code> 即可。</li>
<li><strong>參考解法：</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> RanIt, <span class="keyword">typename</span> Ty, <span class="keyword">typename</span> Pr &gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushHeapByIndex</span><span class="params">(RanIt first, <span class="keyword">ptrdiff_t</span> hole, <span class="keyword">ptrdiff_t</span> top, Ty&amp; val, Pr pred)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> i = (hole - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// parent</span></span><br><span class="line">    <span class="keyword">while</span> (hole &gt; top &amp;&amp; pred(first[i], val)) first[hole] = first[i], i = ((hole = i) - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    first[hole] = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>inline void popHeapHoleByIndex(RanIt first, ptrdiff_t hole, ptrdiff_t bottom, Ty &amp;val, Pr pred)</code></p>
<ul>
<li><strong>函式功能：</strong> 從 <code>hole</code> 開始往下挑選較大的 child 放到 <code>hole</code> 直到到底為止。( 若兩個 child 相等則選擇右邊的 child )</li>
<li><strong>參考作法：</strong> 定義 <code>i</code> 為當前 <code>hole</code> 的 right child，接著判斷，若是 left child 大於 right child 則 <code>i--</code>，終止條件為 <code>i &lt; bottom</code>，此時若是 <code>i == bottom</code> 則代表最後一層還有 left child，則直接將 left child 放入，最後再呼叫 <code>pushHeapByIndex()</code> 將 <code>val</code> 放入即可。</li>
<li><strong>參考解法：</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> RanIt, <span class="keyword">typename</span> Ty, <span class="keyword">typename</span> Pr &gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">popHeapHoleByIndex</span><span class="params">( RanIt first, <span class="keyword">ptrdiff_t</span> hole, <span class="keyword">ptrdiff_t</span> bottom, Ty &amp;val, Pr pred )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> top = hole, i = hole * <span class="number">2</span> + <span class="number">2</span>; <span class="comment">// i -&gt; right child</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; bottom; i = (hole = i) * <span class="number">2</span> + <span class="number">2</span>)</span><br><span class="line">        first[hole] = first[pred(first[i], first[i - <span class="number">1</span>]) ? --i : i];</span><br><span class="line">    <span class="comment">// if only have left child</span></span><br><span class="line">    <span class="keyword">if</span> (i-- == bottom) first[hole] = first[i], hole = i;</span><br><span class="line">    pushHeapByIndex(first, hole, top, val, pred);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<p><a href="https://github.com/larrylai19/1091YzuCse/tree/master/DataStructures/HW02"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>1091DataStructures-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>Final Exam</title>
    <url>/1091DS-FinalExam/</url>
    <content><![CDATA[<p>課程名稱：資料結構 CS203 A<br>授課教師：林基成<span id="more"></span><br>考試時間：2020-12-20</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>本次考試為兩題 UVa 的題目，一題為：<code>UVa - 673 - Parentheses Balance</code>，一題選自作業：<code>UVa - 10972 - RevolC FaeLoN</code>。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><ul>
<li>UVa - 673 - Parentheses Balance：<a class="lilink" href="../UVa-673/" target="_blank">UVa - 673 解題紀錄</a></li>
<li>UVa - 10972 - RevolC FaeLoN：<a class="lilink" href="../UVa-10972/" target="_blank">UVa - 10972 解題紀錄</a></li>
</ul>
<p><a href="https://github.com/larrylai19/1091YzuCse/tree/master/DataStructures/Final"><i class="fa fa-download fa-2x"></i></a></p>
<hr>
<p>這次考的還算輕鬆，第一題老師放海，第二題是作業中比較有印象的一題，但是考試的時候把兩題同時寫，導致兩題都有點小錯誤，花了不少時間 Debug，希望能記取這次的教訓。。。</p>
]]></content>
      <categories>
        <category>1091DataStructures-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>Homework 4 - UVa (Map, Set)</title>
    <url>/1091DS-HW4/</url>
    <content><![CDATA[<p>課程名稱：資料結構 CS203 A<br>授課教師：林基成<span id="more"></span><br>發放時間：2020-10-19<br>截止時間：2020-10-25</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>這次的作業是 UVa 中的 6 題題目。三題與 Map 相關，三題與 Set 相關。</p>
<p><strong>與 Map 相關</strong></p>
<ul>
<li>Uva 10226 - Hardwood Species：<a class="lilink" href="../UVa-10226/" target="_blank">UVa - 10226 解題紀錄</a></li>
<li>UVa 10282 - Babelfish：<a class="lilink" href="../UVa-10282/" target="_blank">UVa - 10282 解題紀錄</a></li>
<li>UVa 11286 – Conformity：<a class="lilink" href="../UVa-11286/" target="_blank">UVa - 11286 解題紀錄</a></li>
</ul>
<p><strong>與 Set 相關</strong></p>
<ul>
<li>UVa - 978 - Lemmings Battle!：<a class="lilink" href="../UVa-978/" target="_blank">UVa - 978 解題紀錄</a></li>
<li>UVa - 11136 - Hoax or what：<a class="lilink" href="../UVa-11136/" target="_blank">UVa - 11136 解題紀錄</a></li>
<li>UVa - 11572 - Unique Snowflakes：<a class="lilink" href="../UVa-11572/" target="_blank">UVa - 11572 解題紀錄</a></li>
</ul>
<p><a href="https://github.com/larrylai19/1091YzuCse/tree/master/DataStructures/HW04"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>1091DataStructures-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>Homework 3 - Set</title>
    <url>/1091DS-HW3/</url>
    <content><![CDATA[<p>課程名稱：資料結構 CS203 A<br>授課教師：林基成<span id="more"></span><br>發放時間：2020-09-29<br>截止時間：2020-10-06</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>完成 Set 中使用到的紅黑樹中的部分函式。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>這次作業的結構為內部為二元紅黑樹的 Set，由於 Code 內已有註解，在此不再贅述，只說大方向的做法。</p>
<p><strong>插入元素:</strong></p>
<ol>
<li><p><code>void insert(const value_type &amp;val)</code></p>
<ul>
<li><strong>函式功能：</strong> 插入一個元素到 Set 中，若元素已經存在則不插入。</li>
<li><strong>參考作法：</strong> 先判斷該值是否已經存在，若不存在則找到該值的 parent ( <code>degree &lt;= 1</code> )，並調整紅黑樹的平衡。</li>
<li><strong>參考解法：</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Extends the container by inserting a new element,</span></span><br><span class="line"><span class="comment">// effectively increasing the container size by one.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">( <span class="keyword">const</span> value_type &amp;val )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// head -&gt; the reference of scaryVal.myHead</span></span><br><span class="line">    <span class="comment">// node -&gt; new node&#x27;s parent</span></span><br><span class="line">    <span class="comment">// dummy -&gt; dummy node</span></span><br><span class="line">    TreeNode&lt; value_type &gt;* head = scaryVal.myHead;</span><br><span class="line">    TreeNode&lt; value_type &gt;* node = head;</span><br><span class="line">    TreeNode&lt; value_type &gt;* dummy = head-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find new node&#x27;s parent also find if the key already exists or not</span></span><br><span class="line">    <span class="keyword">while</span> (!dummy-&gt;isNil &amp;&amp; node-&gt;myval != val)</span><br><span class="line">        node = dummy, dummy = keyCompare(val, dummy-&gt;myval) ? dummy-&gt;left : dummy-&gt;right;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// if the key already exists</span></span><br><span class="line">    <span class="keyword">if</span> (val == node-&gt;myval) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new node&#x27;s color should be red first</span></span><br><span class="line">    <span class="keyword">auto</span> newNode = <span class="keyword">new</span> TreeNode&lt; value_type &gt;&#123; head, node, head, red, <span class="literal">false</span>, val &#125;;</span><br><span class="line">    ++scaryVal.mySize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// connect node and new node, if new node is the root, update head&#x27;s parent</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;isNil) head-&gt;left = head-&gt;right = head-&gt;parent = newNode;</span><br><span class="line">    <span class="keyword">else</span> keyCompare(val, node-&gt;myval) ? node-&gt;left = newNode : node-&gt;right = newNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update head&#x27;s pointers</span></span><br><span class="line">    <span class="keyword">if</span> (keyCompare(val, head-&gt;left-&gt;myval)) head-&gt;left = newNode;</span><br><span class="line">    <span class="keyword">if</span> (keyCompare(head-&gt;right-&gt;myval, val)) head-&gt;right = newNode;</span><br><span class="line"></span><br><span class="line">    scaryVal.reBalance(newNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>void reBalance(TreeNode&lt; value_type &gt; *node)</code></p>
<ul>
<li><strong>函式功能：</strong> 調整插入元素後造成的失衡。<code>node-&gt;color</code> 必為紅色。</li>
<li><strong>參考作法：</strong> 根據基哥上課時講解的情況完成即可，在此不多贅述。</li>
<li><strong>參考解法：</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rebalance for insertion</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reBalance</span><span class="params">( TreeNode&lt; value_type &gt; *node )</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// node-&gt;parent cannot be the root</span></span><br><span class="line">    <span class="comment">// refer to the video of class and the internet</span></span><br><span class="line">    <span class="comment">// p -&gt; parent, g -&gt; grand, u -&gt; uncle</span></span><br><span class="line">    TreeNode&lt; value_type &gt;* p = node-&gt;parent;</span><br><span class="line">    TreeNode&lt; value_type &gt;* g = node-&gt;parent-&gt;parent;</span><br><span class="line">    TreeNode&lt; value_type &gt;* u = p == g-&gt;left ? g-&gt;right : g-&gt;left;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Case 1 -&gt; node is the root, make node black</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;isNil) &#123; node-&gt;color = black; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// boundary condition of Case 2</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;color == black) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// XYr</span></span><br><span class="line">    <span class="keyword">if</span> (u-&gt;color == red)</span><br><span class="line">    &#123;   <span class="comment">// Case 2 -&gt; LLr, LRr, RLr, or RRr</span></span><br><span class="line">        p-&gt;color = u-&gt;color = black;</span><br><span class="line">        g-&gt;color = red;</span><br><span class="line">        <span class="comment">// do the same thing to g</span></span><br><span class="line">        reBalance(g);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// XYb</span></span><br><span class="line">    <span class="keyword">if</span> (p == g-&gt;left &amp;&amp; node == p-&gt;left)</span><br><span class="line">    &#123;   <span class="comment">// Case 3 -&gt; LLb</span></span><br><span class="line">        LLRotation(p); <span class="comment">// rotate right at g</span></span><br><span class="line">        swap(p-&gt;color, g-&gt;color);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == g-&gt;right &amp;&amp; node == p-&gt;right)</span><br><span class="line">    &#123;   <span class="comment">// Case 4 -&gt; RRb</span></span><br><span class="line">        RRRotation(p); <span class="comment">// rotate left at g</span></span><br><span class="line">        swap(p-&gt;color, g-&gt;color);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == g-&gt;left &amp;&amp; node == p-&gt;right)</span><br><span class="line">    &#123;   <span class="comment">// Case 5 -&gt; LRb</span></span><br><span class="line">        <span class="comment">// rotate left at p first, then rotate right at g</span></span><br><span class="line">        LRRotation(node);</span><br><span class="line">        swap(node-&gt;color, g-&gt;color);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == g-&gt;right &amp;&amp; node == p-&gt;left)</span><br><span class="line">    &#123;   <span class="comment">// Case 6 -&gt; RLb</span></span><br><span class="line">        <span class="comment">// rotate right at p first, then rotate left at g</span></span><br><span class="line">        RLRotation(node);</span><br><span class="line">        swap(node-&gt;color, g-&gt;color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>LLRotation(TreeNode&lt; value_type &gt; *p)</code></p>
<ul>
<li><strong>函式功能：</strong> 在 <code>g</code> 右旋轉，<code>p = g-&gt;left</code> 且 <code>node = p-&gt;left</code>。建議搭配圖片來看會較清楚。</li>
<li><strong>參考作法：</strong> 將對應的 node 相連即可，需要注意的是若 <code>p-&gt;right</code> 為 nil node，則不能更改 <code>p-&gt;right-&gt;parent</code>，因為會改動到 <code>myHead-&gt;parent</code>，使得找不到 root。並且若 <code>g</code> 原本為 root，則 <code>p</code> 頂替 <code>g</code> 的位置時需要改變的是 <code>myHead-&gt;parent</code>，而不是 left 或 right。</li>
<li><strong>參考解法：</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rotate right at g, where p = g-&gt;left and node = p-&gt;left</span></span><br><span class="line"><span class="comment">//void set&lt; Kty &gt;::LLbRotation( TreeNode&lt; value_type &gt; *node )</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LLRotation</span><span class="params">( TreeNode&lt; value_type &gt; *p )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode&lt; value_type &gt;* g = p-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// connect g and p&#x27;s right child</span></span><br><span class="line">    g-&gt;left = p-&gt;right;</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;right-&gt;isNil) p-&gt;right-&gt;parent = g;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// connect g&#x27;s parent and p</span></span><br><span class="line">    <span class="keyword">if</span> (g-&gt;parent-&gt;isNil) myHead-&gt;parent = p;</span><br><span class="line">    <span class="keyword">else</span> g == g-&gt;parent-&gt;left ? g-&gt;parent-&gt;left = p : g-&gt;parent-&gt;right = p;</span><br><span class="line">    p-&gt;parent = g-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// connect p and g</span></span><br><span class="line">    p-&gt;right = g;</span><br><span class="line">    g-&gt;parent = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>void RRRotation(TreeNode&lt; value_type &gt; *p)</code></p>
<ul>
<li><strong>函式功能：</strong> 在 <code>g</code> 左旋轉，<code>p = g-&gt;right</code> 且 <code>node = p-&gt;right</code>。建議搭配圖片來看會較清楚。</li>
<li><strong>參考作法：</strong> 與上面的右旋轉差不多，在此不多贅述。</li>
<li><strong>參考解法：</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rotate left at g, where p = g-&gt;right and node = p-&gt;right</span></span><br><span class="line"><span class="comment">//void set&lt; Kty &gt;::RRbRotation( TreeNode&lt; value_type &gt; *node )</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RRRotation</span><span class="params">( TreeNode&lt; value_type &gt; *p )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode&lt; value_type &gt;* g = p-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// connect g and p&#x27;s left child</span></span><br><span class="line">    g-&gt;right = p-&gt;left;</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;left-&gt;isNil) p-&gt;left-&gt;parent = g;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// connect g&#x27;s parent and p</span></span><br><span class="line">    <span class="keyword">if</span> (g-&gt;parent-&gt;isNil) myHead-&gt;parent = p;</span><br><span class="line">    <span class="keyword">else</span> g == g-&gt;parent-&gt;left ? g-&gt;parent-&gt;left = p : g-&gt;parent-&gt;right = p;</span><br><span class="line">    p-&gt;parent = g-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// connect p and g</span></span><br><span class="line">    p-&gt;left = g;</span><br><span class="line">    g-&gt;parent = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>void LRRotation(TreeNode&lt; value_type &gt; *node)</code></p>
<ul>
<li><strong>函式功能：</strong> 先在 <code>p</code> 左旋轉，接著在 <code>g</code> 右旋轉，<code>g</code> 為左旋轉前的 <code>g</code>。<code>p = g-&gt;left</code> 且 <code>node = p-&gt;right</code>。</li>
<li><strong>參考作法：</strong> 呼叫上面的函式即可，需要注意的是該傳入哪個 node，搭配圖片看就很清楚了。</li>
<li><strong>參考解法：</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LR rotation; p = g-&gt;left and node = p-&gt;right</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRRotation</span><span class="params">( TreeNode&lt; value_type &gt; *node )</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// LRb rotation</span></span><br><span class="line">    RRRotation(node); <span class="comment">// rotate left at p first</span></span><br><span class="line">    LLRotation(node); <span class="comment">// then rotate right at g</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>void RLRotation(TreeNode&lt; value_type &gt; *node)</code></p>
<ul>
<li><strong>函式功能：</strong> 先在 <code>p</code> 右旋轉，接著在 <code>g</code> 左旋轉，<code>g</code> 為右旋轉前的 <code>g</code>。<code>p = g-&gt;right</code> 且 <code>node = p-&gt;left</code>。</li>
<li><strong>參考作法：</strong> 與上面的先左旋轉再右旋轉相同，在此不多贅述。</li>
<li><strong>參考解法：</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RL rotation; p = g-&gt;right and node = p-&gt;left</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RLRotation</span><span class="params">( TreeNode&lt; value_type &gt; *node )</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// RLb rotation</span></span><br><span class="line">    LLRotation(node); <span class="comment">// rotate right at p first</span></span><br><span class="line">    RRRotation(node); <span class="comment">// then rotate left at g</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<hr>
<p><strong>刪除元素:</strong></p>
<ol start="7">
<li><p><code>size_type erase(const key_type &amp;val)</code></p>
<ul>
<li><strong>函式功能：</strong> 刪除 Set 中值為 <code>val</code> 的元素，並回傳刪除的元素數量。</li>
<li><strong>參考作法：</strong> 先判斷值是否存在，若不存在直接回傳 0。若存在則判斷該 node 是否存在兩個 child，若存在兩個 child 則從 node 的右子樹中找到最左邊的 node 的值來取代要刪除的 node，接著刪除剛剛找到的 node。若為 leaf node 或只存在一個 child，則直接刪除 ( 呼叫 <code>eraseDrgreeOne()</code> )。值得注意的是回傳的值必為 0 或 1，因為 Set 不允許存在兩個相同值的元素，所以最多只會找到一個要刪除的 node。</li>
<li><strong>參考解法：</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Removes from the set container a single element whose value is val</span></span><br><span class="line"><span class="comment">// This effectively reduces the container size by one, which are destroyed.</span></span><br><span class="line"><span class="comment">// Returns the number of elements erased.</span></span><br><span class="line"><span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type &amp;val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode&lt; value_type &gt;* node = scaryVal.myHead-&gt;parent; <span class="comment">// root</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the key</span></span><br><span class="line">    <span class="keyword">while</span> (!node-&gt;isNil &amp;&amp; val != node-&gt;myval)</span><br><span class="line">        node = keyCompare(val, node-&gt;myval) ? node-&gt;left : node-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// not found</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;isNil) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if node has two children</span></span><br><span class="line">    <span class="keyword">if</span> (!node-&gt;left-&gt;isNil &amp;&amp; !node-&gt;right-&gt;isNil)</span><br><span class="line">    &#123;   <span class="comment">// let the node&#x27;s right subtree&#x27;s leftmost node&#x27;s val replace node&#x27;s val</span></span><br><span class="line">        TreeNode&lt; value_type &gt;* RL = node-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (!RL-&gt;left-&gt;isNil) RL = RL-&gt;left;</span><br><span class="line">        node-&gt;myval = RL-&gt;myval;</span><br><span class="line">        node = RL; <span class="comment">// delete RL</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scaryVal.eraseDegreeOne(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>void eraseDegreeOne(TreeNode&lt; value_type &gt; *node)</code></p>
<ul>
<li><strong>函式功能：</strong> 刪除一個 <code>degree &lt;= 1</code> 的 node。</li>
<li><strong>參考作法：</strong> 根據基哥上課講解的情況完成即可。註解有列出情況及對應的操作，在此不多贅述。</li>
<li><strong>參考解法：</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// erase node provided that the degree of node is at most one</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eraseDegreeOne</span><span class="params">( TreeNode&lt; value_type &gt; *node )</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// refer to the video of class</span></span><br><span class="line">    <span class="comment">// M -&gt; the node need to delete</span></span><br><span class="line">    <span class="comment">// P -&gt; M&#x27;s parent, if M is the root, P is myHead</span></span><br><span class="line">    <span class="comment">// C -&gt; M&#x27;s only child, if M doesn&#x27;t have any child, C is the nil node</span></span><br><span class="line">    TreeNode&lt; value_type &gt;* M = node;</span><br><span class="line">    TreeNode&lt; value_type &gt;* P = node-&gt;parent;</span><br><span class="line">    TreeNode&lt; value_type &gt;* C = node-&gt;left-&gt;isNil ? node-&gt;right : node-&gt;left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Simple Case 3 -&gt; M and C are black, and M is the root</span></span><br><span class="line">    <span class="keyword">if</span> (M-&gt;color == black &amp;&amp; C-&gt;color == black &amp;&amp; P-&gt;isNil)</span><br><span class="line">    &#123;   <span class="comment">// delete M and make C be the root</span></span><br><span class="line">        myHead-&gt;parent = C;</span><br><span class="line">        C-&gt;parent = myHead;</span><br><span class="line">        <span class="keyword">delete</span> M;</span><br><span class="line">        --mySize;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Simple Case 1 -&gt; M is red or M is a leaf node : delete M and connect P and C</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// connect P and C</span></span><br><span class="line">    M == P-&gt;left ? P-&gt;left = C : P-&gt;right = C;</span><br><span class="line">    <span class="keyword">if</span> (!C-&gt;isNil) C-&gt;parent = P;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Complex Case -&gt; M and C are black, and M is not the root : connect P and C, then rebalance</span></span><br><span class="line">    <span class="keyword">if</span> (M-&gt;color == black &amp;&amp; C-&gt;color == black &amp;&amp; !P-&gt;isNil) fixUp(C, P);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Simple Case 2 -&gt; M is black, C is red : delete M, connect P and C, and make C black</span></span><br><span class="line">    <span class="keyword">if</span> (M-&gt;color == black &amp;&amp; C-&gt;color == red) C-&gt;color = black;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> M;</span><br><span class="line">    --mySize;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>void fixUp(TreeNode&lt; value_type &gt; *N, TreeNode&lt; value_type &gt; *P)</code></p>
<ul>
<li><p><strong>函式功能：</strong> 調整刪除 node 後造成的失衡。</p>
</li>
<li><p><strong>參考作法：</strong> 根據基哥附在作業中的 PPT 完成即可，在此不多贅述。</p>
</li>
<li><p><strong>參考解法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rebalance for deletion</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fixUp</span><span class="params">( TreeNode&lt; value_type &gt; *N, TreeNode&lt; value_type &gt; *P )</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// refer to Assignment 3.pptx</span></span><br><span class="line">    TreeNode&lt; value_type &gt;* S = N == P-&gt;left ? P-&gt;right : P-&gt;left; <span class="comment">// N&#x27;s sibling</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Case 1</span></span><br><span class="line">    <span class="keyword">if</span> (S-&gt;color == red &amp;&amp; N == P-&gt;left)</span><br><span class="line">    &#123;   <span class="comment">// Case 1.1 -&gt; S is red and N is P&#x27;s left child</span></span><br><span class="line">        swap(P-&gt;color, S-&gt;color);</span><br><span class="line">        RRRotation(S); <span class="comment">// rotate left at P</span></span><br><span class="line">        <span class="comment">// update S, then go to Case 2.1, 3.1, or 4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;color == red &amp;&amp; N == P-&gt;right)</span><br><span class="line">    &#123;   <span class="comment">// Case 1.2 -&gt; S is red and N is P&#x27;s right child</span></span><br><span class="line">        swap(P-&gt;color, S-&gt;color);</span><br><span class="line">        LLRotation(S); <span class="comment">// rotate right at P</span></span><br><span class="line">        <span class="comment">// update S, then go to Case 2.2, 3.2, or 4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update S</span></span><br><span class="line">    S = N == P-&gt;left ? P-&gt;right : P-&gt;left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Case 3</span></span><br><span class="line">    <span class="keyword">if</span> (S-&gt;color == black &amp;&amp; S-&gt;right-&gt;color == black &amp;&amp; N == P-&gt;left &amp;&amp; S-&gt;left-&gt;color == red)</span><br><span class="line">    &#123;   <span class="comment">// Case 3.1 -&gt; S and SR are black, N is P&#x27;s left child, but SL is red</span></span><br><span class="line">        swap(S-&gt;color, S-&gt;left-&gt;color);</span><br><span class="line">        LLRotation(S-&gt;left); <span class="comment">// rotate right at S</span></span><br><span class="line">        <span class="comment">// update S, then go to Case 2.1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;color == black &amp;&amp; S-&gt;left-&gt;color == black &amp;&amp; N == P-&gt;right &amp;&amp; S-&gt;right-&gt;color == red)</span><br><span class="line">    &#123;   <span class="comment">// Case 3.2 -&gt; S and SL are black, N is P&#x27;s right child, but SR is red</span></span><br><span class="line">        swap(S-&gt;color, S-&gt;right-&gt;color);</span><br><span class="line">        RRRotation(S-&gt;right); <span class="comment">// rotate left at S</span></span><br><span class="line">        <span class="comment">// update S, then go to Case 2.2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update S</span></span><br><span class="line">    S = N == P-&gt;left ? P-&gt;right : P-&gt;left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Case 2</span></span><br><span class="line">    <span class="keyword">if</span> (S-&gt;color == black &amp;&amp; S-&gt;right-&gt;color == red &amp;&amp; N == P-&gt;left)</span><br><span class="line">    &#123;   <span class="comment">// Case 2.1 -&gt; S is black, SR is red and N is P&#x27;s left child</span></span><br><span class="line">        swap(P-&gt;color, S-&gt;color);</span><br><span class="line">        S-&gt;right-&gt;color = black;</span><br><span class="line">        RRRotation(S); <span class="comment">// rotate left at P</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;color == black &amp;&amp; S-&gt;left-&gt;color == red &amp;&amp; N == P-&gt;right)</span><br><span class="line">    &#123;   <span class="comment">// Case 2.2 -&gt; S is black, SL is red and N is the right child of P</span></span><br><span class="line">        swap(P-&gt;color, S-&gt;color);</span><br><span class="line">        S-&gt;left-&gt;color = black;</span><br><span class="line">        LLRotation(S); <span class="comment">// rotate right at P</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Case 4 -&gt; S, SR and SL are black, but P is red</span></span><br><span class="line">    <span class="keyword">if</span> (S-&gt;color == black &amp;&amp; S-&gt;right-&gt;color == black &amp;&amp; S-&gt;left-&gt;color == black &amp;&amp; P-&gt;color == red)</span><br><span class="line">    &#123;   <span class="comment">// Just exchange the colors of S and of P</span></span><br><span class="line">        swap(S-&gt;color, P-&gt;color);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Case 5 -&gt; S, SR, SL and P are black</span></span><br><span class="line">    <span class="keyword">if</span> (S-&gt;color == black &amp;&amp; S-&gt;right-&gt;color == black &amp;&amp; S-&gt;left-&gt;color == black &amp;&amp; P-&gt;color == black)</span><br><span class="line">    &#123;</span><br><span class="line">        S-&gt;color = red;</span><br><span class="line">        fixUp(P, P-&gt;parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/1091YzuCse/tree/master/DataStructures/HW02"><i class="fa fa-download fa-2x"></i></a></p>
</li>
</ul>
</li>
</ol>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html#fixup">Red Black Tree: Insert(新增資料)與Fixup(修正)</a></p>
]]></content>
      <categories>
        <category>1091DataStructures-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>Homework 5 - UVa (List and Deque, Priority_queue)</title>
    <url>/1091DS-HW5/</url>
    <content><![CDATA[<p>課程名稱：資料結構 CS203 A<br>授課教師：林基成<span id="more"></span><br>發放時間：2020-10-29<br>截止時間：2020-11-05</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>這次的作業是 UVa 中的 5 題題目。兩題與 List 及 Deque 相關，三題與 Priority_queue 相關。</p>
<p><strong>與 List 及 Deque 相關</strong></p>
<ul>
<li>UVa - 11988 - Broken Keyboard (a.k.a. Beiju Text)：<a class="lilink" href="../UVa-11988/" target="_blank">UVa - 11988 解題紀錄</a></li>
<li>UVa - 12207 - That is Your Queue：<a class="lilink" href="../UVa-12207/" target="_blank">UVa - 12207 解題紀錄</a></li>
</ul>
<p><strong>與 Priority_queue 相關</strong></p>
<ul>
<li>UVa - 1203 - Argus：<a class="lilink" href="../UVa-1203/" target="_blank">UVa - 1203 解題紀錄</a></li>
<li>UVa - 10954 - Add All：<a class="lilink" href="../UVa-10954/" target="_blank">UVa - 10954 解題紀錄</a></li>
<li>UVa - 11995 - I Can Guess the Data Structure!：<a class="lilink" href="../UVa-11995/" target="_blank">UVa - 11995 解題紀錄</a></li>
</ul>
<p><a href="https://github.com/larrylai19/1091YzuCse/tree/master/DataStructures/HW05"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>1091DataStructures-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>Homework 6 - UVa (Stack, Queue)</title>
    <url>/1091DS-HW6/</url>
    <content><![CDATA[<p>課程名稱：資料結構 CS203 A<br>授課教師：林基成<span id="more"></span><br>發放時間：2020-10-29<br>截止時間：2020-11-05</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>這次的作業是 UVa 中的 6 題題目。三題與 Stack 相關，三題與 Queue 相關。</p>
<p><strong>與 Stack 相關</strong></p>
<ul>
<li>UVa - 514 - Rails：<a class="lilink" href="../UVa%20-514/" target="_blank">UVa - 514 解題紀錄</a></li>
<li>UVa - 732 - Anagrams by Stack：<a class="lilink" href="../UVa-732/" target="_blank">UVa - 732 解題紀錄</a></li>
<li>UVa - 1062 - Containers：<a class="lilink" href="../UVa-1062/" target="_blank">UVa - 1062 解題紀錄</a></li>
</ul>
<p><strong>與 Queue 相關</strong></p>
<ul>
<li>UVa - 10172 - The Lonesome Cargo Distributor：<a class="lilink" href="../UVa-10172/" target="_blank">UVa - 10172 解題紀錄</a></li>
<li>UVa - 10901 - Ferry Loading III：<a class="lilink" href="../UVa-10901/" target="_blank">UVa - 10901 解題紀錄</a></li>
<li>UVa - 11034 - Ferry Loading IV：<a class="lilink" href="../UVa-11034/" target="_blank">UVa - 11034 解題紀錄</a></li>
</ul>
<p><a href="https://github.com/larrylai19/1091YzuCse/tree/master/DataStructures/HW06"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>1091DataStructures-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>Homework 7 - UVa (DFS, Topological Sort)</title>
    <url>/1091DS-HW7/</url>
    <content><![CDATA[<p>課程名稱：資料結構 CS203 A<br>授課教師：林基成<span id="more"></span><br>發放時間：2020-11-05<br>截止時間：2020-11-12</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>這次的作業是 UVa 中的 6 題題目。三題與 DFS 相關，三題與 Topological Sort 相關。</p>
<p><strong>與 DFS 相關</strong></p>
<ul>
<li>UVa - 168 - Theseus and the Minotaur：<a class="lilink" href="../UVa-168/" target="_blank">UVa - 168 解題紀錄</a></li>
<li>UVa - 11906 - Knight in a War Grid：<a class="lilink" href="../UVa-11906/" target="_blank">UVa - 11906 解題紀錄</a></li>
<li>UVa - 12442 - Forwarding Emails：<a class="lilink" href="../UVa-12442/" target="_blank">UVa - 12442 解題紀錄</a></li>
</ul>
<p><strong>與 Topological Sort 相關</strong></p>
<ul>
<li>UVa - 200 - Rare Order：<a class="lilink" href="../UVa-200/" target="_blank">UVa - 200 解題紀錄</a></li>
<li>UVa - 872 - Ordering：<a class="lilink" href="../UVa-872/" target="_blank">UVa - 872 解題紀錄</a></li>
<li>UVa - 10305 - Ordering Tasks：<a class="lilink" href="../UVa-10305/" target="_blank">UVa - 10305 解題紀錄</a></li>
</ul>
<p><a href="https://github.com/larrylai19/1091YzuCse/tree/master/DataStructures/HW07"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>1091DataStructures-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>UVa - 978 解題紀錄</title>
    <url>/UVa-978/</url>
    <content><![CDATA[<p>題目： <a href="https://onlinejudge.org/index.php?option=onlinejudge&Itemid=8&page=show_problem&problem=919">UVa - 978 - Lemmings Battle!</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>有兩個隊伍需要戰鬥，每個隊伍裡面的戰士都有一個戰力，每次從隊伍裡面挑選 <code>B</code> 個人 ( 若任一隊伍不足 <code>B</code> 個人則以較少隊伍的人數當作 <code>B</code> ) 出來依序戰鬥<span id="more"></span>，若是被分配到的兩者戰力相等則同歸於盡，否則戰力較高的戰士減去戰力較低的戰士的戰力並回到隊伍中。</p>
<p><strong>Input：</strong> 測資起始於一個整數 <code>n</code>，代表接下來會有 <code>n</code> 組資料。每組資料的第一行為三個整數，分別代表 <code>B</code>、<code>SG</code>、<code>SB</code>，<code>SG</code> 為綠隊的人數，<code>SB</code> 為藍隊的人數，三者以空格隔開，接下來 <code>SG</code> 行為綠隊戰士的戰力，<code>SB</code> 行為藍隊戰士的戰力。</p>
<p><strong>Output：</strong> 若兩支隊伍最後都沒有戰士了則輸出 <code>&quot;green and blue died&quot;</code>，否則輸出勝利的隊伍，並且列出勝利隊伍剩餘戰士的戰力，並由大至小排序。兩組輸出結果中間須以空行隔開。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用兩個 Priority_queue 分別儲存兩隊戰士的戰力，並且每次 <code>pop()</code> 對應的人數戰鬥，使用 Vector 暫存戰鬥結果，最後依照戰鬥的結果將戰士重新 <code>push()</code> 回去即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> b, sg, sb, tmp;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b &gt;&gt; sg &gt;&gt; sb;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; G, B;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sg--) <span class="built_in">cin</span> &gt;&gt; tmp, G.push(tmp);</span><br><span class="line">        <span class="keyword">while</span> (sb--) <span class="built_in">cin</span> &gt;&gt; tmp, B.push(tmp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!G.empty() &amp;&amp; !B.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; battle;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (G.empty() || B.empty()) <span class="keyword">break</span>;</span><br><span class="line">                battle.push_back(G.top() - B.top());</span><br><span class="line">                G.pop(), B.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ret : battle)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) G.push(ret);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) B.push(-ret);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (G.empty() &amp;&amp; B.empty()) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;green and blue died\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!G.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;green wins\n&quot;</span>;</span><br><span class="line">                <span class="keyword">while</span> (!G.empty()) <span class="built_in">cout</span> &lt;&lt; G.top() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>, G.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;blue wins\n&quot;</span>;</span><br><span class="line">                <span class="keyword">while</span> (!B.empty()) <span class="built_in">cout</span> &lt;&lt; B.top() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>, B.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n) <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/UVa/00978.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UVa</tag>
        <tag>Vector</tag>
        <tag>Priority_queue</tag>
      </tags>
  </entry>
  <entry>
    <title>Homework 8 - UVa (Finding Articulation Points / Bridges, Finding Biconnected / Bridge Connected Components)</title>
    <url>/1091DS-HW8/</url>
    <content><![CDATA[<p>課程名稱：資料結構 CS203 A<br>授課教師：林基成<span id="more"></span><br>發放時間：2020-11-21<br>截止時間：2020-11-28</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>這次的作業是 UVa 中的 5 題題目。三題與 Articulation Points / Bridges 相關，兩題與 Biconnected / Bridge Connected Components 相關。</p>
<p><strong>與 Articulation Points / Bridges 相關</strong></p>
<ul>
<li>UVa - 315 - Network：<a class="lilink" href="../UVa-315/" target="_blank">UVa - 315 解題紀錄</a></li>
<li>UVa - 796 - Critical Links：<a class="lilink" href="../UVa-796/" target="_blank">UVa - 796 解題紀錄</a></li>
<li>UVa - 10765 - Doves and bombs：<a class="lilink" href="../UVa-10765/" target="_blank">UVa - 10765 解題紀錄</a></li>
</ul>
<p><strong>與 Biconnected / Bridge Connected Components 相關</strong></p>
<ul>
<li>UVa - 1108 - Mining Your Own Business：<a class="lilink" href="../UVa-1108/" target="_blank">UVa - 1108 解題紀錄</a></li>
<li>UVa - 10972 - RevolC FaeLoN：<a class="lilink" href="../UVa-10972/" target="_blank">UVa - 10972 解題紀錄</a></li>
</ul>
<p><a href="https://github.com/larrylai19/1091YzuCse/tree/master/DataStructures/HW08"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>1091DataStructures-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>Homework 9 - UVa (Finding Strongly Connected Components)</title>
    <url>/1091DS-HW9/</url>
    <content><![CDATA[<p>課程名稱：資料結構 CS203 A<br>授課教師：林基成<span id="more"></span><br>發放時間：2020-11-26<br>截止時間：2020-12-03</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>這次的作業是 UVa 中的 3 題題目。與 Strongly Connected Components 相關。</p>
<ul>
<li>UVa - 247 - Calling Circles：<a class="lilink" href="../UVa-247/" target="_blank">UVa - 247 解題紀錄</a></li>
<li>UVa - 11504 - Dominos：<a class="lilink" href="../UVa-11504/" target="_blank">UVa - 11504 解題紀錄</a></li>
<li>UVa - 11838 - Come and Go：<a class="lilink" href="../UVa-11838/" target="_blank">UVa - 11838 解題紀錄</a></li>
</ul>
<p><a href="https://github.com/larrylai19/1091YzuCse/tree/master/DataStructures/HW09"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>1091DataStructures-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>Midterm Exam</title>
    <url>/1091DS-MidtermExam/</url>
    <content><![CDATA[<p>課程名稱：資料結構 CS203 A<br>授課教師：林基成<span id="more"></span><br>考試時間：2020-10-18</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>基本上和作業一及作業三一模一樣，但是都有簡化。</p>
<ul>
<li><strong>Midterm1：</strong> 為作業一的簡化，基本上都一樣，但是只需要完成 insert，不需要寫 erase。</li>
<li><strong>Midterm2：</strong> 為作業三的簡化，基本上都一樣，但是 Case 被簡化了許多。</li>
</ul>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>由於跟作業一模一樣，在此不再贅述。</p>
<h3 id="修改內容"><a href="#修改內容" class="headerlink" title="修改內容"></a>修改內容</h3><p>在考試時已經都 0 errors。但是在紅黑樹的 <code>fixUp()</code> 中，忘記老師說只有什麼 Case 了，所以就把全部的 Case 都寫了，還有 insert 的部分 <code>if (n-&gt;myval == val) return;</code> 這一個判斷可能會有 <code>myHead-&gt;myval == val</code> 的情況導致沒有新增 node，修改後為 <code>if (!n-&gt;isNil &amp;&amp; n-&gt;myval == val) return;</code> 即可避免這個問題。</p>
<hr>
<p><a href="https://github.com/larrylai19/1091YzuCse/tree/master/DataStructures/Midterm"><i class="fa fa-download fa-2x"></i></a></p>
<p>裡面有三個資料夾：</p>
<ul>
<li><strong>MidtermExam：</strong> 為題目的原始檔。</li>
<li><strong>Midterm - original：</strong> 考試繳交的版本。</li>
<li><strong>Midterm - fixed：</strong> 修改後的版本。</li>
</ul>
]]></content>
      <categories>
        <category>1091DataStructures-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>Homework 0 - Summation</title>
    <url>/1091LA-HW0/</url>
    <content><![CDATA[<p>課程名稱：線性代數 CS233 B<br>授課教師：簡廷因<span id="more"></span><br>發放時間：2020-09-14<br>截止時間：2020-09-28 23:59:59</p>
<hr>
<p>Get a integer N from parameter, and print the result of 1+2+…+N to STDOUT</p>
<p>0 &lt; N &lt; 65535</p>
<p>Sample input : 10<br>Sample output : 55<br>Sample command : ./tinin.exe 10</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個整數 <code>N</code>，求 1 + 2 + … + N 的值並 cout 出來。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先判斷 <code>argc</code> 是否大於 1，表示至少有一個參數傳入，接著判斷此參數是否 <code>大於 0 且小於 65535</code>。若是的話先使用 <code>atoll()</code> 將字串轉為數字 ( 轉為 long long 避免數值超越 int 的邊界 )，最後使用梯形面積公式算出答案即可。</p>
<p><strong>※</strong> <code>argc</code> 表示傳入參數的數量，<code>char* argv[]</code> 表示傳入的參數。<code>argv[0]</code> 為程式的名稱。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ((argc &gt; <span class="number">1</span> &amp;&amp; atoi(argv[<span class="number">1</span>]) &gt; <span class="number">0</span> &amp;&amp; atoi(argv[<span class="number">1</span>]) &lt; <span class="number">65535</span>) ? (<span class="number">1</span> + atoll(argv[<span class="number">1</span>])) * atoll(argv[<span class="number">1</span>]) / <span class="number">2</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/1091YzuCse/blob/master/LinearAlgebra/HW0/Source.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="備註"><a href="#備註" class="headerlink" title="備註"></a>備註</h3><p>此作業為測試用，不算分。</p>
]]></content>
      <categories>
        <category>1091LinearAlgebra-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>Homework 1 - QRcode Decoder</title>
    <url>/1091LA-HW1/</url>
    <content><![CDATA[<p>課程名稱：線性代數 CS233 B<br>授課教師：簡廷因<span id="more"></span><br>發放時間：2020-10-05<br>截止時間：2020-10-26 23:59:59</p>
<hr>
<p>Get a filename F1 from parameter, and using STDOUT for output</p>
<p>Sample input : case1.bmp<br>Sample output : This is the testing sentence and will convert into a QR-code like photo.<br>Sample command : ./tinin.exe case1.bmp</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 bmp 檔案，由下而上，由左至右，每 8 個像素點代表一組二進位數字 ( 白為 0、黑為 1 )，表示為 Ascii Code，求解碼後的字串。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>bmp 檔案其實就是以二進制檔案來表示圖片的儲存格式，以本次作業的測資來說，前 54 個 byte 為 bmp 的 header，紀錄一些圖片的基本訊息，如：長度、寬度 … 等等。接著就是像素點的訊息，3 個 byte 一組，分別代表一個像素點的 B、G、R，並且由圖片的下而上，左至右。由於題目只需要後面關於像素點的資料，所以使用 <code>seekg()</code> 跳過前面的 54 個 byte，之後使用 <code>while()</code> 及 <code>get()</code> 讀檔，同時做二進位的轉換，直到檔案的最後即可。需要注意的是當讀了 8 個像素點後，字元若為無法顯示的字元，代表句子已經結尾了，同時表示這張圖片已經處理完了。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// no file path</span></span><br><span class="line"></span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(argv[<span class="number">1</span>], ios::binary)</span></span>;</span><br><span class="line">    file.seekg(<span class="number">54</span>, ios::beg); <span class="comment">// avoid header</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// read file and print</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch, tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (file.get(ch).get(ch).get(ch)) <span class="comment">// B, G, R</span></span><br><span class="line">    &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">        tmp = (tmp &lt;&lt; <span class="number">1</span>) + ch + <span class="number">1</span>; <span class="comment">// ch == -1 -&gt; white = 0, ch == 0 -&gt; black = 1</span></span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp &lt; <span class="number">32</span> || tmp &gt; <span class="number">126</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; tmp;</span><br><span class="line">            cnt = tmp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/1091YzuCse/blob/master/LinearAlgebra/HW1/"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>1091LinearAlgebra-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>Homework 2 - Image Rotation</title>
    <url>/1091LA-HW2/</url>
    <content><![CDATA[<p>課程名稱：線性代數 CS233 B<br>授課教師：簡廷因<span id="more"></span><br>發放時間：2020-11-02<br>截止時間：2020-11-30 23:59:59</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一張圖片 ( jpg )，偵測出圖片中最長的直線，逆時針旋轉直到直線垂直於水平線，並將旋轉後多出來的部份塗黑，之後輸出成圖片檔 ( jpg )。</p>
<p><strong><code>本次作業可使用 OpenCV 套件</code></strong></p>
<p><strong>參數設定：</strong></p>
<p>Canny 使用 <code>500，100</code><br>HoughLinesP 使用 <code>1, CV_PI / 180, 250, 200, 10</code></p>
<h3 id="OpenCV-設定"><a href="#OpenCV-設定" class="headerlink" title="OpenCV 設定"></a>OpenCV 設定</h3><p><a href="https://ppt.cc/fdePvx">在Visual Studio 2019上使用OpenCV</a> : 先依照這篇設定，之後會遇到錯誤類似於 <code>LNK1104 無法開啟檔案 &#39;opencv_world401d.lib&#39;</code><br><a href="https://ppt.cc/fda4tx">[圖文] OpenCV 4.0.1 安裝配置在 Visual Studio 2019</a> : 之後再依照這篇設定環境參數即可。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先使用 <code>imread()</code> 讀取圖片，之後使用 <code>Canny()</code> 完成邊緣偵測，再使用 <code>HoughLinesP()</code> 完成霍夫直線判斷，得到圖片中所有直線的陣列，之後遍歷陣列取得最長邊的斜率 ( 長度可使用 <code>norm()</code> 進行計算 )，並算出圖片需要旋轉的角度 ( 在 <code>getSlope()</code> 中 return 的地方，我也不知道為什麼要這樣弄，在網路上找的資料拼拼湊湊弄出來的 )，之後找出圖片的中心點 ( 長度寬度各除以二 )，並使用 <code>getRotationMatrix2D()</code> 找出旋轉矩陣，最後使用 <code>warpAffine()</code> 取得圖片旋轉後的結果並輸出檔案 ( 使用 <code>imwrite()</code> ) 即可。</p>
<p><strong>請先看更新：<a href="#2020-12-01-00-39">點我</a></strong></p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">OpenCV setup</span></span><br><span class="line"><span class="comment">https://ppt.cc/fdePvx : 先依照這篇設定，之後會遇到錯誤類似於 LNK1104 無法開啟檔案 &#x27;opencv_world401d.lib&#x27;</span></span><br><span class="line"><span class="comment">https://ppt.cc/fda4tx : 之後再依照這篇設定環境參數即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Reference:</span></span><br><span class="line"><span class="comment">    霍夫直線檢測: https://ppt.cc/fSXfIx</span></span><br><span class="line"><span class="comment">    計算斜率: https://www.itread01.com/content/1547635163.html</span></span><br><span class="line"><span class="comment">    旋轉圖片: https://www.itread01.com/articles/1476043874.html</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get longest line&#x27;s slope</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getSlope</span><span class="params">(<span class="built_in">vector</span>&lt;Vec4i&gt;&amp; lines)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> _max = <span class="number">0</span>, tmp;</span><br><span class="line">    Vec4i V;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; l : lines)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = norm(Point(l[<span class="number">2</span>], l[<span class="number">3</span>]) - Point(l[<span class="number">0</span>], l[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">if</span> (tmp &gt; _max) _max = tmp, V = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">atan</span>((<span class="keyword">double</span>)(V[<span class="number">3</span>] - V[<span class="number">1</span>]) / (<span class="keyword">double</span>)(V[<span class="number">2</span>] - V[<span class="number">0</span>])) * <span class="number">180</span> / CV_PI + <span class="number">90</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read image</span></span><br><span class="line">    Mat Image = imread(argv[<span class="number">1</span>], <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (Image.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get Canny matrix</span></span><br><span class="line">    Mat canny;</span><br><span class="line">    Canny(Image, canny, <span class="number">500</span>, <span class="number">100</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get hough lines</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Vec4i&gt; Lines;</span><br><span class="line">    HoughLinesP(canny, Lines, <span class="number">1</span>, CV_PI / <span class="number">180</span>, <span class="number">250</span>, <span class="number">200</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> slope = getSlope(Lines);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get center and rotation matrix</span></span><br><span class="line">    Size sz = Image.size();</span><br><span class="line">    <span class="function">Point2f <span class="title">center</span><span class="params">(sz.width / <span class="number">2.</span>, sz.height / <span class="number">2.</span>)</span></span>;</span><br><span class="line">    Mat rotMat = getRotationMatrix2D(center, slope, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rotate</span></span><br><span class="line">    Mat result;</span><br><span class="line">    warpAffine(Image, result, rotMat, sz);</span><br><span class="line"></span><br><span class="line">    imwrite(argv[<span class="number">2</span>], result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fSXfIx">Opencv霍夫直线检测</a><br><a href="https://www.itread01.com/content/1547635163.html">opencv計算直線的斜率、截距，與水平線弧度值、角度值</a><br><a href="https://www.itread01.com/articles/1476043874.html">用OpenCV實現Photoshop算法(一): 圖像旋轉</a></p>
<hr>
<h3 id="2020-12-01-00-39"><a href="#2020-12-01-00-39" class="headerlink" title="2020/12/01 00:39"></a>2020/12/01 00:39</h3><p>老師系統好像出問題，抓錯資料導致測資錯誤，後來系統弄好後只剩 10 分，然後多了一些需要處理的情況。</p>
<p>還有原本是 <strong>逆時針旋轉</strong>，後來改成 <strong>朝最接近垂直線的角度旋轉</strong>。</p>
<ol>
<li><p><strong>修改旋轉角度：</strong> 原本是逆時針旋轉所以 <code>slope</code> 直接加 90，後來加上判斷，若順時針旋轉的角度較小則順時針旋轉，減 90。修改這邊後是 50 分。</p>
</li>
<li><p><strong>彩色圖片：</strong> 原本的測資好像都是黑白的圖片，所以那時候沒有加上轉灰階，新測資的 6 ~ 10 是彩色的圖片，需要轉灰階才能成功偵測。</p>
</li>
</ol>
<p>修改後的 Code：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/types_c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Reference:</span></span><br><span class="line"><span class="comment">	霍夫直線檢測: https://ppt.cc/fSXfIx</span></span><br><span class="line"><span class="comment">	計算斜率: https://www.itread01.com/content/1547635163.html</span></span><br><span class="line"><span class="comment">	旋轉圖片: https://www.itread01.com/articles/1476043874.html</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get longest line&#x27;s slope</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getSlope</span><span class="params">(<span class="built_in">vector</span>&lt;Vec4i&gt;&amp; lines)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> _max = <span class="number">0</span>, tmp;</span><br><span class="line">	Vec4i V;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; l : lines)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp = norm(Point(l[<span class="number">2</span>], l[<span class="number">3</span>]) - Point(l[<span class="number">0</span>], l[<span class="number">1</span>]));</span><br><span class="line">		<span class="keyword">if</span> (tmp &gt; _max) _max = tmp, V = l;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">atan</span>((<span class="keyword">double</span>)(V[<span class="number">3</span>] - V[<span class="number">1</span>]) / (<span class="keyword">double</span>)(V[<span class="number">2</span>] - V[<span class="number">0</span>])) * <span class="number">180</span> / CV_PI;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// read image</span></span><br><span class="line">	Mat Image = imread(argv[<span class="number">1</span>], <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (Image.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 轉成灰階，彩色圖片沒有這一步會錯誤</span></span><br><span class="line">	Mat gray;</span><br><span class="line">	cvtColor(Image, gray, CV_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// get canny matrix</span></span><br><span class="line">	Mat canny;</span><br><span class="line">	Canny(gray, canny, <span class="number">500</span>, <span class="number">100</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// get hough lines</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;Vec4i&gt; Lines;</span><br><span class="line">	HoughLinesP(canny, Lines, <span class="number">1</span>, CV_PI / <span class="number">180</span>, <span class="number">250</span>, <span class="number">200</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> slope = getSlope(Lines);</span><br><span class="line">	slope += (slope &gt; <span class="number">0</span>) ? <span class="number">-90</span> : <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// get center and rotation matrix</span></span><br><span class="line">	Size sz = Image.size();</span><br><span class="line">	<span class="function">Point2f <span class="title">center</span><span class="params">(sz.width / <span class="number">2.</span>, sz.height / <span class="number">2.</span>)</span></span>;</span><br><span class="line">	Mat rotMat = getRotationMatrix2D(center, slope, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// rotate</span></span><br><span class="line">	Mat result;</span><br><span class="line">	warpAffine(Image, result, rotMat, sz);</span><br><span class="line"></span><br><span class="line">	imwrite(argv[<span class="number">2</span>], result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/1091YzuCse/blob/master/LinearAlgebra/HW2/"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>1091LinearAlgebra-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>Homework 3 - FFT</title>
    <url>/1091LA-HW3/</url>
    <content><![CDATA[<p>課程名稱：線性代數 CS233 B<br>授課教師：簡廷因<span id="more"></span><br>發放時間：2020-12-01<br>截止時間：2020-12-22 23:59:59</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一些訊號，求做完傅立葉轉換後的結果。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>我完全不會，我是抄 <a href="https://ppt.cc/f1yLAx">這篇</a> 的。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE(c) int(c.size())</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14159</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reference: https://ppt.cc/f1yLAx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []</span><br><span class="line">&#123;</span><br><span class="line">    ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> real;</span><br><span class="line">    <span class="keyword">double</span> image;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="built_in">string</span>&amp; str)</span></span>; <span class="comment">// 資料分割</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitrp</span><span class="params">()</span></span>;            <span class="comment">// 位反轉置換 Bit-reversal Permutation</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;signal&gt; signals;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Case = <span class="number">0</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">inFile</span><span class="params">(argv[<span class="number">1</span>])</span></span>;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">while</span> (getline(inFile, str))</span><br><span class="line">    &#123;</span><br><span class="line">        signals.clear();</span><br><span class="line">        split(str);</span><br><span class="line">        FFT();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Data &quot;</span> &lt;&lt; ++Case &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [r, i] : signals)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; setprecision(<span class="number">4</span>) &lt;&lt; fixed &lt;&lt; r &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="built_in">string</span>&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (getline(ss, str, <span class="string">&#x27;,&#x27;</span>)) signals.push_back(&#123; stod(str), <span class="number">0</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitrp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; SIZE(signals); i *= <span class="number">2</span>) ++p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE(signals); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = i, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p; ++j) b = b * <span class="number">2</span> + a % <span class="number">2</span>, a /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (b &gt; i) swap(signals[i], signals[b]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;signal&gt; <span class="title">w</span><span class="params">(SIZE(signals))</span></span>;</span><br><span class="line"></span><br><span class="line">    bitrp();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> arg = <span class="number">-2</span> * PI / SIZE(signals);</span><br><span class="line">    <span class="keyword">double</span> treal = <span class="built_in">cos</span>(arg);</span><br><span class="line">    <span class="keyword">double</span> timage = <span class="built_in">sin</span>(arg);</span><br><span class="line">    w[<span class="number">0</span>] = &#123; <span class="number">1.0</span>, <span class="number">0.0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; SIZE(signals) / <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        w[i].real = w[i - <span class="number">1</span>].real * treal - w[i - <span class="number">1</span>].image * timage;</span><br><span class="line">        w[i].image = w[i - <span class="number">1</span>].real * timage + w[i - <span class="number">1</span>].image * treal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">2</span>; m &lt;= SIZE(signals); m *= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; SIZE(signals); k += m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m / <span class="number">2</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> i1 = k + j;</span><br><span class="line">                <span class="keyword">int</span> i2 = i1 + m / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">int</span> t = SIZE(signals) * j / m;</span><br><span class="line">                treal = w[t].real * signals[i2].real - w[t].image * signals[i2].image;</span><br><span class="line">                timage = w[t].real * signals[i2].image + w[t].image * signals[i2].real;</span><br><span class="line">                <span class="keyword">double</span> ureal = signals[i1].real;</span><br><span class="line">                <span class="keyword">double</span> uimage = signals[i1].image;</span><br><span class="line">                signals[i1] = &#123; ureal + treal, uimage + timage &#125;;</span><br><span class="line">                signals[i2] = &#123; ureal - treal, uimage - timage &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/1091YzuCse/blob/master/LinearAlgebra/HW3/"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/f1yLAx">快速傅立葉變換（FFT）的C++實現 -  开发者知识库</a></p>
]]></content>
      <categories>
        <category>1091LinearAlgebra-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>Homework 4 - Distance Measurement</title>
    <url>/1091LA-HW4/</url>
    <content><![CDATA[<p>課程名稱：線性代數 CS233 B<br>授課教師：簡廷因<span id="more"></span><br>發放時間：2020-12-22<br>截止時間：2020-01-19 23:59:59</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>本次的作業是影像測距，給一個固定長度的物體，推算其距離。( 利用 data.jpg 算出焦距後套用至所有的測資檢測 )</p>
<p><strong><code>本次作業可使用 OpenCV 套件</code></strong></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>照著 <a href="https://github.com/larrylai19/1091YzuCse/blob/master/LinearAlgebra/HW4/HW4/HW4.v1.pdf">HW4.v1.pdf</a> 的說明步驟完成即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/types_c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">reference:</span></span><br><span class="line"><span class="comment">findContours ( 尋找輪廓 ): https://ppt.cc/fchOEx</span></span><br><span class="line"><span class="comment">contourArea ( 計算輪廓面積 ): https://ppt.cc/fqIYtx</span></span><br><span class="line"><span class="comment">approxPolyDP ( 逼近邊緣 ): https://ppt.cc/f0FApx</span></span><br><span class="line"><span class="comment">minAreaRect ( 最佳邊框 ): https://ppt.cc/f45Axx</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指定參數</span></span><br><span class="line"><span class="comment">GaussianBlur(matrix, matrix, Size(5, 5), 0);</span></span><br><span class="line"><span class="comment">Canny(matrix, out_ matrix, 35, 125);</span></span><br><span class="line"><span class="comment">findContours(matrix, contours, CV_RETR_LIST, CV_CHAIN_APPROX_SIMPLE);</span></span><br><span class="line"><span class="comment">approxPolyDP(contours, contours_poly, 3, true);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得面積最大的輪廓</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;Point&gt; <span class="title">GetBiggestContours</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Point&gt;&gt;&amp; contours)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Distance</span><span class="params">(Point2f&amp; l, Point2f&amp; r)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat img = imread(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 轉灰階</span></span><br><span class="line">    Mat gray;</span><br><span class="line">    cvtColor(img, gray, CV_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 高斯模糊</span></span><br><span class="line">    Mat Gauss;</span><br><span class="line">    GaussianBlur(gray, Gauss, Size(<span class="number">5</span>, <span class="number">5</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Mat canny;</span><br><span class="line">    Canny(Gauss, canny, <span class="number">35</span>, <span class="number">125</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找輪廓</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Point&gt;&gt; contours; <span class="comment">// contours (n.) 輪廓; 外型; 曲線</span></span><br><span class="line">    findContours(canny, contours, CV_RETR_LIST, CV_CHAIN_APPROX_SIMPLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得面積最大的輪廓</span></span><br><span class="line">    <span class="keyword">auto</span> MaxContours = GetBiggestContours(contours);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逼近邊緣</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Point&gt; contours_poly;</span><br><span class="line">    approxPolyDP(MaxContours, contours_poly, <span class="number">3</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得最佳邊框</span></span><br><span class="line">    <span class="keyword">auto</span> rect = minAreaRect(contours_poly);</span><br><span class="line">    Point2f boxPoints[<span class="number">4</span>];</span><br><span class="line">    rect.points(boxPoints);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 像素寬度</span></span><br><span class="line">    <span class="keyword">auto</span> width = Distance(boxPoints[<span class="number">0</span>], boxPoints[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 焦距 -&gt; 3752.24</span></span><br><span class="line">    <span class="comment">//auto fl = (width * 1500) / 210;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> l = (<span class="number">210</span> * <span class="number">3752.24</span>) / width;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得面積最大的輪廓</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;Point&gt; <span class="title">GetBiggestContours</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Point&gt;&gt;&amp; contours)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Point&gt; biggest;</span><br><span class="line">    <span class="keyword">double</span> _max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : contours)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp = contourArea(v);</span><br><span class="line">        <span class="keyword">if</span> (tmp &gt; _max) _max = tmp, biggest = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> biggest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Distance</span><span class="params">(Point2f&amp; l, Point2f&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> dx = r.x - l.x;</span><br><span class="line">    <span class="keyword">double</span> dy = r.y - l.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/1091YzuCse/blob/master/LinearAlgebra/HW4/"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ppt.cc/fchOEx">findContours 實作（OpenCV）</a><br><a href="https://ppt.cc/fqIYtx">[OpenCV] 計算輪廓面積 (Calculate Contour Area) | 逍遙文工作室</a><br><a href="https://ppt.cc/f0FApx">OpenCV approxPolyDP()函数详解_高祥xiang的博客-CSDN博客</a><br><a href="https://ppt.cc/f45Axx">Opencv獲取最小外接矩形——minAreaRect - IT閱讀</a></p>
]]></content>
      <categories>
        <category>1091LinearAlgebra-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>1092 ALGO Homework 1 - UVa (Dynamic Programming)</title>
    <url>/1092ALGO-HW1/</url>
    <content><![CDATA[<p>課程名稱：演算法概論 CS309 B<br>授課教師：林基成<span id="more"></span><br>發放時間：2021-02-23<br>截止時間：2021-03-02</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>這次的作業是 UVa 中的 3 題題目，與 Dynamic Programming 有關。</p>
<ul>
<li>UVa 10337 - Flight Planner：<a class="lilink" href="../UVa-10337/" target="_blank">UVa - 10337 解題紀錄</a></li>
<li>UVa 10721 - Bar Codes：<a class="lilink" href="../UVa-10721/" target="_blank">UVa - 10721 解題紀錄</a></li>
<li>UVa 10943 - How do you add?：<a class="lilink" href="../UVa-10943/" target="_blank">UVa - 10943 解題紀錄</a></li>
</ul>
]]></content>
      <categories>
        <category>1092IntroductionToAlgorithms-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>1092 ALGO Homework 10 - UVa (Convex Hull)</title>
    <url>/1092ALGO-HW10/</url>
    <content><![CDATA[<p>課程名稱：演算法概論 CS309 B<br>授課教師：林基成<span id="more"></span><br>發放時間：2021-05-11<br>截止時間：2021-05-18</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>這次的作業是 UVa 中的 3 題題目，與 Convex Hull 有關。</p>
<ul>
<li>UVa 681 - Convex Hull Finding：<a class="lilink" href="../UVa-681/" target="_blank">UVa - 681 解題紀錄</a></li>
<li>UVa 1206 - Boundary Points：<a class="lilink" href="../UVa-1206/" target="_blank">UVa - 1206 解題紀錄</a></li>
<li>UVa 11096 - Nails：<a class="lilink" href="../UVa-11096/" target="_blank">UVa - 11096 解題紀錄</a></li>
</ul>
]]></content>
      <categories>
        <category>1092IntroductionToAlgorithms-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>1092 ALGO Homework 12 - UVa (MCMF)</title>
    <url>/1092ALGO-HW12/</url>
    <content><![CDATA[<p>課程名稱：演算法概論 CS309 B<br>授課教師：林基成<span id="more"></span><br>發放時間：2021-05-13<br>截止時間：2021-05-20</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>這次的作業是 UVa 中的 3 題題目，與 Minimum Cost Maximum Flow 有關。</p>
<ul>
<li>UVa 10594 - Data Flow：<a class="lilink" href="../UVa-10594/" target="_blank">UVa - 10594 解題紀錄</a></li>
<li>UVa 10806 - Dijkstra, Dijkstra.：<a class="lilink" href="../UVa-10806/" target="_blank">UVa - 10806 解題紀錄</a></li>
<li>UVa 10888 - Warehouse：<a class="lilink" href="../UVa-10888/" target="_blank">UVa - 10888 解題紀錄</a></li>
</ul>
]]></content>
      <categories>
        <category>1092IntroductionToAlgorithms-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>1092 ALGO Homework 11 - UVa (Closest Pair Problem)</title>
    <url>/1092ALGO-HW11/</url>
    <content><![CDATA[<p>課程名稱：演算法概論 CS309 B<br>授課教師：林基成<span id="more"></span><br>發放時間：2021-05-11<br>截止時間：2021-05-18</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>這次的作業是 UVa 中的 2 題題目，與 Closest Pair Problem 有關。</p>
<ul>
<li>UVa 10245 - The Closest Pair Problem：<a class="lilink" href="../UVa-10245/" target="_blank">UVa - 10245 解題紀錄</a></li>
<li>UVa 11378 - Bey Battle：<a class="lilink" href="../UVa-11378/" target="_blank">UVa - 11378 解題紀錄</a></li>
</ul>
]]></content>
      <categories>
        <category>1092IntroductionToAlgorithms-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>1092 ALGO Homework 2 - UVa (Dynamic Programming)</title>
    <url>/1092ALGO-HW2/</url>
    <content><![CDATA[<p>課程名稱：演算法概論 CS309 B<br>授課教師：林基成<span id="more"></span><br>發放時間：2021-02-27<br>截止時間：2021-03-08</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>這次的作業是 UVa 中的 3 題題目，與 Dynamic Programming 有關。</p>
<ul>
<li>UVa 10003 - Cutting Sticks：<a class="lilink" href="../UVa-10003/" target="_blank">UVa - 10003 解題紀錄</a></li>
<li>UVa 10912 - Simple Minded Hashing：<a class="lilink" href="../UVa-10912/" target="_blank">UVa - 10912 解題紀錄</a></li>
<li>UVa 11420 - Chest of Drawers：<a class="lilink" href="../UVa-11420/" target="_blank">UVa - 11420 解題紀錄</a></li>
</ul>
]]></content>
      <categories>
        <category>1092IntroductionToAlgorithms-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>1092 ALGO Homework 3 - UVa (Dynamic Programming - Longest Increasing Subsequence)</title>
    <url>/1092ALGO-HW3/</url>
    <content><![CDATA[<p>課程名稱：演算法概論 CS309 B<br>授課教師：林基成<span id="more"></span><br>發放時間：2021-03-07<br>截止時間：2021-03-15</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>這次的作業是 UVa 中的 3 題題目，與 Dynamic Programming - Longest Increasing Subsequence 有關。</p>
<ul>
<li>UVa 481 - What Goes Up：<a class="lilink" href="../UVa-481/" target="_blank">UVa - 481 解題紀錄</a></li>
<li>UVa 11456 - Trainsorting：<a class="lilink" href="../UVa-11456/" target="_blank">UVa - 11456 解題紀錄</a></li>
<li>UVa 11790 - Murcia’s Skyline：<a class="lilink" href="../UVa-11790/" target="_blank">UVa - 11790 解題紀錄</a></li>
</ul>
]]></content>
      <categories>
        <category>1092IntroductionToAlgorithms-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>1092 ALGO Homework 4 - UVa (Dynamic Programming - 0-1 Knapsack)</title>
    <url>/1092ALGO-HW4/</url>
    <content><![CDATA[<p>課程名稱：演算法概論 CS309 B<br>授課教師：林基成<span id="more"></span><br>發放時間：2021-03-15<br>截止時間：2021-03-22</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>這次的作業是 UVa 中的 3 題題目，與 Dynamic Programming - 0-1 Knapsack 有關。</p>
<ul>
<li>UVa 1213 - Sum of Different Primes：<a class="lilink" href="../UVa-1213/" target="_blank">UVa - 1213 解題紀錄</a></li>
<li>UVa 10616 - Divisible Group Sums：<a class="lilink" href="../UVa-10616/" target="_blank">UVa - 10616 解題紀錄</a></li>
<li>UVa 11566 - Let’s Yum Cha!：<a class="lilink" href="../UVa-11566/" target="_blank">UVa - 11566 解題紀錄</a></li>
</ul>
]]></content>
      <categories>
        <category>1092IntroductionToAlgorithms-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>1092 ALGO Homework 5 - UVa (Dynamic Programming - Max 2D/3D Range Sum)</title>
    <url>/1092ALGO-HW5/</url>
    <content><![CDATA[<p>課程名稱：演算法概論 CS309 B<br>授課教師：林基成<span id="more"></span><br>發放時間：2021-03-27<br>截止時間：2021-04-03</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>這次的作業是 UVa 中的 3 題題目，與 Dynamic Programming - Max 2D/3D Range Sum 有關。</p>
<ul>
<li>UVa 10827 - Maximum sum on a torus：<a class="lilink" href="../UVa-10827/" target="_blank">UVa - 10827 解題紀錄</a></li>
<li>UVa 11951 - Area：<a class="lilink" href="../UVa-11951/" target="_blank">UVa - 11951 解題紀錄</a></li>
<li>UVa 10755 - Garbage Heap：<a class="lilink" href="../UVa-10755/" target="_blank">UVa - 10755 解題紀錄</a></li>
</ul>
]]></content>
      <categories>
        <category>1092IntroductionToAlgorithms-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>1092 ALGO Homework 6 - UVa (Dynamic Programming - Floyd Warshall’s Algorithm)</title>
    <url>/1092ALGO-HW6/</url>
    <content><![CDATA[<p>課程名稱：演算法概論 CS309 B<br>授課教師：林基成<span id="more"></span><br>發放時間：2021-04-01<br>截止時間：2021-04-08</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>這次的作業是 UVa 中的 3 題題目，與 Dynamic Programming - Floyd Warshall’s Algorithm 有關。</p>
<ul>
<li>UVa 821 - Page Hopping：<a class="lilink" href="../UVa-821/" target="_blank">UVa - 821 解題紀錄</a></li>
<li>UVa UVa - 10171 - Meeting Prof. Miguel…：<a class="lilink" href="../UVa-10171/" target="_blank">UVa - 10171 解題紀錄</a></li>
<li>UVa 11463 - Commandos：<a class="lilink" href="../UVa-11463/" target="_blank">UVa - 11463 解題紀錄</a></li>
</ul>
]]></content>
      <categories>
        <category>1092IntroductionToAlgorithms-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>1092 ALGO Homework 7 - UVa (Dynamic Programming - Coin Change)</title>
    <url>/1092ALGO-HW7/</url>
    <content><![CDATA[<p>課程名稱：演算法概論 CS309 B<br>授課教師：林基成<span id="more"></span><br>發放時間：2021-04-04<br>截止時間：2021-04-09</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>這次的作業是 UVa 中的 3 題題目，與 Dynamic Programming - Coin Change 有關。</p>
<ul>
<li>UVa 357 - Let Me Count The Ways：<a class="lilink" href="../UVa-357/" target="_blank">UVa - 357 解題紀錄</a></li>
<li>UVa 10306 - e-Coins：<a class="lilink" href="../UVa-10306/" target="_blank">UVa - 10306 解題紀錄</a></li>
<li>UVa 11517 - Exact Change：<a class="lilink" href="../UVa-11517/" target="_blank">UVa - 11517 解題紀錄</a></li>
</ul>
]]></content>
      <categories>
        <category>1092IntroductionToAlgorithms-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>1092 ALGO Homework 8 - UVa (Maximum Flow)</title>
    <url>/1092ALGO-HW8/</url>
    <content><![CDATA[<p>課程名稱：演算法概論 CS309 B<br>授課教師：林基成<span id="more"></span><br>發放時間：2021-04-24<br>截止時間：2021-05-03</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>這次的作業是 UVa 中的 3 題題目，與 Maximum Flow 有關。</p>
<ul>
<li>UVa 820 - Internet Bandwidth：<a class="lilink" href="../UVa-820/" target="_blank">UVa - 820 解題紀錄</a></li>
<li>UVa 11418 - Clever Naming Patterns：<a class="lilink" href="../UVa-11418/" target="_blank">UVa - 11418 解題紀錄</a></li>
<li>UVa 12873 - The Programmers：<a class="lilink" href="../UVa-12873/" target="_blank">UVa - 12873 解題紀錄</a></li>
</ul>
]]></content>
      <categories>
        <category>1092IntroductionToAlgorithms-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>1092 ALGO Homework 9 - UVa (Maximum Flow)</title>
    <url>/1092ALGO-HW9/</url>
    <content><![CDATA[<p>課程名稱：演算法概論 CS309 B<br>授課教師：林基成<span id="more"></span><br>發放時間：2021-05-03<br>截止時間：2021-05-10</p>
<hr>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>這次的作業是 UVa 中的 4 題題目，與 Maximum Flow 有關。</p>
<ul>
<li>UVa 10330 - Power Transmission：<a class="lilink" href="../UVa-10330/" target="_blank">UVa - 10330 解題紀錄</a></li>
<li>UVa 11380 - Down Went The Titanic：<a class="lilink" href="../UVa-11380/" target="_blank">UVa - 11380 解題紀錄</a></li>
<li>UVa 11506 - Angry Programmer：<a class="lilink" href="../UVa-11506/" target="_blank">UVa - 11506 解題紀錄</a></li>
<li>UVa 12125 - March of the Penguins：<a class="lilink" href="../UVa-12125/" target="_blank">UVa - 12125 解題紀錄</a></li>
</ul>
]]></content>
      <categories>
        <category>1092IntroductionToAlgorithms-YzuCse</category>
      </categories>
  </entry>
  <entry>
    <title>C++ Vector 介紹</title>
    <url>/C++_Vector_Introduce/</url>
    <content><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>Vector 是 STL 內含的一個容器，空間不夠時會自動擴大空間，可以想像成是一個提供許多功能的陣列，它的內部結構其實就是一個動態陣列及其他一些 Data Members 形成的，有許多 Functions 可以使用，非常方便。</p>
<span id="more"></span>

<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><p>使用前需要先 <code>#include &lt;vector&gt;</code></p>
<h3 id="變數宣告"><a href="#變數宣告" class="headerlink" title="變數宣告"></a>變數宣告</h3><ul>
<li><p><code>Vector &lt;Variable type&gt; name</code><br>  Variable type：變數型態，如 int, unsigned int, short, char …等等，也可以是自己定義的 Struct 或 Class。</p>
</li>
<li><p><code>Vector &lt;Variable type&gt; name(i)</code><br>  建構內含 i 個初始值元素的 Vector。</p>
</li>
</ul>
<h2 id="成員函式"><a href="#成員函式" class="headerlink" title="成員函式"></a>成員函式</h2><ul>
<li><h3 id="新增與刪除元素"><a href="#新增與刪除元素" class="headerlink" title="新增與刪除元素"></a>新增與刪除元素</h3><ul>
<li><code>push_back(value)</code>：新增一個值為 value 的元素到 Vector 的尾端。 當空間不夠時會自己擴大空間。 </li>
<li><code>insert(pos, value)</code>：新增一個值為 value 的元素到 pos 的前方。</li>
<li><code>insert(pos, num, value)</code>：新增 num 個值為 value 的元素到 pos 的前方。</li>
<li><code>erase(pos)</code>：刪除位於 pos 的一個元素。</li>
<li><code>erase(begin, end)</code>：刪除位於 begin 到 end 之間 ( 不包括 end ) 的所有元素。</li>
<li><code>clear()</code>: 刪除所有元素。</li>
</ul>
<hr>
</li>
<li><h3 id="存取元素"><a href="#存取元素" class="headerlink" title="存取元素"></a>存取元素</h3><ul>
<li><code>[i]</code>：存取第 i 個元素。( 從 0 開始 )</li>
<li><code>at(i)</code>：存取第 i 個元素 ( 從 0 開始 ) 與上一個的差別在於這種使用這種方式存取會檢查 i 的範圍，大家可以嘗試一下兩者存取超過範圍的元素的差別。</li>
<li><code>front()</code>：回傳位於 Vector 的第一個元素。</li>
<li><code>back()</code>：回傳位於 Vector 的最後一個元素。</li>
</ul>
<hr>
</li>
<li><h3 id="取得長度-容量"><a href="#取得長度-容量" class="headerlink" title="取得長度 / 容量"></a>取得長度 / 容量</h3><ul>
<li><code>size()</code>：取得目前 Vector 內的元素個數。</li>
<li><code>capacity()</code>：取得目前 Vector 內動態陣列的大小，通常不會使用到。</li>
<li><code>empty()</code>：當 Vector 是空的時候 ( Size 為 0 ) 回傳 <code>True</code> 反之則回傳 <code>False</code>。</li>
</ul>
<hr>
</li>
<li><h3 id="修改長度-容量"><a href="#修改長度-容量" class="headerlink" title="修改長度 / 容量"></a>修改長度 / 容量</h3><ul>
<li><code>resize(i)</code>：修改 Vector 內的元素個數。( 當 i &lt; 原本的 Size 時，多出來的元素會被清除，當 i &gt; 原本的 Size 時，新增元素的值為初始值 )</li>
<li><code>reserve()</code>：修改 Vector 內動態陣列的大小 ( 只能變大不能縮小 )，通常不會使用到。</li>
</ul>
</li>
</ul>
<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><ul>
<li><code>begin()</code>：回傳一個指向 Vector 內第一個元素位置的 Iterator。</li>
<li><code>end()</code>：回傳一個指向 Vector 內最後一個元素後面位置的 Iterator。( 注意不是最後一個元素 )  </li>
<li><code>rbegin()</code>：回傳一個指向 Vector 內最後一個元素位置的反向 Iterator。</li>
<li><code>rend()</code>：回傳一個指向 Vector 內第一個元素位置的反向 Iterator。</li>
</ul>
<h2 id="補充"><a href="#補充" class="headerlink" title="補充"></a>補充</h2><p>Size ( 長度 ) 與 Capacity ( 容量 ) 的差別：Size 代表的是這個陣列裡面放置的元素數量，而 Capacity 則是代表這個陣列的大小。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *Vec = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]();</span><br><span class="line"></span><br><span class="line">Vec[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">Vec[<span class="number">1</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>此時 Vector 的 Size 就是 2，而 Capacity 就是 5。Size 可以擴大也能縮小，但 Capacity 只能擴大無法縮小。一般在使用 Vector 時只須注意 Size 即可，因為當 Capacity 不夠需要擴大時 Vector 會自動幫我們擴大。</p>
<h2 id="簡單實作"><a href="#簡單實作" class="headerlink" title="簡單實作"></a>簡單實作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt;&amp; Vec)</span> <span class="comment">// 印出 Vector 內的所有元素及 Vector 的 Size</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Vector 內的元素: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; Vec.size(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Vec[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;Vector 的 Size : &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Vec.size();</span><br><span class="line">    <span class="keyword">if</span> (Vec.empty())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;Vector.empty() : True&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;Vector.empty() : False&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Vec;</span><br><span class="line"></span><br><span class="line">    Vec.push_back(<span class="number">2</span>);</span><br><span class="line">    Vec.push_back(<span class="number">1</span>);</span><br><span class="line">    output(Vec);</span><br><span class="line">    <span class="comment">// 2 1</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// False</span></span><br><span class="line"></span><br><span class="line">    Vec.insert(Vec.begin(), <span class="number">3</span>);</span><br><span class="line">    output(Vec);</span><br><span class="line">    <span class="comment">// 3 2 1</span></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// False</span></span><br><span class="line"></span><br><span class="line">    Vec.insert(Vec.begin(), <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    output(Vec);</span><br><span class="line">    <span class="comment">// 4 4 3 2 1</span></span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">    <span class="comment">// False</span></span><br><span class="line"></span><br><span class="line">    Vec.erase(Vec.begin() + <span class="number">2</span>);</span><br><span class="line">    output(Vec);</span><br><span class="line">    <span class="comment">// 4 4 2 1</span></span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="comment">// False</span></span><br><span class="line"></span><br><span class="line">    Vec.erase(Vec.begin(), Vec.begin() + <span class="number">2</span>);</span><br><span class="line">    output(Vec);</span><br><span class="line">    <span class="comment">// 2 1</span></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="comment">// False</span></span><br><span class="line"></span><br><span class="line">    Vec.clear();</span><br><span class="line">    output(Vec);</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 0</span></span><br><span class="line">    <span class="comment">// True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        Vec.push_back(i);</span><br><span class="line">    output(Vec);</span><br><span class="line">    <span class="comment">// 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">    <span class="comment">// 9</span></span><br><span class="line">    <span class="comment">// False</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Vector.front(): &quot;</span>&lt;&lt; Vec.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Vector.back(): &quot;</span> &lt;&lt; Vec.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 9</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Vector[1]: &quot;</span> &lt;&lt; Vec[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Vector.at(1): &quot;</span> &lt;&lt; Vec.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    Vec.resize(<span class="number">5</span>);</span><br><span class="line">    output(Vec);</span><br><span class="line">    <span class="comment">// 1 2 3 4 5</span></span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">    <span class="comment">// False</span></span><br><span class="line"></span><br><span class="line">    Vec.resize(<span class="number">9</span>);</span><br><span class="line">    output(Vec);</span><br><span class="line">    <span class="comment">// 1 2 3 4 5 0 0 0 0</span></span><br><span class="line">    <span class="comment">// 9</span></span><br><span class="line">    <span class="comment">// False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt;::iterator it = Vec.begin(); it != Vec.end(); ++it)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 1 2 3 4 5 0 0 0 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt;::reverse_iterator it = Vec.rbegin(); it != Vec.rend(); ++it)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 0 0 0 0 5 4 3 2 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/Vector/Vector%20example%20code.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="http://www.cplusplus.com/reference/vector/">&lt;vector&gt; - C++ Reference</a><br><a href="https://mropengate.blogspot.com/2015/07/cc-vector-stl.html">C/C++ - Vector (STL) 用法與心得完全攻略</a><br><a href="https://dangerlover9403.pixnet.net/blog/post/98733652-%5B%E6%95%99%E5%AD%B8%5Dc++-vector%E8%A9%B3%E7%B4%B0%E7%94%A8%E6%B3%95">[教學]C++ Vector 詳細用法</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
        <tag>容器</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>XOR 位元運算介紹</title>
    <url>/Bitwise-XOR/</url>
    <content><![CDATA[<h3 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h3><p>XOR 的中文是互斥或的意思，它是一種位元運算子，會單獨對每個位元進行運算，在程式語言中寫作 <code>a ^ b</code>。詳細介紹可參考：<a href="https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E5%BC%82%E6%88%96">Wiki</a></p>
<span id="more"></span>

<h3 id="真值表"><a href="#真值表" class="headerlink" title="真值表"></a>真值表</h3><p>XOR 簡單來說就是兩者相同為 0，不同為 1。</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">輸出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>XOR 會有以下幾種特性：</p>
<ul>
<li><code>A ^ 0 = A</code><br>若 A 為 0，0 ^ 0 = 0，若 A 為 1，1 ^ 0 = 1。</li>
<li><code>A ^ A = 0</code><br>若 A 為 0，0 ^ 0 = 0，若 A 為 1，1 ^ 1 = 0。</li>
<li><code>A ^ B = B ^ A</code><br>若 A 為 0，B 為 0，0 ^ 0 = 0 ^ 0 = 0。<br>若 A 為 0，B 為 1，0 ^ 1 = 1 ^ 0 = 1。<br>若 A 為 1，B 為 0，1 ^ 0 = 0 ^ 1 = 1。</li>
</ul>
<p>上面這些都是以位元為單位來運算的，但其實對於十進位的數字也是通用的，有興趣的可以自己把十進位的數字轉為二進位來做就會明白了。</p>
<h3 id="實際應用"><a href="#實際應用" class="headerlink" title="實際應用"></a>實際應用</h3><p><a href="https://leetcode.com/problems/single-number/">LeetCode - 136</a> 就是一個經典的 XOR 題目，詳細解法可參考本篇文章：<a href="../LeetCode%20-%20136/" target="_blank">LeeCode - 136 解題紀錄</a>。</p>
]]></content>
      <categories>
        <category>Bitwise</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Bitwise</tag>
        <tag>XOR</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ LeetCode I/O 加速</title>
    <url>/C++_Fast_IO/</url>
    <content><![CDATA[<p>當我們在用 C++ 解 LeetCode 的題目時，如果你覺得你的演算法已經很極致了，但是時間卻還是比別人慢，<span id="more"></span>這時可能就是因為測資比較龐大，導致 I/O 需要花比較多的時間。而使用 C++ 解題的話，預設會使用 <code>cin</code> 來做測資的輸入，但是在使用 <code>cin/cout</code> 時，由於緩存及一些其他的問題，速度會比 <code>scanf/printf</code> 來的慢，所以如果是在程式競賽的時候，通常我們會使用 <code>scanf/printf</code> 來代替 <code>cin/cout</code>。但是在做 LeetCode 的題目時，LeetCode 會自動幫我們輸入測資，而它輸入的方法就是使用 <code>cin</code>，所以我們可以自己添加以下代碼，使得 <code>cin/cout</code> 的速度能和 <code>scanf/printf</code> 一樣快。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>只要把它添加在最前面即可，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findJudge</span><span class="params">(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; trust)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>至於原理的話我現在也還不是很懂，等以後懂了再來補唄。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>加速</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 檔案下載</title>
    <url>/C++_File_Downloader/</url>
    <content><![CDATA[<h3 id="用處"><a href="#用處" class="headerlink" title="用處"></a>用處</h3><p>當我們完成一支程式發布出去時，我們可能會希望後續還能夠控制這支程式。例如使程式失效、更新等等…，<span id="more"></span>這時我們就可以透過下載檔案並讀取檔案內容，再根據讀取到的內容做出對應的操作。</p>
<h3 id="實現方法"><a href="#實現方法" class="headerlink" title="實現方法"></a>實現方法</h3><p>需要引入以下的頭文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;urlmon.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;urlmon.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<p>只需使用一行 code 即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HRESULT hr = URLDownloadToFile(<span class="literal">NULL</span>, _T(<span class="string">&quot;檔案下載路徑&quot;</span>), _T(<span class="string">&quot;檔案儲存路徑&quot;</span>), <span class="number">0</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<h3 id="簡單實作"><a href="#簡單實作" class="headerlink" title="簡單實作"></a>簡單實作</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;urlmon.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;urlmon.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> test[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Downloading file...&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    HRESULT hr = URLDownloadToFile(<span class="literal">NULL</span>, _T(<span class="string">&quot;https://www.larrysprognotes.com/DownloadTest.dat&quot;</span>), _T(<span class="string">&quot;DownloadTest.dat&quot;</span>), <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Done!&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;DownloadTest.dat&quot;</span>, ios::binary)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (in.read((<span class="keyword">char</span>*)&amp;test, <span class="keyword">sizeof</span>(test)))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; test;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/Others/C%2B%2Bdownloadfile.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://www.pupuliao.info/2014/05/cc-%E7%B0%A1%E6%98%93%E6%AA%94%E6%A1%88%E4%B8%8B%E8%BC%89/">C/C++ 簡易檔案下載</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>檔案</tag>
        <tag>下載</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ String 介紹</title>
    <url>/C++_String_Introduce/</url>
    <content><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>String 是 STL 內含的一個容器，專門用來放字符，有許多方便的字串操作。可以想像成它是一個強化版的 Vector<char>，其實他們的構造也非常像，核心都是使用動態陣列存放資料。<span id="more"></span>它除了擁有和 Vector 相似的特性外，還加載了許多 Operator。因為之前介紹過 Vector 了，所以本篇會著重在介紹其他的功能，Vector 能使用的函式 String 大部分都能使用，想了解的可以參考本篇文章：<a href="../C++%20Vector%20介紹/" target="_blank">C++ Vector 介紹</a>。</p>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><p>使用前需要先 <code>#include &lt;string&gt;</code></p>
<h3 id="變數宣告"><a href="#變數宣告" class="headerlink" title="變數宣告"></a>變數宣告</h3><ul>
<li><p><code>string name</code><br>  建立一個空的 String。</p>
</li>
<li><p><code>string name(str)</code><br>  建立一個內容與 str 相同的 String。</p>
</li>
</ul>
<h2 id="成員函式"><a href="#成員函式" class="headerlink" title="成員函式"></a>成員函式</h2><ul>
<li><code>str1 = str2</code>：將 str2 的內容放進 str1。</li>
<li><code>str1 += str2</code>：將 str2 接在 str1 後。</li>
<li><code>str1 == str2</code>：若 str1 的內容和 str2 相等則回傳 <code>True</code>，反之則回傳 <code>False</code>。</li>
<li><code>str1.find(str2)</code>：在 str1 內尋找 str2 並回傳第一個字符位置的值。</li>
<li><code>str1.find_first_of(str2)</code>：在 str1 內從頭尋找 str2 內的字符並回傳第一個字符位置的值。</li>
<li><code>str1.find_last_of(str2)</code>：在 str1 內從尾尋找 str2 內的字符並回傳第一個字符位置的值。</li>
<li><code>str1.find_first_not_of(str2)</code>：在 str1 內從頭尋找不在 str2 內的字符並回傳第一個字符位置的值。</li>
<li><code>str1.find_last_not_of(str2)</code>：在 str1 內從尾尋找不在 str2 內的字符並回傳第一個字符位置的值。</li>
</ul>
<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><ul>
<li><code>begin()</code>：回傳一個指向 String 內第一個元素位置的 Iterator。</li>
<li><code>end()</code>：回傳一個指向 String 內最後一個元素後面位置的 Iterator。( 注意不是最後一個元素 )  </li>
<li><code>rbegin()</code>：回傳一個指向 String 內最後一個元素位置的反向 Iterator。</li>
<li><code>rend()</code>：回傳一個指向 String 內第一個元素位置的反向 Iterator。</li>
</ul>
<h2 id="簡單實作"><a href="#簡單實作" class="headerlink" title="簡單實作"></a>簡單實作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">string</span>&amp; str1, <span class="built_in">string</span>&amp; str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1: &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str2: &quot;</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">equal</span><span class="params">(<span class="built_in">string</span>&amp; str1, <span class="built_in">string</span>&amp; str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 == str2: &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (str1 == str2)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;True&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;False&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1, str2;</span><br><span class="line"></span><br><span class="line">    str1 = <span class="string">&quot;string 1&quot;</span>;</span><br><span class="line">    str2 = <span class="string">&quot;string 2&quot;</span>;</span><br><span class="line">    print(str1, str2);</span><br><span class="line">    <span class="comment">// str1: string 1</span></span><br><span class="line">    <span class="comment">// str2: string 2</span></span><br><span class="line"></span><br><span class="line">    str1 += str2;</span><br><span class="line">    print(str1, str2);</span><br><span class="line">    <span class="comment">// str1: string 1string 2</span></span><br><span class="line">    <span class="comment">// str2: string 2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;在 str1 內尋找 str2: &quot;</span> &lt;&lt; str1.find(str2) &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    equal(str1, str2);</span><br><span class="line">    <span class="comment">// str1 == str2: False</span></span><br><span class="line">    str1 = str2;</span><br><span class="line">    equal(str1, str2);</span><br><span class="line">    <span class="comment">// str1 == str2: True</span></span><br><span class="line"></span><br><span class="line">    str1 = <span class="string">&quot;strings&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1: &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;在 str1 內從頭尋找字符為 s 的位置: &quot;</span> &lt;&lt; str1.find_first_of(<span class="string">&quot;s&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 在 str1 內從頭尋找字符為 s 的位置: 0</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;在 str1 內從尾尋找字符為 s 的位置: &quot;</span> &lt;&lt; str1.find_last_of(<span class="string">&quot;s&quot;</span>) &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 在 str1 內從尾尋找字符為 s 的位置: 6</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;在 str1 內從頭尋找字符不為 s 的位置: &quot;</span> &lt;&lt; str1.find_first_not_of(<span class="string">&quot;s&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 在 str1 內從頭尋找字符不為 s 的位置: 1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;在 str1 內從尾尋找字符不為 s 的位置: &quot;</span> &lt;&lt; str1.find_last_not_of(<span class="string">&quot;s&quot;</span>) &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 在 str1 內從尾尋找字符不為 s 的位置: 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/String/String%20example%20code.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="http://www.cplusplus.com/reference/string/string/">string - C++ Reference</a><br><a href="https://mropengate.blogspot.com/2015/07/cc-string-stl.html">C/C++ - String 用法與心得完全攻略</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>容器</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>透過 XOR 進行簡易加密</title>
    <url>/encrypt/</url>
    <content><![CDATA[<h3 id="紀錄"><a href="#紀錄" class="headerlink" title="紀錄"></a>紀錄</h3><p>使用 XOR 進行簡易加密，目前進行 2 次 XOR 運算 ( 太多次中文字會出錯 )</p>
<h3 id="作法"><a href="#作法" class="headerlink" title="作法"></a>作法</h3><ul>
<li>加密：隨機產生兩個數字，並將內容對這兩個數字做 XOR，最後這兩個數字對 9 做一次 XOR 並儲存在第一行</li>
<li>解密：先讀取第一行並對 9 做一次 XOR 可以得到兩個加密的數字，再將內容對這兩個數字做 XOR 並儲存即可</li>
</ul>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>將要加密或解密的文字放在 data.txt 裡</p>
<ul>
<li>加密：執行完成後會產生 encrypted.txt，裡面即是加密後的內容</li>
<li>解密：執行完成後會產生 decrypted.txt，裡面即是加密後的內容</li>
</ul>
<h3 id="已知-Bug"><a href="#已知-Bug" class="headerlink" title="已知 Bug"></a>已知 Bug</h3><ul>
<li>中文字有時會出錯 ( 變成其他文字或符號 )</li>
<li>符號有時會出錯 ( 會不見 )</li>
</ul>
<h3 id="努力方向"><a href="#努力方向" class="headerlink" title="努力方向"></a>努力方向</h3><ul>
<li>解決掉上面的 Bug</li>
<li>讓程式更有效率 ( 目前太多迴圈 )</li>
</ul>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><p>2020-07-08 第一版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> encryptTimes 2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readFile</span><span class="params">(<span class="built_in">vector</span>&lt; <span class="built_in">string</span> &gt;&amp; data)</span></span>;                      <span class="comment">// 讀取 data.txt</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">produceCode</span><span class="params">(<span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt;&amp; code)</span></span>;                      <span class="comment">// 產生加密的數字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveCode</span><span class="params">(<span class="built_in">vector</span>&lt; <span class="built_in">string</span> &gt;&amp; data, <span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt;&amp; code)</span></span>; <span class="comment">// 轉換</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(<span class="built_in">vector</span>&lt; <span class="built_in">string</span> &gt;&amp; data, <span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt;&amp; code)</span></span>;  <span class="comment">// 將加密的數字轉換並存在第一行</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> choice;</span><br><span class="line">    <span class="built_in">string</span> temp;</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt; code;</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">string</span> &gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Welcome! Input 1 to encrypt, 2 to decrypt: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (choice == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        readFile(data);                    <span class="comment">// 讀取 data.txt</span></span><br><span class="line">        produceCode(code);                 <span class="comment">// 產生加密的數字</span></span><br><span class="line">        convert(data, code);               <span class="comment">// 轉換</span></span><br><span class="line">        saveCode(data, code);              <span class="comment">// 將加密的數字轉換並存在第一行</span></span><br><span class="line"></span><br><span class="line">        <span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;encrypted.txt&quot;</span>)</span></span>; <span class="comment">// 輸出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : data)</span><br><span class="line">            outFile &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;encrypt completed.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (choice == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        readFile(data);                    <span class="comment">// 讀取 data.txt</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> readcode = data[<span class="number">0</span>];         <span class="comment">// 第一行為加密的數字</span></span><br><span class="line">        data.erase(data.begin());          <span class="comment">// 刪除掉第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : readcode)           <span class="comment">// 將第一行轉換</span></span><br><span class="line">            code.push_back((i ^ <span class="number">9</span>) - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        convert(data, code);               <span class="comment">// 轉換</span></span><br><span class="line">        <span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;decrypted.txt&quot;</span>)</span></span>; <span class="comment">// 輸出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : data)</span><br><span class="line">            outFile &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;decrypt completed.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readFile</span><span class="params">(<span class="built_in">vector</span>&lt; <span class="built_in">string</span> &gt;&amp; data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> temp;</span><br><span class="line">    <span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!inFile)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;There is no file.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (getline(inFile, temp))</span><br><span class="line">        data.push_back(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">produceCode</span><span class="params">(<span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt;&amp; code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">int</span> codetemp;</span><br><span class="line">    <span class="keyword">while</span> (code.size() &lt; encryptTimes)</span><br><span class="line">    &#123;</span><br><span class="line">        codetemp = rand() % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = find(code.begin(), code.end(), codetemp);</span><br><span class="line">        <span class="keyword">if</span> (it == code.end())</span><br><span class="line">            code.push_back(codetemp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveCode</span><span class="params">(<span class="built_in">vector</span>&lt; <span class="built_in">string</span> &gt;&amp; data, <span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt;&amp; code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> savecode;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : code)</span><br><span class="line">        savecode.push_back((<span class="string">&#x27;a&#x27;</span> + i) ^ <span class="number">9</span>);</span><br><span class="line">    data.insert(data.begin(), savecode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(<span class="built_in">vector</span>&lt; <span class="built_in">string</span> &gt;&amp; data, <span class="built_in">vector</span>&lt; <span class="keyword">int</span> &gt;&amp; code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : data)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; j : i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; k : code)</span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">32</span>)</span><br><span class="line">                    j ^= k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode - 1 解題紀錄</title>
    <url>/LeetCode-1/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/two-sum/">LeetCode - 1. Two Sum</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列和一個 <code>target</code>，找出陣列中兩數相加等於 <code>target</code> 的 <code>index</code>。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 <code>unordered_map&lt;int, int&gt;</code> 存放資料，key 存放 nums 裡面的元素的值，value 存放該值的 <code>index</code>。當每次訪問 nums 的元素時，若 <code>target - nums[i]</code> 的值在 map 中有出現表示找到答案，即為 <code>map[target - nums[i]]</code> 和 <code>i</code>，若沒出現則將 <code>&#123;nums[i]], i&#125;</code> 插入 map。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.count(target - nums[i])) <span class="keyword">return</span> &#123; m[target - nums[i]], i &#125;;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/1.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Unordered_map</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 1022 解題紀錄 / September LeetCoding Challenge Day 8</title>
    <url>/LeetCode-1022/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/">LeetCode - 1022. Sum of Root To Leaf Binary Numbers</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 Binary Tree，從樹根到每片葉子中間包含的數字代表一串二進位的數字，求轉為十進位後的總和。</p>
<span id="more"></span>

<p>類似題目：<a href="../LeetCode%20-%20129/" target="_blank">LeetCode - 129 解題紀錄</a></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用遞迴的概念遍歷整棵樹，<code>sum</code> 紀錄到目前的十進位總和，若是目前的 <code>node</code> 已經是葉子，直接回傳 <code>sum</code>，否則回傳 <code>sumRootToLeaf(root-&gt;left, sum) + sumRootToLeaf(root-&gt;right, sum)</code>。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRootToLeaf</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum = <span class="number">0</span>)</span> <span class="comment">// add sum</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sum = sum * <span class="number">2</span> + root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> !root-&gt;left &amp;&amp; !root-&gt;right ? sum : sumRootToLeaf(root-&gt;left, sum) + sumRootToLeaf(root-&gt;right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/1022.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Recursive</tag>
        <tag>Tree</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
        <tag>LeetCode 30 September</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 104 解題紀錄</title>
    <url>/LeetCode-104/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">LeetCode - 104. Maximum Depth of Binary Tree</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 Tree，找出它的最深深度。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>利用遞迴的概念，每個節點的最深深度為 <code>左邊node 的最深深度 + 1</code> 或是 <code>右邊 node 的最深深度 + 1</code>，終止條件為 <code>root == nullptr</code> 的時候。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/104.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Recursive</tag>
        <tag>Tree</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 1046 解題紀錄</title>
    <url>/LeetCode-1046/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/last-stone-weight/">LeetCode - 1046. Last Stone Weight</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列，每次找出最大及次大的值，若是兩者相同則消除，否則消除小的，而大的值改為兩者相減。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><ul>
<li><p><strong>解法一：</strong>每次都從陣列中取出最大及次大的值，並同時將陣列該位置的值改為 0。使用 pair 儲存，first 放值，second 放 <code>index</code>。</p>
</li>
<li><p><strong>解法二：</strong>使用 <code>priority queue</code>。</p>
</li>
</ul>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><p>解法一：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    pair&lt;int, int&gt; findMax(vector&lt;int&gt;&amp; stones)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; max;</span><br><span class="line">        max = &#123;stones[<span class="number">0</span>], <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; stones.size(); ++i)</span><br><span class="line">            <span class="keyword">if</span>(stones[i] &gt; max.first)</span><br><span class="line">                max = &#123;stones[i], i&#125;;</span><br><span class="line">        stones[max.second] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; x, y;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            y = findMax(stones);</span><br><span class="line">            x = findMax(stones);</span><br><span class="line">            <span class="keyword">if</span>(y != x)</span><br><span class="line">                stones[y.second] = y.first - x.first;</span><br><span class="line">        &#125;<span class="keyword">while</span>(x.first != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> y.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/1046-1.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<p>解法二：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y, x;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; maxheap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : stones)</span><br><span class="line">            maxheap.push(i);</span><br><span class="line">        <span class="keyword">while</span>(maxheap.size() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            y = maxheap.top();</span><br><span class="line">            maxheap.pop();</span><br><span class="line">            x = maxheap.top();</span><br><span class="line">            maxheap.pop();</span><br><span class="line">            <span class="keyword">if</span>(y != x)</span><br><span class="line">                maxheap.push(y - x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxheap.empty() ? <span class="number">0</span> : maxheap.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/1046-2.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Priority_queue</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 1103 解題紀錄 / August LeetCoding Challenge Day 17</title>
    <url>/LeetCode-1103/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/distribute-candies-to-people/">LeetCode - 1103. Distribute Candies to People</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個整數，<code>candies</code> 表示糖果的數量，<code>num_people</code> 表示糖果要分給的人數。<span id="more"></span>分糖果的規則為</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">num_people =  <span class="number">4</span></span><br><span class="line">candies    = <span class="number">40</span></span><br><span class="line">     i:   <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line">people:   <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span></span><br><span class="line">----------------------</span><br><span class="line">round <span class="number">1</span>   <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>      每個人分到的糖果數： i + <span class="number">1</span> + <span class="number">0</span> * num_people</span><br><span class="line">round <span class="number">2</span>   <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>      每個人分到的糖果數： i + <span class="number">1</span> + <span class="number">1</span> * num_people</span><br><span class="line">round <span class="number">3</span>   <span class="number">4</span>               每個人分到的糖果數： i + <span class="number">1</span> + <span class="number">2</span> * num_people 當糖果數量不夠時就全部給當前的那個人即可</span><br><span class="line">----------------------</span><br><span class="line">         <span class="number">10</span>  <span class="number">8</span> <span class="number">10</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>回傳一個代表每個人收到糖果數量的陣列。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>可以直接模擬每次發放糖果的情況，但是效率較低，我們可以使用等差數列總和的公式計算每輪的糖果數量，最後剩下的糖果在模擬發放的過程即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">distributeCandies</span><span class="params">(<span class="keyword">int</span> candies, <span class="keyword">int</span> num_people)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, tmp;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(num_people)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(candies &gt;= (tmp = (<span class="number">1</span> + num_people) * num_people / <span class="number">2</span> + num_people * num_people * r)) candies -= tmp, ++r;</span><br><span class="line">        <span class="keyword">if</span>(r) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_people; ++i) v[i] += (i + <span class="number">1</span> + i + <span class="number">1</span> + num_people * (r - <span class="number">1</span>)) * r / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_people; ++i)</span><br><span class="line">            <span class="keyword">if</span>(candies &gt;= (tmp = i + <span class="number">1</span> + num_people * r)) v[i] += tmp, candies -= tmp;</span><br><span class="line">            <span class="keyword">else</span> &#123; v[i] += candies; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/1103.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
        <tag>LeetCode 30 August</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 112 解題紀錄</title>
    <url>/LeetCode-112/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/path-sum/">LeetCode - 112. Path Sum</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 Binary Tree 及整數 <code>sum</code>，求是否有一段從樹根到葉子的總和會等於 <code>sum</code>。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用遞迴的觀念遍歷整棵樹，<code>curSum</code> 紀錄從樹根遍歷到這裡的總和，若是到了葉子且 <code>curSum == sum</code> 回傳 True，否則回傳 <code>hasPathSum(root-&gt;left, sum, curSum) || hasPathSum(root-&gt;right, sum, curSum)</code></p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum, <span class="keyword">int</span> curSum = <span class="number">0</span>)</span> <span class="comment">// add curSum</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        curSum += root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; curSum == sum) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left, sum, curSum) || hasPathSum(root-&gt;right, sum, curSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/112.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Recursive</tag>
        <tag>Tree</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 119 解題紀錄 / August LeetCoding Challenge Day 12</title>
    <url>/LeetCode-119/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/pascals-triangle-ii/">LeetCode - 119. Pascal’s Triangle II</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個整數 <code>rowIndex</code>，求第 <code>rowIndex</code> 層 ( 從 0 開始 ) 的帕斯卡三角形的值。<span id="more"></span>( 回傳一個陣列 )<br><strong>※</strong> 題目希望空間複雜度為 O(rowIndex)。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>當我們將帕斯卡三角形轉換成陣列的表示方法時：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>會發現對於 <code>pascal[i][j]</code> 來說，其值為 <code>pascal[i - 1][j] + pascal[i - 1][j - 1]</code>。而題目只要求特定的某一層，所以我們從後面開始做就可以省掉上面層數的空間。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(rowIndex + <span class="number">1</span>)</span></span>;</span><br><span class="line">        v[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowIndex; ++i) <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &gt; <span class="number">0</span>; --j) v[j] += v[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/119.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
        <tag>LeetCode 30 August</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 121 解題紀錄 / September LeetCoding Challenge Day 18</title>
    <url>/LeetCode-121/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">LeetCode - 121. Best Time to Buy and Sell Stock</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列代表每日的股票價格，求買賣一次的最大收益。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>動態規劃，轉移方程為：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cost = min(p, cost);</span><br><span class="line">profit = max(p - cost, profit);</span><br></pre></td></tr></table></figure>

<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cost = INT_MAX, profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p : prices) cost = min(p, cost), profit = max(p - cost, profit);</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/121.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
        <tag>LeetCode 30 September</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 122 解題紀錄</title>
    <url>/LeetCode-122/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">LeetCode - 122. Best Time to Buy and Sell Stock II</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列代表股票的價格，賣的時間不可早於買的時間，求最大收益。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>只需判斷相隔兩天即可，若第二天的價格大於第一天則於第一天購買並於第二天賣出。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size(), profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; prices[i + <span class="number">1</span>])</span><br><span class="line">                profit += prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/122.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 1232 解題紀錄</title>
    <url>/LeetCode-1232/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/check-if-it-is-a-straight-line/">LeetCode - 1232. Check If It Is a Straight Line</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列，元素代表在 2d 座標中的點，求裡面所有的點是否在同一條線上。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>數學題，判斷斜率即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkStraightLine</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; coordinates)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = coordinates.size();</span><br><span class="line">        <span class="keyword">int</span> dx = coordinates[<span class="number">1</span>][<span class="number">0</span>] - coordinates[<span class="number">0</span>][<span class="number">0</span>], dy = coordinates[<span class="number">1</span>][<span class="number">1</span>] - coordinates[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(dy * (coordinates[i][<span class="number">0</span>] - coordinates[<span class="number">0</span>][<span class="number">0</span>]) != dx * (coordinates[i][<span class="number">1</span>] - coordinates[<span class="number">0</span>][<span class="number">1</span>]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/1232.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 125 解題紀錄 / August LeetCoding Challenge Day 3</title>
    <url>/LeetCode-125/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/valid-palindrome/">LeetCode - 125. Valid Palindrome</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 String，檢查此字串是否為回文。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用雙指針即可，使用 <code>isalnum()</code> 判斷字符是否為數字或英文字母，使用 <code>tolower()</code> 將字母轉為小寫。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isalnum</span>(s[i]) &amp;&amp; <span class="built_in">isalnum</span>(s[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">tolower</span>(s[i]) != <span class="built_in">tolower</span>(s[j]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                ++i, --j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">isalnum</span>(s[i]))</span><br><span class="line">                    ++i;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">isalnum</span>(s[j]))</span><br><span class="line">                    --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/125.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
        <tag>LeetCode 30 August</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 136 解題紀錄</title>
    <url>/LeetCode-136/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/single-number/">LeetCode - 136. Single Number</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>從一個陣列中找出不重複的數字。( 只會有一個數字不重複 )</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 XOR 位元運算，將 ans 先設為 nums[0]，再用一個迴圈從 1 開始，對 ans 做 XOR 位元運算，最後的結果即是答案。XOR 的介紹可以參考本篇文章：<a href="../XOR%20位元運算介紹/" target="_blank">XOR 位元運算介紹</a>。</p>
<h3 id="為什麼要使用-XOR-呢？"><a href="#為什麼要使用-XOR-呢？" class="headerlink" title="為什麼要使用 XOR 呢？"></a>為什麼要使用 XOR 呢？</h3><p>因為 XOR 有一個特性是 <code>A ^ A = 0</code>，意思是當兩個相同的數字做 XOR 運算後會變成 0，而另一個特性是 <code>A ^ 0 = A</code>，意思是當任意一個數字對 0 做 XOR 運算後還是自己，恰巧很符合本題的題目，一個陣列內只有一個數字是單獨存在的，其他數字都會有兩個。那你可能會想說：可是陣列的順序不一定是 [A, A, B, B, C, C, D] 呀。這時就要提到 XOR 的第三個特性，<code>A ^ B = B ^ A</code>，就是說 XOR 其實是有交換律的，所以順序其實並不重要。這個題目其實也是 XOR 的經典題目，所有概念都有使用到。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i)</span><br><span class="line">            ans ^= nums[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/136.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Bitwise</tag>
        <tag>XOR</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 14 解題紀錄</title>
    <url>/LeetCode-14/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/longest-common-prefix/">LeetCode - 14. Longest Common Prefix</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列，裡面的元素為 String，求此陣列中所有元素最長的相同開頭字串。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用第一個元素去比對即可，若是碰到不符合的就直接回傳子串。若是都符合代表最長的就是 <code>strs[0]</code>。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> n = strs.size(), N = strs[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">                <span class="keyword">if</span>(strs[j][i] != strs[<span class="number">0</span>][i])</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/14.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 155 解題紀錄</title>
    <url>/LeetCode-155/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/min-stack/">LeetCode - 155. Min Stack</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>設計一個 Stack，並完成部分功能。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>可以直接使用 STL 的容器，所以只須明白 Stack 的運作模式即可。</p>
<ul>
<li><p><strong>解法一</strong><br>  Vector：速度較慢。( 因為插入與刪除元素的代價較高 )</p>
</li>
<li><p><strong>解法二</strong><br>  Stack：速度較快，這邊使用 <code>stack&lt;pair&lt;int, int&gt;&gt;</code> 來增加取得最小值的效率。</p>
</li>
</ul>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><p>解法一：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minstack;</span><br><span class="line">    </span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        minstack.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        minstack.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minstack.back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *(min_element(minstack.begin(), minstack.end()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/155-1.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<p>解法二：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; minstack;</span><br><span class="line">    </span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minstack.empty() || minstack.top().second &gt;= x)</span><br><span class="line">            minstack.push(&#123;x, x&#125;);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            minstack.push(&#123;x, minstack.top().second&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        minstack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minstack.top().first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minstack.top().second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/155-2.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<p>2020-08-18 重寫</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty()) &#123; s.emplace(x, x); <span class="keyword">return</span>; &#125;</span><br><span class="line">        s.emplace(x, x &lt; s.top().second ? x : s.top().second);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; s.pop(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s.top().first; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s.top().second; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/155-3.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Stack</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 169 解題紀錄</title>
    <url>/LeetCode-169/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/majority-element/">LeetCode - 169. Majority Element</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列，求此陣列中出現最多次的數字。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><ul>
<li><p><strong>想法：</strong> 想像成是消去法，將數字兩兩消去，最後剩下的一定是出現最多次的那個數字。</p>
</li>
<li><p><strong>作法：</strong> 定義一個 <code>num</code> 紀錄數字，<code>count</code> 紀錄該數字出現的次數。使用一個迴圈，當碰到數字和 <code>num</code> 不同時就把 <code>count</code> - 1，若 <code>count</code> 剩下 0 時，把 <code>num</code> 換成該數，<code>count</code> 設為 1。</p>
</li>
</ul>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : nums)</span><br><span class="line">            <span class="keyword">if</span>(i == num)</span><br><span class="line">                ++count;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(--count &lt;= <span class="number">0</span>)</span><br><span class="line">                num = i, count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/169.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 171 解題紀錄 / August LeetCoding Challenge Day 10</title>
    <url>/LeetCode-171/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/excel-sheet-column-number/">LeetCode - 171. Excel Sheet Column Number</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個只含有大寫英文字母的字串，按照題目的規則求出對應的數字。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>想像為 26 進制即可，例如 <code>&quot;AAA&quot; = (1 * 26²) + (1 * 26¹) + (1 * 26⁰)</code>。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size() - <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)</span><br><span class="line">            res += (c - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>) * <span class="built_in">pow</span>(<span class="number">26</span>, n--);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/171.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode - Easy</tag>
        <tag>LeetCode 30 August</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 198 解題紀錄 / September LeetCoding Challenge Day 14</title>
    <url>/LeetCode-198/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/house-robber/">LeetCode - 198. House Robber</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列代表每間房子的搶劫價值，不能搶連續的兩間房子，求能搶劫的最大價值。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用動態規劃的思路，<code>dp[i]</code> 代表到第 <code>i - 1</code> 間能搶到的最大價值，遍歷 <code>nums</code>，若是決定第 <code>i - 1</code> 間要搶，則 <code>dp[i]</code> 為 <code>dp[i - 2] + nums[i]</code>，若是不搶則為 <code>dp[i - 1]</code>，兩者取較大者即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dp[i] = max(dp[max(i - <span class="number">2</span>, <span class="number">0</span>)] + nums[i - <span class="number">1</span>], dp[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/198.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
        <tag>LeetCode 30 September</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 20 解題紀錄</title>
    <url>/LeetCode-20/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/valid-parentheses/">LeetCode - 20. Valid Parentheses</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個只含有括號的字串，求此字串是否合法。<span id="more"></span>字串合法須滿足以下條件：</p>
<ul>
<li><strong>開括號必須用相同類型的括號封閉</strong></li>
<li><strong>開括號必須以正確的順序關閉</strong></li>
</ul>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>由於閉括號必須搭配相同類型的開括號，所以可以使用 Stack，碰到開括號時直接推入，若碰到閉括號時只要看 <code>stack.top()</code> 是否是對應的開括號即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s_;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : s)</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="string">&#x27;(&#x27;</span> || i == <span class="string">&#x27;&#123;&#x27;</span> || i == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                s_.push(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!s_.empty())</span><br><span class="line">                <span class="keyword">switch</span>(i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                        <span class="keyword">if</span>(s_.top() != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        s_.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                        <span class="keyword">if</span>(s_.top() != <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        s_.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                        <span class="keyword">if</span>(s_.top() != <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        s_.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> s_.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/20.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>Stack</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 202 解題紀錄</title>
    <url>/LeetCode-202/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/happy-number/">LeetCode - 202. Happy Number</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>將題目給的數字拆開並求出拆開的數字的平方和，若結果為 1 則為 Happy Number。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 <code>Floyd Cycle Detection Algorithm</code> 即可，詳細介紹可參考：<a href="https://zh.wikipedia.org/wiki/Floyd%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95">Wiki</a></p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            next += (n % <span class="number">10</span>) * ( n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tortoise = n;</span><br><span class="line">        <span class="keyword">int</span> hare = n;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            tortoise = next(tortoise);</span><br><span class="line">            hare = next(next(hare));</span><br><span class="line">        &#125;<span class="keyword">while</span>(tortoise != hare);</span><br><span class="line">        <span class="keyword">return</span> (hare == <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/202.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
        <tag>Floyd Cycle Detection Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 21 解題紀錄</title>
    <url>/LeetCode-21/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/merge-two-sorted-lists/">LeetCode - 21. Merge Two Sorted Lists</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個 List，將數值從小到大排序。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用遞迴即可，每次都以較小的值建立 node。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!l1) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(!l2) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">return</span> l1-&gt;val &lt; l2-&gt;val ? <span class="keyword">new</span> ListNode(l1-&gt;val, mergeTwoLists(l1-&gt;next, l2)) : <span class="keyword">new</span> ListNode(l2-&gt;val, mergeTwoLists(l1, l2-&gt;next));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/21.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Recursive</tag>
        <tag>List</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 26 解題紀錄</title>
    <url>/LeetCode-26/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">LeetCode - 26. Remove Duplicates from Sorted Array</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個由小到大排序好的陣列，要求刪除陣列中重複的數字，並回傳處理後的陣列的大小。</p>
<span id="more"></span>

<p><strong>※</strong> 題目希望使用原本的陣列來達成，不要建立額外的陣列，也就是空間複雜度為 O(1) 的意思。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先判斷 <code>nums</code> 是否為空，若為空直接回傳 0。<br>定義 <code>idx</code> 紀錄目前的 index，由於陣列是排序好的，重複的數字會被排在一起，所以依序遍歷陣列，若碰到與 <code>nums[idx]</code> 不同的數字，則放入 <code>nums[idx + 1]</code>，同時將 <code>idx</code> + 1，最後回傳 <code>idx</code> + 1，因為題目要求回傳的是大小。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; n : nums) <span class="keyword">if</span> (n != nums[idx]) nums[++idx] = n;</span><br><span class="line">        <span class="keyword">return</span> ++idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/26.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 27 解題紀錄</title>
    <url>/LeetCode-27/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/remove-element/">LeetCode - 27. Remove Element</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列，求刪除某個特定數字後的陣列及其大小。</p>
<span id="more"></span>

<p><strong>※</strong> 題目希望使用原本的陣列來達成，不要建立額外的陣列，也就是空間複雜度為 O(1) 的意思。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>遍歷陣列，若值不等於要刪除的值則從頭開始放入陣列。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; n : nums) <span class="keyword">if</span> (n != val) nums[l++] = n;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/27.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 278 解題紀錄</title>
    <url>/LeetCode-278/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/first-bad-version/">LeetCode - 278. First Bad Version</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個整數 <code>n</code>，求 1, 2, …, n 中，從哪個數字開始是 Bad version。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用二元搜尋法即可。<br><strong>※</strong> 須注意溢位的問題，所以型態使用 <code>long long</code>。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> first = <span class="number">1</span>, last = n, mid = (first + last) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(!isBadVersion(mid) || isBadVersion(mid - <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isBadVersion(mid))</span><br><span class="line">                first = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                last = mid - <span class="number">1</span>;</span><br><span class="line">            mid = (first + last) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/278.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 283 解題紀錄</title>
    <url>/LeetCode-283/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/move-zeroes/">LeetCode - 283. Move Zeroes</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列，將陣列中的 0 全部都往最右邊移，而其他數字的順序不變。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用一個迴圈，將陣列中不是 0 的從最前面開始放，最後再把 0 補上即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>, n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)</span><br><span class="line">                nums[j++] = nums[i];</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n)</span><br><span class="line">            nums[j++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/283.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 290 解題紀錄 / September LeetCoding Challenge Day 7</title>
    <url>/LeetCode-290/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/word-pattern/">LeetCode - 290. Word Pattern</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個字串 <code>pattern</code> 及 <code>str</code> 分別代表單詞的組成模式及單詞組成。求單詞組成是否符合組成模式。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 Stringstream 來分割 <code>str</code>，Unordered_map 紀錄組成模式及對應的字串，Unordered_set 避免兩個 key 對應到同一個字串，接著遍歷 <code>pattern</code>，若是碰到兩種 key 對應到同一個字串或是 val 與當前讀取到的字串不相等則回傳 False，最後判斷 <code>str</code> 是否已經全部處理，若是沒有代表 <code>pattern</code> 的長度不夠，此時也是回傳 False。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordPattern</span><span class="params">(<span class="built_in">string</span> pattern, <span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> tmp;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; m;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : pattern)</span><br><span class="line">        &#123;</span><br><span class="line">            ss &gt;&gt; tmp;</span><br><span class="line">            <span class="comment">//         two keys to one val || not right val</span></span><br><span class="line">            <span class="keyword">if</span>(!m.count(c) &amp;&amp; s.count(tmp) || m.count(c) &amp;&amp; tmp != m[c]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            m[c] = tmp, s.insert(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ss.eof() ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/290.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Unordered_map</tag>
        <tag>Unordered_set</tag>
        <tag>Stringstream</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
        <tag>LeetCode 30 September</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 299 解題紀錄 / September LeetCoding Challenge Day 10</title>
    <url>/LeetCode-299/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/bulls-and-cows/">LeetCode - 299. Bulls and Cows</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個字串，一個代表猜測的密碼一個代表正確密碼，若是位置及數字都正確則 A 增加，若是數字正確而位置錯誤則 B 增加。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用一個陣列紀錄正確密碼的個數，接著遍歷兩個字串，先判斷 <code>guess</code> 當前的字元是否存在陣列中，接著判斷 <code>guess</code> 的當前字元是否等於 <code>secret</code> 的當前字元即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getHint</span><span class="params">(<span class="built_in">string</span> secret, <span class="built_in">string</span> guess)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> A&#123;&#125;, B&#123;&#125;, n = secret.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c : secret) ++v[c - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i&#123;&#125;; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[guess[i] - <span class="string">&#x27;0&#x27;</span>]) --v[guess[i] - <span class="string">&#x27;0&#x27;</span>], ++B;</span><br><span class="line">            <span class="keyword">if</span>(secret[i] == guess[i]) ++A, --B;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> to_string(A) + <span class="string">&quot;A&quot;</span> + to_string(B) + <span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/299.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
        <tag>LeetCode 30 September</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 342 解題紀錄 / August LeetCoding Challenge Day 4</title>
    <url>/LeetCode-342/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/power-of-four/">LeetCode - 342. Power of Four</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個整數，求此整數是否是 4 的次方數。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>一個整數若是 4 的次方數，必定會是 2 的次方數，所以先判斷是否為 2 的次方數再判斷是否為 4 的次方數即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num &gt; <span class="number">0</span> &amp;&amp; !(num &amp; (num - <span class="number">1</span>)) &amp;&amp; (num &amp; <span class="number">0x55555555</span>) == num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/342.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode - Easy</tag>
        <tag>LeetCode 30 August</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 35 解題紀錄</title>
    <url>/LeetCode-35/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/search-insert-position/">LeetCode - 35. Search Insert Position</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個由小至大排序的陣列，及一個 <code>target</code>，求 <code>target</code> 應該插入到的位置 ( index )。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>由於是排序過的陣列，所以使用二分法查詢即可。 ( 可直接使用 <code>lower_bound()</code> 完成二分法 )</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(nums, target);</span><br><span class="line">        <span class="comment">//return lower_bound(begin(nums), end(nums), target) - begin(nums);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size();</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (target &gt; nums[mid]) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/35.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 367 解題紀錄</title>
    <url>/LeetCode-367/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/valid-perfect-square/">LeetCode - 367. Valid Perfect Square</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個整數，求此數是否是完全平方數。( 開根號後還是整數 )<br><strong>※</strong> 題目要求不要使用包含在 Library 內的 Function，如 <code>sqrt()</code>… 等等。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用二元搜尋法即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = num;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mid, squareMid;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            squareMid = mid * mid;</span><br><span class="line">            <span class="keyword">if</span>(squareMid == num)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(squareMid &gt; num)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/367.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 383 解題紀錄</title>
    <url>/LeetCode-383/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/ransom-note/">LeetCode - 383. Ransom Note</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個字串 <code>ransomNote</code>、<code>magazine</code>，求 <code>ransomNote</code> 是否能由 <code>magazine</code> 組成。對於一個字元來說，在 <code>magazine</code> 中出現的次數需大於等於在 <code>ransomNote</code> 中出現的次數。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用一個陣列儲存字元出現的次數即可。由於測資只包含小寫的英文字母，所以陣列大小設為 26。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(<span class="built_in">string</span> ransomNote, <span class="built_in">string</span> magazine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">26</span>] = &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : ransomNote)</span><br><span class="line">            ++count[i - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : magazine)</span><br><span class="line">            --count[i - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : count)</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/383.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 387 解題紀錄</title>
    <url>/LeetCode-387/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/first-unique-character-in-a-string/">LeetCode - 387. First Unique Character in a String</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個字串，求字串中只出現過一次的字元的 <code>index</code>。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用一個陣列儲存字元出現的次數即可。由於測資只包含小寫的英文字母，所以陣列大小設為 26。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">26</span>] = &#123;&#125;, n = s.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : s)</span><br><span class="line">            ++count[i - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(count[s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/387.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 389 解題紀錄 / September LeetCoding Challenge Day 24</title>
    <url>/LeetCode-389/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/find-the-difference/">LeetCode - 389. Find the Difference</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個字串 <code>s</code> 及 <code>t</code>，<code>t</code> 為 <code>s</code> 加上一個字元組成，求該字元為何。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>由於字元本身為 ascii code，也是一種數字，所以使用 XOR 找出多出來的字元即可，詳細可參考本篇文章：<a href="../LeetCode%20-%20136/" target="_blank">LeetCode - 136 解題紀錄</a>。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c : (s + t)) ch ^= c;</span><br><span class="line">        <span class="keyword">return</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/389.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Bitwise</tag>
        <tag>XOR</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
        <tag>LeetCode 30 September</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 409 解題紀錄 / August LeetCoding Challenge Day 14</title>
    <url>/LeetCode-409/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/longest-palindrome/">LeetCode - 409. Longest Palindrome</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個字串，求字串中的所有字元能組成的最大回文長度。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>回文的形式有兩種，一種是奇數個數，一種是偶數個數，而奇數個數的形式就是偶數個數加上任意一個字元，所以我們先計算每個字元出現的次數，再判斷所有字元裡面是否有出現奇數個數的次數，最後將次數加入長度即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, odd = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; _m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s) ++_m[c];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> m : _m) &#123; <span class="keyword">if</span>(m.second % <span class="number">2</span>) odd = <span class="number">1</span>; l += m.second / <span class="number">2</span> * <span class="number">2</span>; &#125;</span><br><span class="line">        <span class="keyword">return</span> l + odd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/409.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
        <tag>LeetCode 30 August</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 412 解題紀錄 / August LeetCoding Challenge Day 26</title>
    <url>/LeetCode-412/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/fizz-buzz/">LeetCode - 412. Fizz Buzz</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個整數 <code>n</code>，要求回傳一個字串的陣列，<code>i</code> 從 1 數到 <code>n</code>，若 <code>i</code> 為 3 的倍數，字串為 “Fizz”，若為 5 的倍數則為 “Buzz”，若為 3 與 5 的倍數則為 “FizzBuzz”，否則為 <code>i</code>。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>字串的串接。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp;</span><br><span class="line">            <span class="keyword">if</span>(!(i % <span class="number">3</span>)) tmp += <span class="string">&quot;Fizz&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i % <span class="number">5</span>)) tmp += <span class="string">&quot;Buzz&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(tmp.empty()) tmp += to_string(i);</span><br><span class="line">            v.emplace_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/412.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
        <tag>LeetCode 30 August</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 404 解題紀錄 / August LeetCoding Challenge Day 24</title>
    <url>/LeetCode-404/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/sum-of-left-leaves/">LeetCode - 404. Sum of Left Leaves</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 Tree，找到所有位於左邊的葉子的總和。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>判斷當前 <code>node</code> 的左邊 <code>node</code> 是否符合 <code>!root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right</code> 若符合代表 <code>root-&gt;left</code> 為左邊的葉子，依此想法使用遞迴即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) <span class="keyword">return</span> root-&gt;left-&gt;val + sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/404.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Recursive</tag>
        <tag>Tree</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
        <tag>LeetCode 30 August</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 459 解題紀錄 / September LeetCoding Challenge Day 3</title>
    <url>/LeetCode-459/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/repeated-substring-pattern/">LeetCode - 459. Repeated Substring Pattern</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個字串 <code>s</code>，求 <code>s</code> 是否為某個子串的數倍串接組成。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>如果 <code>s</code> 滿足題目的條件，那麼將字串複製一次後，去除頭跟尾，一定能找到原本的字串。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123; <span class="keyword">return</span> (s + s).find(s, <span class="number">1</span>) != s.size(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/459.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
        <tag>LeetCode 30 September</tag>
        <tag>Puzzled</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 476 解題紀錄</title>
    <url>/LeetCode-476/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/number-complement/">LeetCode - 476. Number Complement</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個數字，求這個數字的補數。補數的取法就是將數字轉為二進制，然後對代表數字的部分做 <code>not</code> 運算。例如：</p>
<span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5： 00 00000 00000 00000 00000 00000 00|101</span><br><span class="line">                                        ^ 從這裡開始</span><br><span class="line">2： 00 00000 00000 00000 00000 00000 00|010</span><br><span class="line">所以 5 的補數就是 2。</span><br></pre></td></tr></table></figure>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先找出他代表數字的地方有幾位，求法就是一直往右推直到整個數字為 0。然後將數字往左推 <code>count</code> 位數，再使用 <code>~</code> 運算符對數字做 <code>not</code> 運算，最後再把 0 給推回去即可。<br><strong>※</strong> 關於 <code>&lt;&lt;</code> 及 <code>&gt;&gt;</code> 運算符的介紹可參考本篇文章：<a href="../LeetCode%20-%20201/" target="_blank">LeetCode - 201 解題紀錄</a></p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">32</span>, temp = num;</span><br><span class="line">        <span class="keyword">while</span>(temp &gt; <span class="number">0</span>)</span><br><span class="line">            temp &gt;&gt;= <span class="number">1</span>, --count;</span><br><span class="line">        <span class="keyword">return</span> ~(num &lt;&lt; count) &gt;&gt; count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/476.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Bitwise</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 520 解題紀錄 / August LeetCoding Challenge Day 1</title>
    <url>/LeetCode-520/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/detect-capital/">LeetCode - 520. Detect Capital</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 String 代表一個單字，求單字是否符合以下條件：</p>
<span id="more"></span>

<ul>
<li><strong>所有字母都為大寫</strong></li>
<li><strong>所有字母都為小寫</strong></li>
<li><strong>只有第一個字母為大寫</strong></li>
</ul>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>紀錄大寫字母的數量及最後一個大寫字母的 <code>index</code>，最後再判斷即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">detectCapitalUse</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index, count = <span class="number">0</span>, n = word.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(word[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; word[i] &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">                ++count, index = i;</span><br><span class="line">        <span class="keyword">if</span>(!count || (count == <span class="number">1</span> &amp;&amp; index == <span class="number">0</span>) || count == n)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/520.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
        <tag>LeetCode 30 August</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 53 解題紀錄</title>
    <url>/LeetCode-53/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/maximum-subarray/">LeetCode - 53. Maximum Subarray</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列，找到具有最大總和的連續子陣列 ( 至少包含一個數字 )，並回傳其總和。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用動態規劃的觀念，最大值為 <code>mx + nums[i]</code> 及 <code>nums[i]</code> 兩者取較大者，並隨時更新結果即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mx = nums[<span class="number">0</span>], res = mx, n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            mx = max(mx + nums[i], nums[i]);</span><br><span class="line">            res = max(res, mx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/53.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 543 解題紀錄</title>
    <url>/LeetCode-543/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/diameter-of-binary-tree/">LeetCode - 543. Diameter of Binary Tree</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 Tree，找出它的最長路徑。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>核心想法為，最長路徑有沒有通過 root？</p>
<ul>
<li><p><strong>若有：</strong>最長路徑為 <code>左邊 node 的最深深度</code> 加上 <code>右邊 node 的最深深度</code>。</p>
</li>
<li><p><strong>若沒有：</strong>最長路徑為 <code>左邊 node 的最長路徑</code> 或是 <code>右邊 node 的最長路徑</code>。</p>
</li>
</ul>
<p>確定了上面想法後再利用遞迴的觀念找出答案即可。<br>Tree 的最深深度的算法可參考：<a href="../LeetCode%20-%20104/">LeetCode - 104 解題紀錄</a></p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 終止條件</span></span><br><span class="line">        <span class="keyword">if</span>(!root) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 包含 root 的最長路徑</span></span><br><span class="line">        <span class="keyword">int</span> middle = maxDepth(root-&gt;left) + maxDepth(root-&gt;right);</span><br><span class="line">        <span class="comment">// 只有右邊的最長路徑</span></span><br><span class="line">        <span class="keyword">int</span> right = diameterOfBinaryTree(root-&gt;right);</span><br><span class="line">        <span class="comment">// 只有左邊的最長路徑</span></span><br><span class="line">        <span class="keyword">int</span> left = diameterOfBinaryTree(root-&gt;left);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(middle, max(right, left));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/543.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Recursive</tag>
        <tag>Tree</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 58 解題紀錄 / September LeetCoding Challenge Day 15</title>
    <url>/LeetCode-58/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/length-of-last-word/">LeetCode - 58. Length of Last Word</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個字串，求字串中最後一個單詞的長度。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>從後面開始遍歷字串，先使用 String 的 <code>find_last_not_of()</code> 從後往前找第一個字母的 index，接著利用 <code>isalpha()</code> 判斷是否為字母，找出長度即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = s.find_last_not_of(<span class="string">&#x27; &#x27;</span>), length&#123;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(idx &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">isalpha</span>(s[idx--])) ++length;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/58.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
        <tag>LeetCode 30 September</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 67 解題紀錄</title>
    <url>/LeetCode-67/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/add-binary/">LeetCode - 67. Add Binary</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個 String 代表兩個二進制表示法的數字，求兩數字的和的二進制表示法。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>從兩數字的最後一位開始往前走，分別將數值加到 <code>c</code> 中，最後存到目前結果的前面。直到兩數都走完且 <code>c</code> 為 0 才停止。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">int</span> i = a.length() - <span class="number">1</span>, j = b.length() - <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span>) c += a[i--] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= <span class="number">0</span>) c += b[j--] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            str = <span class="keyword">char</span>(c % <span class="number">2</span> + <span class="string">&#x27;0&#x27;</span>) + str;</span><br><span class="line">            c /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/67.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 7 解題紀錄</title>
    <url>/LeetCode-7/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/reverse-integer/">LeetCode - 7. Reverse Integer</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個整數，將此整數反轉。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>從最後面一位一位拿出來即可，需要特別注意若是過程中超過 <code>int</code> 的界限就直接回傳 0。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, max = INT_MAX / <span class="number">10</span>, min = INT_MIN / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans &gt; max || ans &lt; min)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            ans = ans * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/7.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 705 解題紀錄 / August LeetCoding Challenge Day 2</title>
    <url>/LeetCode-705/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/design-hashset/">LeetCode - 705. Design HashSet</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>設計一個 Hash_set 的 Class。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 Unordered_set 實作即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyHashSet() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123; hs.insert(key); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123; hs.erase(key); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set contains the specified element */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123; <span class="keyword">return</span> hs.count(key); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; hs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/705.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Unordered_set</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
        <tag>LeetCode 30 August</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 733 解題紀錄</title>
    <url>/LeetCode-733/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/flood-fill/">LeetCode - 733. Flood Fill</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個二維的陣列當作 2d 圖片，陣列裡面的元素代表該座標的顏色，給一個座標及一個 <code>newColor</code> 做填滿顏色的動作 ( 與小畫家的 <code>填入色彩</code> 類似)。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先判斷舊顏色和新顏色是否相同，若相同就直接回傳 image，否則就從該點使用遞迴的概念替換顏色即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> oldColor, <span class="keyword">int</span> newColor, <span class="keyword">int</span> height, <span class="keyword">int</span> width)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= height || j &gt;= width || image[i][j] != oldColor)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        image[i][j] = newColor;</span><br><span class="line">        fill(image, i + <span class="number">1</span>, j, oldColor, newColor, height, width);</span><br><span class="line">        fill(image, i - <span class="number">1</span>, j, oldColor, newColor, height, width);</span><br><span class="line">        fill(image, i, j + <span class="number">1</span>, oldColor, newColor, height, width);</span><br><span class="line">        fill(image, i, j - <span class="number">1</span>, oldColor, newColor, height, width);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; floodFill(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="keyword">if</span>(image[sr][sc] == newColor)</span><br><span class="line">            <span class="keyword">return</span> image;</span><br><span class="line">        <span class="keyword">int</span> height = image.size(), width = image[<span class="number">0</span>].size();</span><br><span class="line">        fill(image, sr, sc, image[sr][sc], newColor, height, width);</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/733.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Recursive</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 771 解題紀錄</title>
    <url>/LeetCode-771/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/jewels-and-stones/">LeetCode - 771. Jewels and Stones</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個字串 <code>J</code>、<code>S</code>，求 <code>S</code> 裡面有多少個字元與 <code>J</code> 裡面的字元相同。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 String 裡面的 <code>find()</code> 即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(<span class="built_in">string</span> J, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : S)</span><br><span class="line">            <span class="keyword">if</span>(J.find(i) != <span class="number">-1</span>)</span><br><span class="line">                ++count;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/771.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 824 解題紀錄 / August LeetCoding Challenge Day 19</title>
    <url>/LeetCode-824/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/goat-latin/">LeetCode - 824. Goat Latin</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個字串，將字串中的每個單詞拆開並根據題目的規則修改單詞的內容。<span id="more"></span><br>規則如下：</p>
<ul>
<li>若是單詞的開頭為母音則在單詞的結尾加上 <code>&quot;ma&quot;</code>。</li>
<li>若是單詞的開頭不為母音則將單詞的開頭移到單詞的結尾並加上 <code>&quot;ma&quot;</code>。</li>
<li>在第一個單詞的結尾加上 <code>&#39;a&#39;</code>，第二的單詞的結尾加上 <code>&quot;aa&quot;</code>…。</li>
</ul>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>題目的三個規則可以簡化成兩個步驟：</p>
<ol>
<li><strong>若是單詞的開頭不為母音則將單詞的開頭移到單詞的結尾。</strong></li>
<li><strong>在單詞的結尾加上 <code>&quot;ma&quot;</code> 及對應數量的 <code>&#39;a&#39;</code>。</strong></li>
</ol>
<p>定義一個 String <code>_append</code> 作為每次都必須加上的結尾，使用 StringStream 將字串的單詞拆開，每次先判斷單詞的開頭是否不為母音，若是的話就將開頭移到結尾，最後加上 <code>_append</code> 及更新 <code>_append</code> 即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toGoatLatin</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(S)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> tmp, res, _append = <span class="string">&quot;ma&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(ss &gt;&gt; tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isVowel(<span class="built_in">tolower</span>(tmp[<span class="number">0</span>]))) tmp += tmp[<span class="number">0</span>], tmp.erase(tmp.begin());</span><br><span class="line">            res += tmp + (_append += <span class="string">&#x27;a&#x27;</span>) + <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.substr(<span class="number">0</span>, res.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isVowel</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123; <span class="keyword">return</span> c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/824.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>Stringstream</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
        <tag>LeetCode 30 August</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 844 解題紀錄</title>
    <url>/LeetCode-844/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/backspace-string-compare/">LeetCode - 844. Backspace String Compare</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個字串，模擬字串的內容操作鍵盤，字串內的 <code>#</code> 代表 BackSpace，判斷模擬完後輸出的字串是否相同。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><ul>
<li><p><strong>解法一：</strong>定義新的兩個 String 並分別遍歷原本的字串，若不是 <code>#</code> 則 <code>push_back()</code> 到新字串，否則就 <code>pop_back()</code>。( 須注意字串的Size，若是 0 就不能在 <code>pop_back()</code> )</p>
</li>
<li><p><strong>解法二：</strong>使用雙指針，將模擬操作後的字串放入原本的字串。( 一樣要注意 Size 的問題 )</p>
</li>
</ul>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><p>解法一：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s, t;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : S)</span><br><span class="line">            <span class="keyword">if</span>( i != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                s.push_back(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.size() &gt; <span class="number">0</span>)</span><br><span class="line">                s.pop_back();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : T)</span><br><span class="line">            <span class="keyword">if</span>( i != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                t.push_back(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(t.size() &gt; <span class="number">0</span>)</span><br><span class="line">                t.pop_back();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (s == t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/844-1.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<p>解法二：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : S)</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                S[pos] = i, ++pos;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pos &gt; <span class="number">0</span>)</span><br><span class="line">                --pos;</span><br><span class="line">        S.resize(pos);</span><br><span class="line">        </span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : T)</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                T[pos] = i, ++pos;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pos &gt; <span class="number">0</span>)</span><br><span class="line">                --pos;</span><br><span class="line">        T.resize(pos);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (S == T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/844-2.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 859 解題紀錄</title>
    <url>/LeetCode-859/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/buddy-strings/">LeetCode - 859. Buddy Strings</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個 String <code>A</code>, <code>B</code>，<code>A</code> 需要交換任意兩字元一次，求交換後的 <code>A</code> 是否等於 <code>B</code>。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先檢查兩者長度是否相等，若不相等則直接回傳 False。<br>接著檢查，若兩者原本就已經相等，則判斷 <code>A</code> 內是否有重複的字元，因為 <code>A</code> 一定要交換一次，若 <code>A</code> 中沒有重複的字元則交換後會變為不相等，這裡使用 hashset 來判斷。<br>最後遍歷兩者，將兩者字元不同的 index 儲存，最後判斷 <code>diff</code> 的大小是否為 2，若為 2 則判斷 <code>A[diff[0]] 是否等於 B[diff[1]] 且 A[diff[1]] 是否等於 B[diff[0]]</code> ( 此條件為檢查是否 <code>A</code> 元素互換後會等於 <code>B</code> ) 若都符合則回傳 True，否則回傳 False。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">buddyStrings</span><span class="params">(<span class="built_in">string</span> A, <span class="built_in">string</span> B)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.length() != B.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (A == B) <span class="keyword">return</span> <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt;(A.begin(), A.end()).size() &lt; A.length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; diff;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length(); ++i) <span class="keyword">if</span> (A[i] != B[i]) diff.emplace_back(i);</span><br><span class="line">        <span class="keyword">return</span> diff.size() == <span class="number">2</span> &amp;&amp; A[diff[<span class="number">0</span>]] == B[diff[<span class="number">1</span>]] &amp;&amp; A[diff[<span class="number">1</span>]] == B[diff[<span class="number">0</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/859.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 876 解題紀錄</title>
    <url>/LeetCode-876/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/middle-of-the-linked-list/">LeetCode - 876. Middle of the Linked List</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 Linked List，找到 List 中間的那個 <code>node</code>。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><ul>
<li><p><strong>解法一：</strong>先遍歷一遍，得到整個 List 的長度，然後在用一個 <code>node</code> 走到長度的一半即可。</p>
</li>
<li><p><strong>解法二：</strong>使用 <code>Floyd Cycle Detection Algorithm</code> 的概念，當 hare 走到結尾時，tortoise 剛好會走到一半。</p>
</li>
</ul>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><p>解法一：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> ans = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = head; it != <span class="literal">nullptr</span>; it = it-&gt;next, ++length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length / <span class="number">2</span>; ++i, ans = ans-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/876-1.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<p>解法二：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> tortoise = head, hare = head;</span><br><span class="line">        <span class="keyword">while</span>(hare &amp;&amp; hare-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            hare = hare-&gt;next-&gt;next;</span><br><span class="line">            tortoise = tortoise-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tortoise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/876-2.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>List</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
        <tag>Floyd Cycle Detection Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 9 解題紀錄</title>
    <url>/LeetCode-9/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/palindrome-number/">LeetCode - 9. Palindrome Number</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個整數，求此整數是否為回文。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>從最後面一位一位拿出來即可，需要特別注意若是過程中超過 <code>int</code> 的界限就直接回傳 <code>False</code>。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = x, reverse = <span class="number">0</span>, max = INT_MAX / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(reverse &gt;= max)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            reverse = reverse * <span class="number">10</span> + temp % <span class="number">10</span>;</span><br><span class="line">            temp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverse == x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/9.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 905 解題紀錄 / August LeetCoding Challenge Day 21</title>
    <url>/LeetCode-905/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/sort-array-by-parity/">LeetCode - 905. Sort Array By Parity</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列，要求將陣列重新排序，使得偶數的元素都在前面的部份，奇數都在後面的部份。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>遍歷整個陣列，使用雙指針，當碰到偶數就將它跟前面的值交換即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArrayByParity</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; A.size(); ++r) <span class="keyword">if</span>(!(A[r] % <span class="number">2</span>)) swap(A[l++], A[r]);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/905.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
        <tag>LeetCode 30 August</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 941 解題紀錄</title>
    <url>/LeetCode-941/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/valid-mountain-array/">LeetCode - 941. Valid Mountain Array</a></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>紀錄陣列第一次下降後，是否還有出現下降即可，需要注意的是，由於需要嚴格遞增跟嚴格遞減同時在陣列中出現，所以需要另外紀錄是否有嚴格遞增存在。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validMountainArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> firstDown = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> isIncrease = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                isIncrease = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (firstDown) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; arr[i - <span class="number">1</span>]) firstDown = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> firstDown &amp;&amp; isIncrease;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 949 解題紀錄 / September LeetCoding Challenge Day 1</title>
    <url>/LeetCode-949/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/largest-time-for-given-digits/">LeetCode - 949. Largest Time for Given Digits</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個大小為 4 的陣列，求此陣列中的數字能組出的最大的 24 小時制的時間。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先將陣列由小到大排序，之後使用能組出全排列的函數 <code>next_permutation()</code> 將每種組合都嘗試一次即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestTimeFromDigits</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        sort(A.begin(), A.end());</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> hour = A[<span class="number">0</span>] * <span class="number">10</span> + A[<span class="number">1</span>], minute = A[<span class="number">2</span>] * <span class="number">10</span> + A[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span>(!(hour &lt; <span class="number">24</span> &amp;&amp; minute &lt; <span class="number">60</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            str = to_string(A[<span class="number">0</span>]) + to_string(A[<span class="number">1</span>]) + <span class="string">&quot;:&quot;</span> + to_string(A[<span class="number">2</span>]) + to_string(A[<span class="number">3</span>]);</span><br><span class="line">        &#125;<span class="keyword">while</span>(next_permutation(A.begin(), A.end()));</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/949.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
        <tag>LeetCode 30 September</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 993 解題紀錄</title>
    <url>/LeetCode-993/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/cousins-in-binary-tree/">LeetCode - 993. Cousins in Binary Tree</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 Binary Tree，兩個值，求該值是否在同一層且父節點不同。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 <code>pair&lt;int, int&gt;</code> 紀錄，<code>first</code> 放父節點的值，<code>second</code> 放深度。再使用遞迴計算即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    pair&lt;int, int&gt; get(TreeNode* root, int target, int depth, int father)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> &#123;father, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == target)</span><br><span class="line">            <span class="keyword">return</span> &#123;father, depth&#125;;</span><br><span class="line">        <span class="keyword">auto</span> left = get(root-&gt;left, target, ++depth, root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(left.second != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> get(root-&gt;right, target, depth, root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCousins</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> xInfo = get(root, x, <span class="number">0</span>, root-&gt;val);</span><br><span class="line">        <span class="keyword">auto</span> yInfo = get(root, y, <span class="number">0</span>, root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(xInfo.first != yInfo.first &amp;&amp; xInfo.second == yInfo.second)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/993.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Recursive</tag>
        <tag>Tree</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 997 解題紀錄</title>
    <url>/LeetCode-997/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/find-the-town-judge/">LeetCode - 997. Find the Town Judge</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個整數及一個陣列，整數代表某個城鎮的居民總數，陣列代表某個城鎮居民的信任關係，<span id="more"></span>例如 <code>[1, 2]</code> 就代表居民 1 信任居民 2。題目要求我們找到城鎮中的法官，而法官會有以下特點：</p>
<ul>
<li><strong>法官被其他所有人所信任</strong></li>
<li><strong>法官不相信任何人</strong></li>
</ul>
<p><strong>※</strong> 陣列中不會有重複的信任關係，例如居民 1 信任居民 2，則 <code>[1, 2]</code> 就會出現在陣列中並且只會出現一次。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用一個陣列來紀錄居民們的信任關係，<code>trusts[i][0]</code> 代表居民 <code>i</code> 相信幾個人，<code>trusts[i][1]</code> 代表居民 <code>i</code> 被幾個人所信任。而法官必須滿足以下條件：</p>
<ul>
<li><code>trusts[i][0] == 0</code>：因為法官不能相信任何人。</li>
<li><code>trusts[i][1] == N - 1</code>：因為法官必須被除了自己以外的所有人所信任。</li>
</ul>
<p>若是居民 <code>i</code> 滿足以上的條件，則居民 <code>i</code> 就是法官。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findJudge</span><span class="params">(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; trust)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> trusts = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : trust)</span><br><span class="line">            ++trusts[i[<span class="number">0</span>]][<span class="number">0</span>], ++trusts[i[<span class="number">1</span>]][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">            <span class="keyword">if</span>(!trusts[i][<span class="number">0</span>] &amp;&amp; trusts[i][<span class="number">1</span>] == N - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/997.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 1032 解題紀錄 / August LeetCoding Challenge Day 23</title>
    <url>/LeetCode-1032/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/stream-of-characters/">LeetCode - 1032. Stream of Characters</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>完成一個 Class，裡面包含兩個函式。<span id="more"></span></p>
<ul>
<li><code>StreamChecker(vector&lt;string&gt;&amp; words)</code>：給一個字串的陣列，表示字典。</li>
<li><code>bool query(char letter)</code>：可以想像成呼叫一次就是使用者打了一個字，檢查使用者打的前幾個字中是否有包含於字典中的單詞。</li>
</ul>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用字典樹來實現，關於字典樹的做法可參考本篇文章：<a href="../LeetCode%20-%20208/" target="_blank">LeeCode - 208 解題紀錄</a> 及 本篇文章：<a href="../LeetCode%20-%20211/" target="_blank">LeeCode - 211 解題紀錄</a></p>
<p>只要建一個顛倒的字典樹即可。例如 <code>cd</code> 就建成 <code>dc</code>。</p>
<ul>
<li><code>StreamChecker(vector&lt;string&gt;&amp; words)</code>：普通字典樹的建造。</li>
<li><code>bool query(char letter)</code>：呼叫時先將 <code>letter</code> 加入到字串中，接著從後面開始往前檢查。</li>
</ul>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode() : isWord(<span class="literal">false</span>) &#123; <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ptr : child) ptr = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    ~TrieNode() &#123; <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ptr : child) <span class="keyword">delete</span> ptr; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == <span class="number">-1</span>) &#123; isWord = <span class="literal">true</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span>(!child[str[idx] - <span class="string">&#x27;a&#x27;</span>]) child[str[idx] - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        child[str[idx] - <span class="string">&#x27;a&#x27;</span>]-&gt;build(str, --idx);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == <span class="number">-1</span> || isWord) <span class="keyword">return</span> isWord;</span><br><span class="line">        <span class="keyword">return</span> child[str[idx] - <span class="string">&#x27;a&#x27;</span>] ? child[str[idx] - <span class="string">&#x27;a&#x27;</span>]-&gt;search(str, --idx) : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* child[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> isWord;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamChecker</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StreamChecker(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; word : words) root-&gt;build(word, word.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~StreamChecker() &#123; <span class="keyword">delete</span> root; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> letter)</span> </span>&#123; <span class="keyword">return</span> root-&gt;search(curstr += letter, curstr.size() - <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">    <span class="built_in">string</span> curstr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/1032.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>Recursive</tag>
        <tag>Tree</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 August</tag>
        <tag>LeetCode - Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 124 解題紀錄</title>
    <url>/LeetCode-124/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">LeetCode - 124. Binary Tree Maximum Path Sum</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 Binary Tree，求最大路徑和。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用遞迴即可。核心觀念為：最大路徑和有沒有包含 <code>root</code> ( 自己 )？</p>
<ul>
<li><strong>若有：</strong>最大路徑和為：<code>左邊的最大路徑和</code> ( 需包含 <code>root</code>，但可以不選) + <code>root-&gt;val</code> + <code>右邊的最大路徑和</code> ( 需包含 <code>root</code>，但可以不選)。</li>
<li><strong>若沒有：</strong>最大路徑和為：<code>左邊的最大路徑和</code> ( 任意起點任意終點 ) 及 <code>右邊的最大路徑和</code> ( 任意起點任意終點 ) 兩者取其大。</li>
</ul>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 找出以 root 為起點的最大路徑和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPath</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max(maxPath(root-&gt;left) + root-&gt;val, max(maxPath(root-&gt;right) + root-&gt;val, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找出任意起點任意終點的最大路徑和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(!root) </span><br><span class="line">           <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        <span class="keyword">return</span> max(maxPathSum(root-&gt;left), max(maxPath(root-&gt;left) + root-&gt;val + maxPath(root-&gt;right), maxPathSum(root-&gt;right)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/124.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Recursive</tag>
        <tag>Tree</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 1526 解題紀錄</title>
    <url>/LeetCode-1526/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/">LeetCode - 1526. Minimum Number of Increments on Subarrays to Form a Target Array</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列 <code>target</code>，求一個同等大小，元素值為 0 的陣列，建成 <code>target</code> 那樣需要建造幾層。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>想像成是在爬山，只有在走上坡的時候才需要建造，走下坡時因為上坡已經建過了所以就不用再建。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; pre)</span><br><span class="line">                res += i - pre;</span><br><span class="line">            pre = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/1526.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 23 解題紀錄</title>
    <url>/LeetCode-23/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/merge-k-sorted-lists/">LeetCode - 23. Merge k Sorted Lists</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給 k 個已經由小到大排序好的 Lists，將全部合成一個由小到大排序的 List。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 priority_queue 幫我們排序，由於是自定義的型態，所以需要自己寫比較函數。先遍歷一次 <code>lists</code> 將所有 list 的 head 都推入，接著將 <code>pq.top()</code> 連接，若 <code>pq.top()-&gt;next</code> 存在，就重新推入。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](ListNode* l, ListNode* r) &#123; <span class="keyword">return</span> l-&gt;val &gt; r-&gt;val; &#125;;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;ListNode*, <span class="built_in">vector</span>&lt;ListNode*&gt;, <span class="keyword">decltype</span>(cmp)&gt; pq(cmp);</span><br><span class="line">        <span class="keyword">auto</span> head = <span class="keyword">new</span> ListNode(), tail = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ptr : lists) <span class="keyword">if</span>(ptr) pq.push(ptr);</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;next = pq.top(), tail = tail-&gt;next, pq.pop();</span><br><span class="line">            <span class="keyword">if</span>(tail-&gt;next) pq.push(tail-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/23.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Priority_queue</tag>
        <tag>List</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 25 解題紀錄</title>
    <url>/LeetCode-25/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/reverse-nodes-in-k-group/">LeetCode - 25. Reverse Nodes in k-Group</a></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>利用 Vector 將 Node 暫存，當達到 <code>k</code> 個時將他們 Reverse，需要注意的是每個 Group 也需要連接好。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span> || !head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;ListNode*&gt; v;</span><br><span class="line">        <span class="keyword">auto</span> curr = head;</span><br><span class="line">        <span class="keyword">auto</span> newHead = head;</span><br><span class="line">        <span class="keyword">auto</span> lastNode = head;</span><br><span class="line">        <span class="keyword">bool</span> firstGroup = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            v.push_back(curr);</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (v.size() == k) &#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = curr;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = v.size() - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                    v[i]-&gt;next = v[i - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                v[<span class="number">0</span>]-&gt;next = tmp;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (!firstGroup) newHead = v.back();</span><br><span class="line">                <span class="keyword">else</span> lastNode-&gt;next = v.back();</span><br><span class="line"></span><br><span class="line">                lastNode = v[<span class="number">0</span>];</span><br><span class="line">                </span><br><span class="line">                firstGroup = <span class="literal">true</span>;</span><br><span class="line">                </span><br><span class="line">                v.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 41 解題紀錄 / September LeetCoding Challenge Day 30</title>
    <url>/LeetCode-41/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/first-missing-positive/">LeetCode - 41. First Missing Positive</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列，求從 1 開始的正整數哪個最先沒有出現在陣列中。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先使用 Index Sort 將陣列排序好後從頭開始尋找即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        nums.insert(begin(nums), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">            <span class="keyword">while</span>(nums[i] != i &amp;&amp; nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; nums.size() &amp;&amp; nums[i] != nums[nums[i]]) swap(nums[i], nums[nums[i]]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i) <span class="keyword">if</span>(nums[i] != i) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/41.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 September</tag>
        <tag>LeetCode - Hard</tag>
        <tag>Index Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 4 解題紀錄</title>
    <url>/LeetCode-4/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/median-of-two-sorted-arrays/">LeetCode - 4. Median of Two Sorted Arrays</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個由小到大排序的陣列，求兩陣列結合後的中位數。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>透過 Merge Sort 將兩個陣列結合，之後找出中位數即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.size() + nums2.size();</span><br><span class="line">        nums1 = merge(nums1, nums2);</span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">2</span> ? nums1[n / <span class="number">2</span>] : <span class="keyword">double</span>(nums1[n / <span class="number">2</span>] + nums1[n / <span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = v1.size(), n2 = v2.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(n1 + n2)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, i1 = <span class="number">0</span>, i2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i1 &lt; n1 || i2 &lt; n2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i1 &gt;= n1) v[i++] = v2[i2++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i2 &gt;= n2) v[i++] = v1[i1++];</span><br><span class="line">            <span class="keyword">else</span> v[i++] = v1[i1] &lt; v2[i2] ? v1[i1++] : v2[i2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/4.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 51 解題紀錄</title>
    <url>/LeetCode-51/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/n-queens/">LeetCode - 51. N-Queens</a></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>列為單位，上而下 DFS 模擬。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; results;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">queens</span><span class="params">(n, <span class="built_in">string</span>(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        dfs(n, <span class="number">0</span>, queens, results);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> currRow, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; queens, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; results)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currRow == n) &#123;</span><br><span class="line">            results.push_back(queens);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isValid(n, queens, currRow, i)) &#123;</span><br><span class="line">                queens[currRow][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                dfs(n, currRow + <span class="number">1</span>, queens, results);</span><br><span class="line">                queens[currRow][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// row, col: new queen&#x27;s position</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; queens, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// check if queen on the same columns</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queens[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// check if queen on left-top</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; --i, --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queens[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// check if queen on right-top</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; --i, ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queens[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[List[str]]:</span></span><br><span class="line">        results = []</span><br><span class="line">        queens = [[<span class="string">&#x27;.&#x27;</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        self.dfs(n, <span class="number">0</span>, queens, results)</span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, n, currRow, queens, results</span>):</span></span><br><span class="line">        <span class="keyword">if</span> currRow == n:</span><br><span class="line">            results.append([<span class="string">&#x27;&#x27;</span>.join(i) <span class="keyword">for</span> i <span class="keyword">in</span> queens])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> self.isValid(n, queens, currRow, i):</span><br><span class="line">                queens[currRow][i] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">                self.dfs(n, currRow + <span class="number">1</span>, queens, results)</span><br><span class="line">                queens[currRow][i] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, n, queens, row, col</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        row, col: new queen&#x27;s position</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># check if queen on the same columns</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">            <span class="keyword">if</span> queens[i][col] == <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># check if queen on left-top</span></span><br><span class="line">        i, j = row - <span class="number">1</span>, col - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> queens[i][j] == <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># check if queen on right-top</span></span><br><span class="line">        i, j = row - <span class="number">1</span>, col + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; n:</span><br><span class="line">            <span class="keyword">if</span> queens[i][j] == <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 52 解題紀錄</title>
    <url>/LeetCode-52/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/n-queens-ii/">LeetCode - 52. N-Queens II</a></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>列為單位，上而下 DFS 模擬。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; results;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">queens</span><span class="params">(n, <span class="built_in">string</span>(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        dfs(n, <span class="number">0</span>, queens, results);</span><br><span class="line">        <span class="keyword">return</span> results.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> currRow, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; queens, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; results)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currRow == n) &#123;</span><br><span class="line">            results.push_back(queens);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isValid(n, queens, currRow, i)) &#123;</span><br><span class="line">                queens[currRow][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                dfs(n, currRow + <span class="number">1</span>, queens, results);</span><br><span class="line">                queens[currRow][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// row, col: new queen&#x27;s position</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; queens, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// check if queen on the same columns</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queens[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// check if queen on left-top</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; --i, --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queens[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// check if queen on right-top</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; --i, ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queens[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        results = []</span><br><span class="line">        queens = [[<span class="string">&#x27;.&#x27;</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        self.dfs(n, <span class="number">0</span>, queens, results)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(results)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, n, currRow, queens, results</span>):</span></span><br><span class="line">        <span class="keyword">if</span> currRow == n:</span><br><span class="line">            results.append([<span class="string">&#x27;&#x27;</span>.join(i) <span class="keyword">for</span> i <span class="keyword">in</span> queens])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> self.isValid(n, queens, currRow, i):</span><br><span class="line">                queens[currRow][i] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">                self.dfs(n, currRow + <span class="number">1</span>, queens, results)</span><br><span class="line">                queens[currRow][i] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, n, queens, row, col</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        row, col: new queen&#x27;s position</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># check if queen on the same columns</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">            <span class="keyword">if</span> queens[i][col] == <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># check if queen on left-top</span></span><br><span class="line">        i, j = row - <span class="number">1</span>, col - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> queens[i][j] == <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># check if queen on right-top</span></span><br><span class="line">        i, j = row - <span class="number">1</span>, col + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; n:</span><br><span class="line">            <span class="keyword">if</span> queens[i][j] == <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 60 解題紀錄</title>
    <url>/LeetCode-60/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/permutation-sequence/">LeetCode - 60. Permutation Sequence</a></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>數學題。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> numbers = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">factorial</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            factorial[i] = i * factorial[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        --k; <span class="comment">// for index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = k / factorial[i - <span class="number">1</span>];</span><br><span class="line">            k %= factorial[i - <span class="number">1</span>];</span><br><span class="line">            result += numbers[j];</span><br><span class="line">            numbers.erase(j, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        numbers = [<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">        </span><br><span class="line">        factorial = [<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(factorial)):</span><br><span class="line">            factorial[i] = i * factorial[i - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># for index</span></span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            j = k // factorial[i - <span class="number">1</span>]</span><br><span class="line">            k %= factorial[i - <span class="number">1</span>]</span><br><span class="line">            result += numbers[j]</span><br><span class="line">            <span class="keyword">del</span> numbers[j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 57 解題紀錄 / September LeetCoding Challenge Day 13</title>
    <url>/LeetCode-57/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/insert-interval/">LeetCode - 57. Insert Interval</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個代表區間的陣列，及一個要插入陣列的區間，插入後需要將重疊的部分合併。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>由於陣列已經依照起始點的位置排序過，所以只需要將區間插入到正確的位置，接著利用 LeetCode - 56 的作法來將重疊的部分合併即可。詳細作法可參考本篇文章：<a href="../LeetCode%20-%2056/" target="_blank">LeetCode - 56 解題紀錄</a>。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; insert(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; newInterval)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = intervals.begin();</span><br><span class="line">        <span class="keyword">while</span>(iter != intervals.end() &amp;&amp; iter-&gt;at(<span class="number">0</span>) &lt; newInterval[<span class="number">0</span>]) ++iter;</span><br><span class="line">        intervals.insert(iter, newInterval);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; interval : intervals)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res.empty() || interval[<span class="number">0</span>] &gt; res.back()[<span class="number">1</span>]) res.emplace_back(interval);</span><br><span class="line">            <span class="keyword">else</span> res.back()[<span class="number">1</span>] = max(res.back()[<span class="number">1</span>], interval[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/57.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 September</tag>
        <tag>LeetCode - Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 72 解題紀錄</title>
    <url>/LeetCode-72/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/edit-distance/">LeetCode - 72. Edit Distance</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個 String <code>word1</code>、<code>word2</code>，求最少的操作數使得 <code>word1</code> 等於 <code>word2</code>。<span id="more"></span>操作有以下三種：</p>
<ul>
<li><strong>插入</strong></li>
<li><strong>刪除</strong></li>
<li><strong>取代</strong></li>
</ul>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>動態規劃，核心想法為，目前這兩個字是否相等？若相等則表示不需要操作 <code>dp[i][j] = dp[i - 1][j - 1]</code>，若不相等則 <code>dp[i][j]</code> 為 <code>dp[i - 1][j]</code>、<code>dp[i][j - 1]</code>、<code>dp[i - 1][j - 1]</code> 三者最小值加一。需要注意的是，邊界需要初始化。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = word1.size(), l2 = word2.size();</span><br><span class="line">        <span class="keyword">auto</span> dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(l1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(l2 + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= l1; ++i)</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= l2; ++j)</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l1; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= l2; ++j)</span><br><span class="line">                <span class="keyword">if</span>(word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="number">1</span> + min(dp[i - <span class="number">1</span>][j], min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">return</span> dp[l1][l2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/72.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 952 解題紀錄 / August LeetCoding Challenge Day 30</title>
    <url>/LeetCode-952/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/largest-component-size-by-common-factor/">LeetCode - 952. Largest Component Size by Common Factor</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>待編輯…</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>待編輯…</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DSU(<span class="keyword">int</span> n) : p(n) &#123; <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) p[i] = i; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> _union(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; p[_find(x)] = p[_find(y)]; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> _find(<span class="keyword">int</span> x) &#123; <span class="keyword">if</span>(p[x] != x) p[x] = _find(p[x]); <span class="keyword">return</span> p[x]; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestComponentSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = *max_element(A.begin(), A.end());</span><br><span class="line">        <span class="function">DSU <span class="title">dsu</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> a : A) <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(a); ++i)</span><br><span class="line">            <span class="keyword">if</span>(!(a % i)) dsu._union(a, i), dsu._union(a, a / i);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> a : A) ans = max(ans, ++m[dsu._find(a)]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/952.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 August</tag>
        <tag>Puzzled</tag>
        <tag>LeetCode - Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 980 解題紀錄 / September LeetCoding Challenge Day 20</title>
    <url>/LeetCode-980/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/unique-paths-iii/">LeetCode - 980. Unique Paths III</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列代表二維地圖，1 代表起點，2 代表終點，0 代表可以經過，-1 代表無法經過，求有幾條不同的路徑可以從 1 走到 2 並且所有 0 都經過一次。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 dfs 的概念，先找出 0 的數量及起點的座標，接著使用 dfs，從起點的座標開始，當經過 0 時將 <code>n</code> 加一，並將當前座標先設為 -1，在進入下一層 dfs，結束後將當前座標回復為 0，最後當走到 2 時，若 <code>n</code> 與 <code>target</code> 相等代表有一條達成條件的路徑。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsIII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, target&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i&#123;&#125;; i &lt; grid.size(); ++i) <span class="keyword">for</span>(<span class="keyword">int</span> j&#123;&#125;; j &lt; grid[<span class="number">0</span>].size(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!grid[i][j]) ++target;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>) x = j, y = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(grid, x, y, <span class="number">0</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= grid[<span class="number">0</span>].size() || y &lt; <span class="number">0</span> || y &gt;= grid.size() || grid[y][x] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[y][x] == <span class="number">2</span>) <span class="keyword">return</span> n == target;</span><br><span class="line">        <span class="keyword">if</span>(!grid[y][x]) ++n;</span><br><span class="line">        grid[y][x] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = dfs(grid, x + <span class="number">1</span>, y, n, target) + dfs(grid, x - <span class="number">1</span>, y, n, target) + dfs(grid, x, y + <span class="number">1</span>, n, target) + dfs(grid, x, y - <span class="number">1</span>, n, target);</span><br><span class="line">        grid[y][x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/980.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Recursive</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 September</tag>
        <tag>LeetCode - Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 1008 解題紀錄</title>
    <url>/LeetCode-1008/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/">LeetCode - 1008. Construct Binary Search Tree from Preorder Traversal</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列，將陣列造成一個二元搜尋樹。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><ul>
<li><strong>想法：</strong>樹根的值一定是 <code>preorder[0]</code>，使用 <code>pos</code> 來記數，然後先建左邊，建到 <code>preorder[pos]</code> 大於樹根的值時再建右邊。</li>
<li><strong>作法：</strong>使用遞迴即可。</li>
</ul>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">bstFromPreorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> max = INT_MAX)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == preorder.size() || preorder[pos] &gt; max)   </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(preorder[pos], bstFromPreorder(preorder, preorder[pos++]), bstFromPreorder(preorder, max));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/1008.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Recursive</tag>
        <tag>Tree</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 1035 解題紀錄</title>
    <url>/LeetCode-1035/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/uncrossed-lines/">LeetCode - 1035. Uncrossed Lines</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個陣列，將陣列中相同的元素連線，連線不能交叉，求最大連線數。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>其實題目的答案就是兩者的 LCS。<br>找 LCS 的作法可參考本篇文章：<a href="../LeetCode%20-%201143/" target="_blank">LeetCode - 1143 解題紀錄</a>。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxUncrossedLines</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.size(), n = B.size();</span><br><span class="line">        <span class="keyword">auto</span> dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                dp[i][j] = A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>] ? dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span> : max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/1035.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 1041 解題紀錄 / September LeetCoding Challenge Day 17</title>
    <url>/LeetCode-1041/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/robot-bounded-in-circle/">LeetCode - 1041. Robot Bounded In Circle</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個字串，代表機器人移動的指令，機器人會不斷重複這段指令，求機器人的移動範圍是否可以用一個圓圈圍住。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>若是要滿足題目的條件，則做完一段指令後機器人需要回到原點，或是機器人面向跟最初不同的方向 ( 向北 )，紀錄機器人的座標及面向，並遍歷字串模擬完成指令後的狀態即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRobotBounded</span><span class="params">(<span class="built_in">string</span> instructions)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pos, face&#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : instructions)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;G&#x27;</span>) pos.first += face.first, pos.second += face.second;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;L&#x27;</span>) face = &#123;-face.second, face.first&#125;;</span><br><span class="line">            <span class="keyword">else</span> face = &#123;face.second, -face.first&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (!pos.first &amp;&amp; !pos.second) || face.first || face.second != <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/1041.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 September</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 1094 解題紀錄 / September LeetCoding Challenge Day 21</title>
    <url>/LeetCode-1094/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/car-pooling/">LeetCode - 1094. Car Pooling</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列 <code>trips</code> 及一個整數 <code>capacity</code>，<code>trips</code> 中每個元素包含三個數，依次代表<code>搭車人數</code>、<code>上車站</code>、<code>下車站</code>，<code>capacity</code> 代表公車能同時容納的最大人數，求公車在運送期間人數是否會超過 <code>capacity</code>。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>由於題目有說上車站及下車站的值不會超過 1000，所以定義一個陣列表示站，紀錄每個站會變動的人數，先遍歷 <code>trips</code>，將上車站加上上車的人數，下車站減去下車的人數，接著遍歷 <code>timeStamp</code>，紀錄到目前為止車上的人數，若是人數大於 <code>capacity</code> 回傳 false，否則遍歷結束後回傳 true。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">carPooling</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; trips, <span class="keyword">int</span> capacity)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> timeStamp[<span class="number">1001</span>] = &#123;&#125;, curCap&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : trips) timeStamp[v[<span class="number">1</span>]] += v[<span class="number">0</span>], timeStamp[v[<span class="number">2</span>]] -= v[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; num : timeStamp)</span><br><span class="line">        &#123;</span><br><span class="line">            curCap += num;</span><br><span class="line">            <span class="keyword">if</span>(curCap &gt; capacity) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/1094.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 September</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 11 解題紀錄</title>
    <url>/LeetCode-11/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/container-with-most-water/">LeetCode - 11. Container With Most Water</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列代表容器的兩邊長，求最大容積。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用雙指針即可，而移動指針時只需要移動長度較小的指針即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = height.size(), m = INT_MIN, l = <span class="number">0</span>, r = n - <span class="number">1</span>, L, W;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            L = min(height[l], height[r]);</span><br><span class="line">            W = r - l;</span><br><span class="line">            m = max(m, L * W);</span><br><span class="line">            height[l] &gt; height[r] ? --r : ++l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/11.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 1143 解題紀錄</title>
    <url>/LeetCode-1143/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/longest-common-subsequence/">LeetCode - 1143. Longest Common Subsequence</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個 String，找出它們 LCS 的長度。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用動態規劃即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = text1.size(), n2 = text2.size();</span><br><span class="line">        <span class="comment">// dp[i][j] = text1[i], text2[j] 的 LCS</span></span><br><span class="line">        <span class="keyword">auto</span> dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n2 + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; ++j)</span><br><span class="line">                <span class="comment">// 如果兩者相等，最大長度為兩者 - 1 的最大長度 + 1</span></span><br><span class="line">                <span class="keyword">if</span>(text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 否則為兩者其中一者 - 1 的最大值</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/1143.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 12 解題紀錄</title>
    <url>/LeetCode-12/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/integer-to-roman/">LeetCode - 12. Integer to Roman</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個整數，將此整數轉為羅馬數字。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>建表比對即可，特別的是 4、9、40、90、400、900 也需要建。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">12</span>;</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; dict[] = &#123;&#123;<span class="string">&quot;I&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;IV&quot;</span>, <span class="number">4</span>&#125;, &#123;<span class="string">&quot;V&quot;</span>, <span class="number">5</span>&#125;, &#123;<span class="string">&quot;IX&quot;</span>, <span class="number">9</span>&#125;, &#123;<span class="string">&quot;X&quot;</span>, <span class="number">10</span>&#125;, &#123;<span class="string">&quot;XL&quot;</span>, <span class="number">40</span>&#125;, &#123;<span class="string">&quot;L&quot;</span>, <span class="number">50</span>&#125;, &#123;<span class="string">&quot;XC&quot;</span>, <span class="number">90</span>&#125;, &#123;<span class="string">&quot;C&quot;</span>, <span class="number">100</span>&#125;, &#123;<span class="string">&quot;CD&quot;</span>, <span class="number">400</span>&#125;, &#123;<span class="string">&quot;D&quot;</span>, <span class="number">500</span>&#125;, &#123;<span class="string">&quot;CM&quot;</span>, <span class="number">900</span>&#125;, &#123;<span class="string">&quot;M&quot;</span>, <span class="number">1000</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(pos &amp;&amp; dict[pos].second &gt; num)</span><br><span class="line">                --pos;</span><br><span class="line">            <span class="keyword">while</span>(num &gt;= dict[pos].second)</span><br><span class="line">                res += dict[pos].first, num -= dict[pos].second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/12.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 123 解題紀錄 / August LeetCoding Challenge Day 16</title>
    <url>/LeetCode-123/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/">LeetCode - 123. Best Time to Buy and Sell Stock III</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列代表每日的股票價格，求買賣兩次後的最高收益。當手上有一支股票時就無法買第二支股票。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>動態規劃，轉移方程為：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cost1 = min(p, cost1);</span><br><span class="line">profit1 = max(p - cost1, profit1);</span><br><span class="line">cost2 = min(p - profit1, cost2);</span><br><span class="line">profit2 = max(p - cost2, profit2);</span><br></pre></td></tr></table></figure>

<p>將 <code>profit1</code> 的收益與 <code>cost2</code> 結合，<code>profit2</code> 即為最後的總收益，</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cost1 = INT_MAX, cost2 = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> profit1 = <span class="number">0</span>, profit2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p : prices)</span><br><span class="line">        &#123;</span><br><span class="line">            cost1 = min(p, cost1);</span><br><span class="line">            profit1 = max(p - cost1, profit1);</span><br><span class="line">            cost2 = min(p - profit1, cost2);</span><br><span class="line">            profit2 = max(p - cost2, profit2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/123.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 August</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 129 解題紀錄</title>
    <url>/LeetCode-129/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/">LeetCode - 129. Sum Root to Leaf Numbers</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 Binary Tree，從樹根到每片葉子中間包含的數字代表一串十進位的數字，求總和。</p>
<span id="more"></span>

<p>類似題目：<a href="../LeetCode%20-%201022/" target="_blank">LeetCode - 1022 解題紀錄 / September LeetCoding Challenge Day 8</a></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用遞迴的概念遍歷整棵樹，<code>sum</code> 紀錄到目前的十進位總和，若是目前的 <code>node</code> 已經是葉子，直接回傳 <code>sum</code>，否則回傳 <code>sumNumbers(root-&gt;left, sum) + sumNumbers(root-&gt;right, sum)</code>。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum = <span class="number">0</span>)</span> <span class="comment">// add sum</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sum = sum * <span class="number">10</span> + root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> !root-&gt;left &amp;&amp; !root-&gt;right ? sum : sumNumbers(root-&gt;left, sum) + sumNumbers(root-&gt;right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/129.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Recursive</tag>
        <tag>Tree</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 1291 解題紀錄 / September LeetCoding Challenge Day 19</title>
    <url>/LeetCode-1291/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/sequential-digits/">LeetCode - 1291. Sequential Digits</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個整數 <code>low</code>, <code>high</code>，求大於等於 <code>low</code> 且小於等於 <code>high</code> 的所有整數，整數需要每一位都比前一位的值大 1，如 123、234、3456 …，且返回的陣列須按大小排列。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>題目的要求可以想成從 “123456789” 中找在範圍中的連續子串，先找出 <code>low</code> 及 <code>high</code> 的位數，因為在範圍中的數字位數必定會在 <code>low</code> 及 <code>high</code> 的位數中間，接著使用兩個迴圈，第一層代表位數，第二層為起點 ( 從 0 到 9 - i )，這樣做的同時確保了數字會由小到大，接著判斷，若是數字大於 <code>high</code> 則接下來同位數的數都不會在範圍中，最後判斷若是大於等於 <code>low</code> 則存入結果。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sequentialDigits</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ldigits = to_string(low).length(), hdigits = to_string(high).length();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">&quot;123456789&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = ldigits; i &lt;= hdigits; ++i) <span class="keyword">for</span>(<span class="keyword">int</span> j&#123;&#125;; j &lt; <span class="number">10</span> - i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = atoi(str.substr(j, i).c_str());</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; high) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt;= low) ret.emplace_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/1291.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 September</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 13 解題紀錄</title>
    <url>/LeetCode-13/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/roman-to-integer/">LeetCode - 13. Roman to Integer</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個羅馬數字，將此羅馬數字轉為整數。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>建表比對即可，需先比對兩個英文字母的再比對一個英文字母的避免比對錯誤。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos, res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; dict1[] = &#123;&#123;<span class="string">&quot;I&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;V&quot;</span>, <span class="number">5</span>&#125;, &#123;<span class="string">&quot;X&quot;</span>, <span class="number">10</span>&#125;, &#123;<span class="string">&quot;L&quot;</span>, <span class="number">50</span>&#125;, &#123;<span class="string">&quot;C&quot;</span>, <span class="number">100</span>&#125;, &#123;<span class="string">&quot;D&quot;</span>, <span class="number">500</span>&#125;, &#123;<span class="string">&quot;M&quot;</span>, <span class="number">1000</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; dict2[] = &#123;&#123;<span class="string">&quot;IV&quot;</span>, <span class="number">4</span>&#125;, &#123;<span class="string">&quot;IX&quot;</span>, <span class="number">9</span>&#125;, &#123;<span class="string">&quot;XL&quot;</span>, <span class="number">40</span>&#125;, &#123;<span class="string">&quot;XC&quot;</span>, <span class="number">90</span>&#125;, &#123;<span class="string">&quot;CD&quot;</span>, <span class="number">400</span>&#125;, &#123;<span class="string">&quot;CM&quot;</span>, <span class="number">900</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : dict2)</span><br><span class="line">            <span class="keyword">while</span>((pos = s.find(i.first)) != <span class="number">-1</span>)</span><br><span class="line">                res += i.second, s[pos] = <span class="string">&#x27;*&#x27;</span>, s[++pos] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : dict1)</span><br><span class="line">            <span class="keyword">while</span>((pos = s.find(i.first)) != <span class="number">-1</span>)</span><br><span class="line">                res += i.second, s[pos] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/13.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 1305 解題紀錄 / September LeetCoding Challenge Day 5</title>
    <url>/LeetCode-1305/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/all-elements-in-two-binary-search-trees/">LeetCode - 1305. All Elements in Two Binary Search Trees</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個 Binary Search Tree，回傳一個包含兩個樹的所有值並且以小到大排序後的陣列。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>由於 BST 的特性，我們可以先取 <code>root</code> 的左子樹，再取 <code>root-&gt;val</code>，最後取 <code>root</code> 的右子樹即可得到一個含有 BST 的所有值並排序後的陣列。對於本題來說，我們先取得兩個排序後的陣列，最後使用 Merge Sort 將兩個陣列合併即可得到最後的陣列。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getAllElements</span><span class="params">(TreeNode* root1, TreeNode* root2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t1, t2, v;</span><br><span class="line">        getEle(t1, root1), getEle(t2, root2);</span><br><span class="line">        <span class="keyword">return</span> merge(t1, t2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getEle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v, TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        getEle(v, root-&gt;left);</span><br><span class="line">        v.emplace_back(root-&gt;val);</span><br><span class="line">        getEle(v, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = v1.size(), n2 = v2.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(n1 + n2)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, i1 = <span class="number">0</span>, i2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i1 &lt; n1 || i2 &lt; n2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i1 &gt;= n1) v[i++] = v2[i2++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i2 &gt;= n2) v[i++] = v1[i1++];</span><br><span class="line">            <span class="keyword">else</span> v[i++] = v1[i1] &lt; v2[i2] ? v1[i1++] : v2[i2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/1305.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 September</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 1277 解題紀錄</title>
    <url>/LeetCode-1277/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/count-square-submatrices-with-all-ones/">LeetCode - 1277. Count Square Submatrices with All Ones</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個二維陣列，裡面包含 0 和 1，求出其中值為 1 的元素能組出幾個不同的正方形。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>對於陣列中的每個元素來說，若該值為 1，能組出的正方形個數為，<code>左邊那個元素最多能組出的正方形個數</code>、<code>上面那個元素最多能組出的正方形個數</code> 和 <code>左上角那個元素最多能組出的正方形個數</code>，三者的最小值 + 1，依照此想法做動態規劃即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSquares</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> height = matrix.size(), width = matrix[<span class="number">0</span>].size(), count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; j != <span class="number">0</span> &amp;&amp; matrix[i][j] == <span class="number">1</span>)</span><br><span class="line">                    matrix[i][j] += min(&#123;matrix[i - <span class="number">1</span>][j], matrix[i][j - <span class="number">1</span>], matrix[i - <span class="number">1</span>][j - <span class="number">1</span>]&#125;);</span><br><span class="line">                count += matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/1277.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 134 解題紀錄 / September LeetCoding Challenge Day 23</title>
    <url>/LeetCode-134/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/gas-station/">LeetCode - 134. Gas Station</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>有一個環形的加油站點，車子的油箱容量無限，給兩個陣列分別代表兩個加油站間需要消耗的油量以及到加油站能補充的油量，求從哪個起點開始可以走完一圈，若無法走完則回傳 -1。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>貪心法，一開始先選 0 作為起點，接著往下走，<code>curr</code> 紀錄目前剩下的油量若是油量不夠到下一個點則選擇下一個點作為起點，同時記錄總獲得的油量及消耗的油量，結束時若是總油量大於等於 0 代表可以從 <code>start</code> 開始走能走完一圈。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total&#123;&#125;, curr&#123;&#125;, start&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i&#123;&#125;; i &lt; gas.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            curr += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span>(curr &lt; <span class="number">0</span>) start = i + <span class="number">1</span>, curr = <span class="number">0</span>;</span><br><span class="line">            total += gas[i] - cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total &gt;= <span class="number">0</span> ? start : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/134.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 September</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 139 解題紀錄 / September LeetCoding Challenge Day 29</title>
    <url>/LeetCode-139/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/word-break/">LeetCode - 139. Word Break</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列及一個字串，求字串能否由陣列中的字串組成。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用動態規劃，<code>dp[i]</code> 代表前 <code>i</code> 個字符組成的字串可以被字典中的字串組成。先在 <code>s</code> 前面增加一個空格方便計算，使用一個迴圈遍歷字串，將目前遍歷到的字串分為兩個部分，若前面的部分及後面的部分都可以被組成則代表目前遍歷到的字串可以被組成。最後回傳 <code>dp[n]</code> 即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">set</span><span class="params">(begin(wordDict), end(wordDict))</span></span>;</span><br><span class="line">        s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            <span class="keyword">if</span>(dp[j] &amp;&amp; <span class="built_in">set</span>.count(s.substr(j + <span class="number">1</span>, i - j))) &#123; dp[i] = <span class="number">1</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/139.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>String</tag>
        <tag>Vector</tag>
        <tag>Unordered_set</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 September</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 143 解題紀錄 / August LeetCoding Challenge Day 20</title>
    <url>/LeetCode-143/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/reorder-list/">LeetCode - 143. Reorder List</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 List，依照題目的要求重新排序。<span id="more"></span><br><strong>※</strong> 題目規定不能改變 <code>node</code> 的值。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>我們先取得中間的節點 ( 方法可以參考本篇文章：<a href="../LeetCode%20-%20876/" target="_blank">LeetCode - 876 解題紀錄</a> )，接著將中間到尾端的節點反轉，最後依照要求重新連接即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> mid = findMid(head), l1 = head, l2 = mid-&gt;next;</span><br><span class="line">        mid-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        l2 = _reverse(l2);</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> _next = l1-&gt;next;</span><br><span class="line">            l1-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">            l1-&gt;next-&gt;next = _next;</span><br><span class="line">            l1 = _next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">findMid</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) fast = fast-&gt;next-&gt;next, slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode* _reverse(ListNode* head)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* newhead = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> _next = head-&gt;next;</span><br><span class="line">            head-&gt;next = newhead;</span><br><span class="line">            newhead = head;</span><br><span class="line">            head = _next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/143.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>List</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 August</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 146 解題紀錄</title>
    <url>/LeetCode-146/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/lru-cache/">LeetCode - 146. LRU Cache</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>建立一個類似快取記憶體的 Class，及對應的一些功能。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 <code>list&lt;pair&lt;int, int&gt;&gt;</code> 儲存資料，再利用 <code>unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt;</code> 達到減少時間複雜度的效果。<br><strong>※</strong> 對於 <code>put</code> 來說，如果資料已經滿了，那新的資料就要覆蓋最久沒有調用到的資料。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; cache; <span class="comment">// 儲存 key 及 value</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator&gt; hash; <span class="comment">// 儲存 key 及對應的 node，方便尋找及刪除</span></span><br><span class="line">    <span class="keyword">int</span> Cap;</span><br><span class="line"></span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        Cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先使用 key 尋找 node</span></span><br><span class="line">        <span class="keyword">auto</span> it = hash.find(key);</span><br><span class="line">        <span class="comment">// 如果找不到</span></span><br><span class="line">        <span class="keyword">if</span>(it == hash.end())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 將這個 node 移到最前面</span></span><br><span class="line">        cache.splice(cache.begin(), cache, it-&gt;second);</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先使用 key 尋找 node</span></span><br><span class="line">        <span class="keyword">auto</span> it = hash.find(key);</span><br><span class="line">        <span class="comment">// 如果找到</span></span><br><span class="line">        <span class="keyword">if</span>(it != hash.end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 將原本的 value 改為新的 value</span></span><br><span class="line">            it-&gt;second-&gt;second = value;</span><br><span class="line">            <span class="comment">// 將這個 node 移到最前面</span></span><br><span class="line">            cache.splice(cache.begin(), cache, it-&gt;second);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 list 已經滿了</span></span><br><span class="line">        <span class="keyword">if</span>(cache.size() == Cap)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 刪除最後一個 node，同時 hash 裡面也必須刪除</span></span><br><span class="line">            hash.erase(cache.back().first);</span><br><span class="line">            cache.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 將新的值插入，同時也在 hash 裡面插入</span></span><br><span class="line">        cache.emplace_front(key, value);</span><br><span class="line">        hash[key] = cache.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/146.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="補充"><a href="#補充" class="headerlink" title="補充"></a>補充</h3><ul>
<li><code>splice()</code> 的功能是串接 List。</li>
<li><code>emplace_front()</code> 的功能和 <code>push_front()</code> 是一樣的，但是前者少了一個複製的動作，效率較高。</li>
</ul>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="http://zxi.mytechroad.com/blog/hashtable/leetcode-146-lru-cache/">花花酱 LeetCode 146. LRU Cache O(1)</a><br><a href="https://blog.csdn.net/bichenggui/article/details/4674900">list::splice()函数详解</a><br><a href="https://blog.csdn.net/Kprogram/article/details/82055673">STL - emplace 与 push 的区别</a><br><a href="http://www.cplusplus.com/reference/list/list/emplace_back/">list::emplace_back - C++ Reference</a><br><a href="http://www.cplusplus.com/reference/list/list/splice/">list::splice - C++ Reference</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Unordered_map</tag>
        <tag>List</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 1286 解題紀錄 / August LeetCoding Challenge Day 13</title>
    <url>/LeetCode-1286/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/iterator-for-combination/">LeetCode - 1286. Iterator for Combination</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>設計一個 Class，並完成題目要求完成的函式。</p>
<span id="more"></span>

<ul>
<li><strong>CombinationIterator(string characters, int combinationLength)：</strong><br>Constructor，<code>characters</code> 為排序好的字串並且每個字元只會出現一次，<code>combinationLength</code> 為組合的長度。</li>
<li><strong>next()：</strong> 按照字典序返回長度為 <code>combinationLength</code> 的下一個排列。</li>
<li><strong>hasNext()：</strong> 返回是否還能形成下一個排序。</li>
</ul>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>其實就是排序的問題，最小的情況就是 <code>characters</code> 的前 <code>combinationLength</code> 個字元，最大的情況就是 <code>characters</code> 的倒數 <code>combinationLength</code> 個字元。</p>
<ul>
<li><strong>CombinationIterator(string characters, int combinationLength)：</strong> 在構造的時候我們把最小的情況放入 <code>cur</code>，最大的情況放入 <code>last</code>，並紀錄原本的 <code>characters</code> 及 <code>combinationLength</code>。</li>
<li><strong>next()：</strong> 更新 <code>cur</code> 即可。</li>
<li><strong>hasNext()：</strong> 若是 <code>cur != last</code> 代表還能找出下一個排序。</li>
</ul>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CombinationIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CombinationIterator(<span class="built_in">string</span> characters, <span class="keyword">int</span> combinationLength) : orgin(characters), length(combinationLength), first(<span class="literal">true</span>) &#123;</span><br><span class="line">        cur = characters.substr(<span class="number">0</span>, combinationLength);</span><br><span class="line">        last = characters.substr(characters.size() - combinationLength);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first) &#123; first = <span class="literal">false</span>; <span class="keyword">return</span> cur; &#125;</span><br><span class="line">        <span class="keyword">int</span> pos = cur.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur[pos] == last[pos]) --pos;</span><br><span class="line">        <span class="keyword">int</span> opos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur[pos] != orgin[opos]) ++opos;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &lt; cur.size(); ++i)</span><br><span class="line">            cur[i] = orgin[opos + i + <span class="number">1</span> - pos];</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> cur != last; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> orgin;</span><br><span class="line">    <span class="built_in">string</span> cur;</span><br><span class="line">    <span class="built_in">string</span> last;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">bool</span> first;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/1286.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 August</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 15 解題紀錄</title>
    <url>/LeetCode-15/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/3sum/">LeetCode - 15. 3Sum</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列，求此陣列中所有三個元素值相加為 0 的組合。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>為了增加效率，先對陣列進行排序，接著遍歷陣列，先選定一個最左邊的數字，接著往右找是否存在相加為此數的相反數的組合，若存在代表找到一組，接著檢查 <code>l</code> 的右邊及 <code>r</code> 的左邊的數是否相同，避免找到重複的組合。同時再過程中若是 <code>nums[i] &gt; 0</code> 就可以不用再找了，因為我們是選定最左邊的數，且我們的陣列是排序過的，所以右邊不可能會有相加為此數的相反數的組合，同時要避免重複運算，所以若 <code>nums[i] == nums[i - 1]</code> 則直接 <code>continue</code>。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> target = -nums[i], l = i + <span class="number">1</span>, r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[l] + nums[r] == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    v.push_back(&#123; nums[i], nums[l], nums[r] &#125;);</span><br><span class="line">                    <span class="comment">// 避免儲存到一樣的結果</span></span><br><span class="line">                    <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] == nums[l + <span class="number">1</span>]) ++l;</span><br><span class="line">                    <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>]) --r;</span><br><span class="line">                    ++l, --r;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[l] + nums[r] &lt; target) ++l;</span><br><span class="line">                <span class="keyword">else</span> --r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/15.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 152 解題紀錄 / September LeetCoding Challenge Day 11</title>
    <url>/LeetCode-152/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/maximum-product-subarray/">LeetCode - 152. Maximum Product Subarray</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列，求陣列中最大的子陣列乘積。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>由於是乘積，極小值乘以負數時會變為極大值，所以需要同時保存目前的子陣列乘積最大值及最小值。使用動態規劃的概念，最大值為 <code>mx * nums[i]</code> 及 <code>nums[i]</code> 兩者取較大者，最小值為 <code>mn * nums[i]</code> 及 <code>nums[i]</code> 兩者取較小者，若是碰到目前元素為負數時，則需要將兩者互換再去判斷。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mx = nums[<span class="number">0</span>], mn = mx, res = mx, n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span>) swap(mx, mn);</span><br><span class="line">            mx = max(mx * nums[i], nums[i]);</span><br><span class="line">            mn = min(mn * nums[i], nums[i]);</span><br><span class="line">            res = max(res, mx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/152.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 September</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 1535 解題紀錄</title>
    <url>/LeetCode-1535/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/find-the-winner-of-an-array-game/">LeetCode - 1535. Find the Winner of an Array Game</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列及一個整數 <code>k</code>，每次比對陣列前兩個數字，比較大的留著，較小的放到陣列尾端，求贏了 <code>k</code> 次的數。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>其實放到尾端只是幌子，題目的答案其實只要遍歷一次陣列即可找到。定義一個 <code>currMax</code> 紀錄遍歷到目前的最大值，<code>count</code> 計算贏的次數，若 <code>count</code> 等於 <code>k</code> 就直接回傳 <code>currMax</code>，若遍歷完還沒回傳，代表 <code>currMax</code> 為最大值，直接回傳即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> currMax = arr[<span class="number">0</span>], count = <span class="number">0</span>, n = arr.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] &gt; currMax ? currMax = arr[i], count = <span class="number">1</span> : ++count;</span><br><span class="line">            <span class="keyword">if</span>(count == k)</span><br><span class="line">                <span class="keyword">return</span> currMax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currMax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/1535.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 1536 解題紀錄</title>
    <url>/LeetCode-1536/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/minimum-swaps-to-arrange-a-binary-grid/">LeetCode - 1536. Minimum Swaps to Arrange a Binary Grid</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個二維陣列，代表一個正方形，裡面的值只有 0 或 1。<span id="more"></span>題目要求第 <code>n</code> 行需要有 <code>邊長 - n - 1</code> 個 0 在最右邊，每次可以選擇一行與鄰近的行互換，求最少的交換次數，若題目無法達成要求的話回傳 - 1。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用一個陣列紀錄每行右邊 0 的個數，之後找到要搬移的行進行搬移並紀錄次數即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwaps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), target = n - <span class="number">1</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">zeroes</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ++zeroes[i];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i, --target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; n &amp;&amp; target &gt; zeroes[j])</span><br><span class="line">                ++j;</span><br><span class="line">            <span class="keyword">if</span>(j == n)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            zeroes.insert(zeroes.begin() + i, zeroes[j]);</span><br><span class="line">            zeroes.erase(zeroes.begin() + j + <span class="number">1</span>);</span><br><span class="line">            count += j - i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/1536-1.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<p>2020-09-01 重寫</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwaps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), target = n - <span class="number">1</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">zeroes</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">for</span>(<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; !grid[i][j]; ++zeroes[i], --j);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i, --target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; n &amp;&amp; target &gt; zeroes[j]) ++j;</span><br><span class="line">            <span class="keyword">if</span>(j == n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            zeroes.insert(zeroes.begin() + i, zeroes[j]);</span><br><span class="line">            zeroes.erase(zeroes.begin() + j + <span class="number">1</span>);</span><br><span class="line">            count += j - i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/1536-2.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 16 解題紀錄</title>
    <url>/LeetCode-16/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/3sum-closest/">LeetCode - 16. 3Sum Closest</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列及整數 <code>target</code>，求陣列內任意三數相加最接近 <code>target</code> 的值。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先將陣列由小到大排序。選定最左邊的那個數，接著選擇右邊兩數，<code>l</code> 從 <code>i + 1</code> 開始，<code>r</code> 從最後一個數開始，若這三者相加等於 <code>target</code> 直接回傳，否則檢查這次的值跟 <code>target</code> 的差距是否小於之前選定的，之後判斷若是這次的值大於 <code>target</code> 則代表 <code>r</code> 需要往前選，否則代表 <code>l</code> 需要往後選。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), res = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i&#123;&#125;; i &lt; n - <span class="number">2</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> l = i + <span class="number">1</span>, r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i] + nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span>(tmp == target) <span class="keyword">return</span> tmp;</span><br><span class="line">                res = <span class="built_in">abs</span>(tmp - target) &lt; <span class="built_in">abs</span>(res - target) ? tmp : res;</span><br><span class="line">                tmp &gt; target ? --r : ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/16.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>Unordered_map</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 165 解題紀錄 / September LeetCoding Challenge Day 9</title>
    <url>/LeetCode-165/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/compare-version-numbers/">LeetCode - 165. Compare Version Numbers</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個字串，代表兩個版本號，判斷兩者的大小。( leading zeroes 忽略不計 )</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用兩個指針，每一次都分別遍歷到 <code>.</code> 號為止，將這段字串轉換為整數並且比大小即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(<span class="built_in">string</span> version1, <span class="built_in">string</span> version2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i&#123;&#125;, j&#123;&#125;, n1 = version1.length(), n2 = version2.length();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n1 || j &lt; n2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp1&#123;&#125;, tmp2&#123;&#125;;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n1 &amp;&amp; version1[i] != <span class="string">&#x27;.&#x27;</span>) tmp1 = tmp1 * <span class="number">10</span> + version1[i++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; n2 &amp;&amp; version2[j] != <span class="string">&#x27;.&#x27;</span>) tmp2 = tmp2 * <span class="number">10</span> + version2[j++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            ++i, ++j;</span><br><span class="line">            <span class="keyword">if</span>(tmp1 != tmp2) <span class="keyword">return</span> tmp1 &gt; tmp2 ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/165.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 September</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 17 解題紀錄</title>
    <url>/LeetCode-17/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">LeetCode - 17. Letter Combinations of a Phone Number</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個只包含數字的字串，表示按下手機鍵盤的號碼及順序，求所有可能出現的字串。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先依照鍵盤及數字建表，之後使用 DFS 列出所有有可能的組合即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; dict = &#123;&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;, &#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;, &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>&#125;, &#123;<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;, &#123;<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;, &#123;<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>&#125;, &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>&#125;, &#123;<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">        dfs(<span class="built_in">string</span>(), digits, <span class="number">0</span>, v, dict);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> str, <span class="built_in">string</span>&amp; digits, <span class="keyword">int</span> idx, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; v, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; dict)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == digits.size()) &#123; v.emplace_back(str); <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : dict[digits[idx] - <span class="string">&#x27;0&#x27;</span> - <span class="number">2</span>]) dfs(str + c, digits, idx + <span class="number">1</span>, v, dict);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/17.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>Recursive</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 179 解題紀錄 / September LeetCoding Challenge Day 25</title>
    <url>/LeetCode-179/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/largest-number/">LeetCode - 179. Largest Number</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列，裡面有包含許多整數，求這些整數能組出的最大數字。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>我們先對陣列進行排序，排序的規則為 <code>to_string(l) + to_string(r) &gt; to_string(r) + to_string(l)</code>，由於答案的組成也是將數字轉換為字串後組起來，所以我們在排序時也是以轉換成字串後組起來較大的數值放在前面，如 9, 30 兩數排序，由於 <code>930 &gt; 309</code>，所以 9 排在前面，最後將陣列組成字串組起來即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        sort(nums.begin(), nums.end(), [](<span class="keyword">auto</span>&amp; l, <span class="keyword">auto</span>&amp;r) &#123; <span class="keyword">return</span> to_string(l) + to_string(r) &gt; to_string(r) + to_string(l); &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; val : nums) str += to_string(val);</span><br><span class="line">        <span class="keyword">return</span> !nums.front() ? <span class="string">&quot;0&quot;</span> : str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/179.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 September</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 18 解題紀錄</title>
    <url>/LeetCode-18/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/4sum/">LeetCode - 18. 4Sum</a></p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>基本上和 <a href="../LeetCode-15/">LeetCode - 15 解題紀錄</a> 的想法相同，只是要固定的點從一個變兩個，11 行和 12 行的兩個判斷是為了使執行速度更快，由於陣列是排序過的，所以 11 行的條件成立表後面的 <code>nums[i]</code> 都不可能符合條件，若 12 行的條件成立表 <code>nums[i]</code> 太小，直接往後做即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">        </span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0L</span> + nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0L</span> + nums[i] + nums[n - <span class="number">3</span>] + nums[n - <span class="number">2</span>] + nums[n - <span class="number">1</span>] &lt; target) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; i + <span class="number">2</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != n - <span class="number">1</span> &amp;&amp; nums[j] == nums[j + <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> targetVal = target - (nums[i] + nums[j]);</span><br><span class="line">                <span class="keyword">int</span> l = i + <span class="number">1</span>, r = j - <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[l] + nums[r] == targetVal) &#123;</span><br><span class="line">                        v.push_back(&#123; nums[i], nums[l], nums[r], nums[j] &#125;);</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l + <span class="number">1</span>]) ++l;</span><br><span class="line">                        <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>]) --r;</span><br><span class="line">                        ++l, --r;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nums[l] + nums[r] &lt; targetVal) ++l;</span><br><span class="line">                    <span class="keyword">else</span> --r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 19 解題紀錄</title>
    <url>/LeetCode-19/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">LeetCode - 19. Remove Nth Node From End of List</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 List 和一個整數 <code>n</code>，要求刪除 List 的倒數第 <code>n</code> 個 node。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>若想刪除倒數第 <code>n</code> 個 node，就需要倒數第 <code>n + 1</code> 個 node，可以使用兩個指針，先使兩個指針相隔 <code>n + 1</code> 個 node，之後兩者都往前走，直到前面的指針走到尾巴，此時後面的指針恰好為倒數第 <code>n + 1</code> 個 node，此時作串接及刪除的動作即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>, head)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> first = head, second = &amp;dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) first = first-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(first) first = first-&gt;next, second = second-&gt;next;</span><br><span class="line">        <span class="keyword">auto</span> tmp = second-&gt;next;</span><br><span class="line">        second-&gt;next = second-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/19.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>List</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 2 解題紀錄</title>
    <url>/LeetCode-2/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/add-two-numbers/">LeetCode - 2. Add Two Numbers</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個 Linked List ( 順序是由小位數到大位數 )，求相加後的結果。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>定義一個 <code>carry</code>，使用一個迴圈，<code>carry</code> 每次都將 <code>l1-&gt;val</code> ( 若存在 ) 和 <code>l2-&gt;val</code> ( 若存在 ) 加上，然後新建一個 <code>node</code>，<code>node-val</code> 的值為 <code>carry</code> 除以 10 的餘數，最後再把新建的 <code>node</code> 接上即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>, firstNode = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> res = l1, curr = l1;</span><br><span class="line">        <span class="keyword">while</span>(l1 || l2 || carry != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1)</span><br><span class="line">                carry += l1-&gt;val, l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2)</span><br><span class="line">                carry += l2-&gt;val, l2 = l2-&gt;next;</span><br><span class="line">            <span class="keyword">auto</span> newNode = <span class="keyword">new</span> ListNode(carry % <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span>(firstNode)</span><br><span class="line">                res = curr = newNode, --firstNode;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                curr-&gt;next = newNode, curr = curr-&gt;next;</span><br><span class="line">            carry /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/2.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>List</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 200 解題紀錄</title>
    <url>/LeetCode-200/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/number-of-islands/">LeetCode - 200. Number of Islands</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個二維的陣列當作 2d 地圖，1 代表土地，0 代表海水，求出地圖中島嶼的數量。( 上下左右相鄰的 1 代表同一座島 )</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>將整個地圖訪問一次，若碰到 1 就使用遞迴的概念將相鄰的 1 都設成 0，做完一次代表找到一個島。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> height, <span class="keyword">int</span> width)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= height || j &gt;= width || grid[i][j] != <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        mark(grid, i, j + <span class="number">1</span>, height, width);</span><br><span class="line">        mark(grid, i, j - <span class="number">1</span>, height, width);</span><br><span class="line">        mark(grid, i + <span class="number">1</span>, j, height, width);</span><br><span class="line">        mark(grid, i - <span class="number">1</span>, j, height, width); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> height = grid.size();</span><br><span class="line">        <span class="keyword">if</span>(!height)    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> width = grid[<span class="number">0</span>].size(), numberOfRegions = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; ++j)</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    mark(grid, i, j, height, width),    ++numberOfRegions;</span><br><span class="line">        <span class="keyword">return</span> numberOfRegions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/200.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Recursive</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 201 解題紀錄</title>
    <url>/LeetCode-201/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/bitwise-and-of-numbers-range/">LeetCode - 201. Bitwise AND of Numbers Range</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個數值 <code>m</code>、一個數值 <code>n</code>，<code>0 &lt;= m &lt;= n &lt;= 2147483647</code>。求 <code>m &amp; (m + 1) &amp; ... &amp; n</code> 的值。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>對於 <code>&amp;</code> 運算來說，只要有一個是 0，那結果就會是 0，所以我們只要看 <code>m</code> 跟 <code>n</code> 轉換成二進位後，以左而右從哪個數字開始不一樣，就從那個數字開始到最後面補 0 即可。<br>舉例來說：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5：00 00000 00000 00000 00000 00000 001|01</span><br><span class="line">7：00 00000 00000 00000 00000 00000 001|11</span><br><span class="line">                                        ^ 從這裡開始不一樣</span><br><span class="line">所以答案是：</span><br><span class="line">4：00 00000 00000 00000 00000 00000 001|00</span><br></pre></td></tr></table></figure>

<p>做法也非常簡單，使用 <code>&gt;&gt;</code> 運算符，它會將數字轉換成二進位後，推掉最右邊的那一位，然後在最左邊補 0，而 <code>&gt;&gt;=</code> 的概念和 <code>+=</code> 的概念是一樣的，例如：<code>m &gt;&gt;= 1</code> 等同於 <code>m = m &gt;&gt; 1</code>。所以我們只要一直對 <code>m</code> 和 <code>n</code> 一直做這種運算，直到兩者相等，最後再把右邊的 0 補回去即可。<br><strong>※</strong> <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 的作用一樣，只是它是把最左邊推掉，最右邊補 0。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m != n)</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>, n &gt;&gt;= <span class="number">1</span>, ++count;</span><br><span class="line">        <span class="keyword">return</span> m &lt;&lt; count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/201.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Bitwise</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 211 解題紀錄 / August LeetCoding Challenge Day 5</title>
    <url>/LeetCode-211/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/design-add-and-search-words-data-structure/">LeetCode - 211. Add and Search Word - Data structure design</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>設計一個資料結構，完成題目要求的兩個函式，<code>void addWord(string word)</code>、<code>bool search(string word)</code>。在 <code>word</code> 中， <code>.</code> 代表任意字符。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用字典樹來實現，關於字典樹的做法可參考本篇文章：<a href="../LeetCode%20-%20208/" target="_blank">LeeCode - 208 解題紀錄</a>。</p>
<ul>
<li><p><code>void addWord(string word)：</code><br>  和字典樹的做法一模一樣，不再贅述。</p>
</li>
<li><p><code>bool search(string word)：</code><br>  由於題目多了 <code>.</code> 的特殊情況，所以我們額外定義一個函式，<code>bool exist(string&amp; word, int pos, node* ptr)</code> pos 代表目前要檢查的字元位置，當 <code>word[pos]</code> 不為 <code>.</code> 時，直接往下檢查即可。否則 <code>ptr-&gt;child[]</code> 全部都要往下檢查。</p>
</li>
</ul>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    node* child[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> isWord;</span><br><span class="line">    </span><br><span class="line">    node():isWord(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : child)</span><br><span class="line">            p = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~node()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : child)</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    WordDictionary() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> node();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~WordDictionary() &#123;</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds a word into the data structure. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> ptr = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : word)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!ptr-&gt;child[index])</span><br><span class="line">                ptr-&gt;child[index] = <span class="keyword">new</span> node();</span><br><span class="line">            ptr = ptr-&gt;child[index];</span><br><span class="line">        &#125;</span><br><span class="line">        ptr-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character &#x27;.&#x27; to represent any one letter. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exist(word, <span class="number">0</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">string</span>&amp; word, <span class="keyword">int</span> pos, node* ptr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ptr)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos == word.size())</span><br><span class="line">            <span class="keyword">return</span> ptr-&gt;isWord;</span><br><span class="line">        <span class="keyword">auto</span> c = word[pos];</span><br><span class="line">        <span class="keyword">if</span>(c != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> exist(word, ++pos, ptr-&gt;child[c - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; child : ptr-&gt;child)</span><br><span class="line">            <span class="keyword">if</span>(exist(word, pos + <span class="number">1</span>, child))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    node* root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/211-1.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<p>2020-08-15 重寫</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* child[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> isWord;</span><br><span class="line">    </span><br><span class="line">    TrieNode() : isWord(<span class="literal">false</span>) &#123; <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : child) p = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    ~TrieNode() &#123; <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : child) <span class="keyword">delete</span> p; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    WordDictionary() &#123; root = <span class="keyword">new</span> TrieNode(); &#125;</span><br><span class="line">    </span><br><span class="line">    ~WordDictionary() &#123; <span class="keyword">delete</span> root; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds a word into the data structure. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : word)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;child[c - <span class="string">&#x27;a&#x27;</span>]) p-&gt;child[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            p = p-&gt;child[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character &#x27;.&#x27; to represent any one letter. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123; <span class="keyword">return</span> exist(word, <span class="number">0</span>, root); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">string</span>&amp; word, <span class="keyword">int</span> pos, TrieNode* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos == word.size()) <span class="keyword">return</span> p-&gt;isWord;</span><br><span class="line">        <span class="keyword">auto</span> c = word[pos];</span><br><span class="line">        <span class="keyword">if</span>(c != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span> exist(word, ++pos, p-&gt;child[c - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; child : p-&gt;child) <span class="keyword">if</span>(exist(word, (++pos)--, child)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/211-2.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>Recursive</tag>
        <tag>Tree</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 August</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 208 解題紀錄</title>
    <url>/LeetCode-208/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/implement-trie-prefix-tree/">LeetCode - 208. Implement Trie (Prefix Tree)</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>建立一個 Prefix 字典樹 ( Trie )，並且完成某些功能。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>定義一個 class <code>node</code> 作為節點，裡面包含 <code>node *child[26]</code> 代表 26 個字母，<code>isWord</code> 代表走到這個 <code>node</code> 時是否形成一個單字。</p>
<ul>
<li><p><code>insert(string word)：</code><br>  定義一個 <code>ptr</code>，一開始指向 <code>root</code>，之後遍歷 <code>word</code>，逐一檢查對應的 <code>child</code> 是否存在，若不存在就新建。全部做完後 <code>ptr</code> 這時會指向最後一個字母的 <code>node</code>，再將 <code>ptr-&gt;isWord</code> 設為 <code>True</code> 即可。</p>
</li>
<li><p><code>search(string word)：</code><br>  和 <code>insert()</code> 類似，只是當 <code>child</code> 不存在時就回傳 <code>False</code>。全部做完後，若 <code>ptr-&gt;isWord</code> 為 <code>True</code> 代表這個字串有被 <code>insert()</code> 進來，回傳 <code>True</code>，反之回傳 <code>False</code>。</p>
</li>
<li><p><code>startsWith(string prefix)：</code><br>  和 <code>search()</code> 一模一樣，只是最後不需檢查 <code>ptr-&gt;isWord</code>，直接回傳 <code>True</code> 即可。</p>
</li>
</ul>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    node *child[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> isWord;</span><br><span class="line">    node():isWord(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : child)</span><br><span class="line">            p = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~node()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : child)</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> node();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~Trie()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> ptr = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : word)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!ptr-&gt;child[index])</span><br><span class="line">                ptr-&gt;child[index] = <span class="keyword">new</span> node();</span><br><span class="line">            ptr = ptr-&gt;child[index];</span><br><span class="line">        &#125;</span><br><span class="line">        ptr-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> ptr = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : word)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!ptr-&gt;child[index])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            ptr = ptr-&gt;child[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> ptr = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : prefix)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!ptr-&gt;child[index])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            ptr = ptr-&gt;child[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    node* root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/208-1.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<p>2020-08-24 重寫</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode() : isWord(<span class="literal">false</span>) &#123; <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ptr : child) ptr = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    ~TrieNode() &#123; <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ptr : child) <span class="keyword">delete</span> ptr; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == str.size()) &#123; isWord = <span class="literal">true</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span>(!child[str[idx] - <span class="string">&#x27;a&#x27;</span>]) child[str[idx] - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        child[str[idx] - <span class="string">&#x27;a&#x27;</span>]-&gt;build(str, ++idx);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == str.size()) <span class="keyword">return</span> isWord;</span><br><span class="line">        <span class="keyword">return</span> child[str[idx] - <span class="string">&#x27;a&#x27;</span>] ? child[str[idx] - <span class="string">&#x27;a&#x27;</span>]-&gt;search(str, ++idx) : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">prefix</span><span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx == str.size()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> child[str[idx] - <span class="string">&#x27;a&#x27;</span>] ? child[str[idx] - <span class="string">&#x27;a&#x27;</span>]-&gt;prefix(str, ++idx) : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* child[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> isWord;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie() &#123; root = <span class="keyword">new</span> TrieNode(); &#125;</span><br><span class="line">    </span><br><span class="line">    ~Trie() &#123; <span class="keyword">delete</span> root; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123; root-&gt;build(word, <span class="number">0</span>); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123; <span class="keyword">return</span> root-&gt;search(word, <span class="number">0</span>); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123; <span class="keyword">return</span> root-&gt;prefix(prefix, <span class="number">0</span>); &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/208-2.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>Recursive</tag>
        <tag>Tree</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 220 解題紀錄 / September LeetCoding Challenge Day 2</title>
    <url>/LeetCode-220/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/contains-duplicate-iii/">LeetCode - 220. Contains Duplicate III</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列，求對於陣列中的某個元素的左右各 <code>k</code> 個元素中是否存在兩者的差小於等於 <code>t</code> 的元素。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>為了計算方便，我們先確定 <code>j</code> 的位置，之後再往前找 <code>i</code>，最簡單的方法為兩個迴圈，但是這樣會超時，所以必須使用二分搜尋，這裡我們使用 <code>lower_bound()</code> 這個函式達成二分搜尋的效果，使用 Multiset 紀錄前面 <code>k</code> 個元素，之後使用此函式找到第一個大於等於 <code>nums[j] - t</code> 的值，若有找到並且這個值會小於等於 <code>nums[j] + t</code>，表示兩者的差會小於等於 <code>t</code>，回傳 True。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">long</span>&gt; ms;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; k) ms.erase(ms.lower_bound(nums[j - k - <span class="number">1</span>]));</span><br><span class="line">            <span class="keyword">auto</span> iter = ms.lower_bound(<span class="keyword">long</span>(nums[j]) - <span class="keyword">long</span>(t));</span><br><span class="line">            <span class="keyword">if</span>(iter != ms.end() &amp;&amp; *iter &lt;= <span class="keyword">long</span>(nums[j]) + <span class="keyword">long</span>(t)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            ms.insert(nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/220.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Multiset</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 September</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 221 解題紀錄</title>
    <url>/LeetCode-221/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/maximal-square/">LeetCode - 221. Maximal Square</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個二維陣列，裡面包含 0 和 1，求出其中值為 1 的元素能組出的最大正方形。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>對於陣列中的每個元素來說，若該值為 1，能組出的最大正方形的長度為，<code>左邊那個元素能組出的最大正方形的長度</code>、<code>上面那個元素能組出的最大正方形的長度</code> 和 <code>左上角那個元素能組出的最大正方形的長度</code>，三者的最小值 + 1，依照此想法使用動態規劃即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> height = matrix.size();</span><br><span class="line">        <span class="keyword">if</span>(!height)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> width = matrix[<span class="number">0</span>].size(), Max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(height + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(width + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= height; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= width; ++j)</span><br><span class="line">                <span class="keyword">if</span>(matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    dp[i][j] = min(dp[i - <span class="number">1</span>][j], min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>])) + <span class="number">1</span>,    Max = max(Max, dp[i][j]);</span><br><span class="line">        <span class="keyword">return</span> Max * Max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/221.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 216 解題紀錄 / September LeetCoding Challenge Day 12</title>
    <url>/LeetCode-216/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/combination-sum-iii/">LeetCode - 216. Combination Sum III</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個整數 <code>k</code> 及 <code>n</code>，求在 1 ~ 9 的數字中，找出 <code>k</code> 個相加會等於 <code>n</code> 的數，此為一組，一組內的數字不可重複，每組中的數不可相同。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 dfs 尋找解，為了避免重複，我們由小找到大，每次遞迴中先判斷 <code>k</code> 及 <code>n</code>，若 <code>k</code> 為 0 代表數字已經夠了，此時若是 <code>n</code> 為 0 則代表這是一組解。接著使用迴圈，i 從 <code>bound</code> 開始到 9 繼續做 dfs。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line">        dfs(k, n, <span class="number">1</span>, cur, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> bound, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cur, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!k) &#123; <span class="keyword">if</span>(!n) res.emplace_back(cur); <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = bound; i &lt;= <span class="number">9</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cur.emplace_back(i);</span><br><span class="line">            dfs(k - <span class="number">1</span>, n - i, i + <span class="number">1</span>, cur, res);</span><br><span class="line">            cur.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/216.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Recursive</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 September</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 230 解題紀錄</title>
    <url>/LeetCode-230/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">LeetCode - 230. Kth Smallest Element in a BST</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 Binary Search Tree 及一個整數 <code>k</code>，求 Tree 中第 <code>k</code> 小的值。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用遞迴將值推入 <code>v</code>，由於是 <code>BST</code>，所以先將左子樹推入，再推入自己的值，最後推入右子樹，這樣 <code>v</code> 裡面就是由小到大排序了，最後回傳 <code>v[k - 1]</code> 即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putsIn</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        putsIn(root-&gt;left);</span><br><span class="line">        v.push_back(root-&gt;val);</span><br><span class="line">        putsIn(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        putsIn(root);</span><br><span class="line">        <span class="keyword">return</span> v[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/230.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Recursive</tag>
        <tag>Vector</tag>
        <tag>Tree</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 229 解題紀錄 / September LeetCoding Challenge Day 22</title>
    <url>/LeetCode-229/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/majority-element-ii/">LeetCode - 229. Majority Element II</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列，求陣列中出現次數大於 <code>陣列大小 / 3</code> 的元素。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先使用 Unordered_map 紀錄每個元素出現的次數，接著遍歷找出符合條件的元素即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bound = nums.size() / <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums) ++cnt[num];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [num, times] : cnt) <span class="keyword">if</span>(times &gt; bound) ret.emplace_back(num);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/229.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Unordered_map</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 September</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 238 解題紀錄</title>
    <url>/LeetCode-238/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/product-of-array-except-self/">LeetCode - 238. Product of Array Except Self</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列 nums，要求回傳一個陣列 res，res[i] 的值為除了 nums[i] 以外，其他所有位於 nums 的元素的乘積。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><ul>
<li><p><strong>解法一：</strong>定義一個 <code>index</code> 起始值為 - 1，訪問 nums 內所有元素，當碰到 0 時，把 <code>index</code> 儲存，若再碰到 0，則代表整個 res 都是 0，可以直接回傳。若只有 1 個 0，則 <code>res[index] = all</code>，其餘都為 0，否則 <code>res[i] = all / nums[i]</code>。</p>
</li>
<li><p><strong>解法二：</strong>對於 res 來說，<code>res[i] = (nums[0] * nums[1] * ... * nums[i - 1]) * (num[nums.size() - 1] * num[nums.size() - 2] * ... * nums[i + 1])</code>，所以使用一個陣列計算右邊的部分，左邊的部分直接在迴圈做即可得到 <code>res</code>。</p>
</li>
</ul>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><p>解法一：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), all = <span class="number">1</span>, index = <span class="number">-1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)</span><br><span class="line">                all *= nums[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(index == <span class="number">-1</span>)</span><br><span class="line">               index = i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                res[i] = all / nums[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res[index] = all;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/238-1.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<p>解法二：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightProduct</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            rightProduct[i] = rightProduct[i + <span class="number">1</span>] * nums[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, left = <span class="number">1</span>; i &lt; n; left *= nums[i], ++i)</span><br><span class="line">            rightProduct[i] *= left;</span><br><span class="line">        <span class="keyword">return</span> rightProduct;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/238-2.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 24 解題紀錄</title>
    <url>/LeetCode-24/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/swap-nodes-in-pairs/">LeetCode - 24. Swap Nodes in Pairs</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 Linked List，將相鄰的兩個 node 互換 ( 1、2 互換，3、4 互換)。最後回傳互換後的 head。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 Recursive 的概念，先將第二個 node 保存，之後呼叫並傳入第三個 node，最後把第一個 node 接到第二個 node 後面即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> tmp = head-&gt;next;</span><br><span class="line">        head-&gt;next = swapPairs(head-&gt;next-&gt;next);</span><br><span class="line">        tmp-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/24.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Recursive</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 274 解題紀錄 / August LeetCoding Challenge Day 11</title>
    <url>/LeetCode-274/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/h-index/">LeetCode - 274. H-Index</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列，代表每篇論文的引用數，求 H - index。( 若 h = 5，代表有 5 篇論文的引用數大於等於 5，其餘論文的引用數皆小於 5 )</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先將陣列降冪排序，接著遍歷陣列，若 <code>citations[i] &gt;= i + 1</code>，代表有 <code>i + 1</code> 篇論文的引用數大於等於 <code>i + 1</code>，持續做直到找到最大的 <code>h</code> 即可。( 當找到最大的 <code>h</code> 代表總共有 <code>h</code> 篇論文的引用數大於等於 <code>h</code>，而後面論文的引用數都小於 <code>h</code> )</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">[<span class="number">3</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>] <span class="comment">// sorted</span></span><br><span class="line">i = <span class="number">0</span>, citations[<span class="number">0</span>] = <span class="number">6</span> &gt;= <span class="number">1</span>, 代表目前有 <span class="number">1</span> 篇論文的引用數大於等於 <span class="number">1</span></span><br><span class="line">i = <span class="number">1</span>, citations[<span class="number">1</span>] = <span class="number">5</span> &gt;= <span class="number">2</span>, 代表目前有 <span class="number">2</span> 篇論文的引用數大於等於 <span class="number">2</span></span><br><span class="line">i = <span class="number">2</span>, citations[<span class="number">2</span>] = <span class="number">3</span> &gt;= <span class="number">3</span>, 代表目前有 <span class="number">3</span> 篇論文的引用數大於等於 <span class="number">3</span></span><br><span class="line">i = <span class="number">3</span>, citations[<span class="number">3</span>] = <span class="number">1</span> &lt;  <span class="number">4</span>, 其實做到這邊就可以停了</span><br><span class="line">H - index = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>, n = citations.size(), i = <span class="number">-1</span>;</span><br><span class="line">        sort(citations.begin(), citations.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">while</span>(++i &lt; n &amp;&amp; citations[i] &gt;= i + <span class="number">1</span>) h = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; n; ++i) h = citations[i] &gt;= i + 1 ? i + 1 : h;</span></span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/274.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 August</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 3 解題紀錄</title>
    <url>/LeetCode-3/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">LeetCode - 3. Longest Substring Without Repeating Characters</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 String，找出這個 String 裡面最長的不重複子陣列。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>定義一個陣列紀錄每個英文字母最後出現的位置，使用一個迴圈，<code>j</code> 為子陣列的右端點，<code>i</code> 為子陣列的左端點，每一次 <code>i</code> 都更新為 <code>max(i, v[s[j] + 1])</code> 這樣就可以確保子陣列中沒有重複的元素，此時子陣列的長度為 <code>j - i + 1</code>，最後更新 <code>maxL</code> 即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size(), maxL = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">128</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            i = max(i, v[s[j]] + <span class="number">1</span>);</span><br><span class="line">            maxL = max(maxL, j - i + <span class="number">1</span>);</span><br><span class="line">            v[s[j]] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/3.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 328 解題紀錄</title>
    <url>/LeetCode-328/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/odd-even-linked-list/">LeetCode - 328. Odd Even Linked List</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 Linked List，題目要求將奇數的 node 往前放，偶數的 node 往後放。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>將原本的第一個節點當作奇數 node 的頭，第二個節點當作偶數 node 的頭，將奇數與偶數各自串起，最後將偶數 node 的頭接在奇數最後一個 node 後面即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) </span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> odd = head, even = head-&gt;next, evenhead = even;</span><br><span class="line">        <span class="keyword">while</span>(even &amp;&amp; even-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            odd-&gt;next = odd-&gt;next-&gt;next;</span><br><span class="line">            even-&gt;next = even-&gt;next-&gt;next;</span><br><span class="line">            odd = odd-&gt;next, even = even-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd-&gt;next = evenhead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/328.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>List</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 33 解題紀錄</title>
    <url>/LeetCode-33/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">LeetCode - 33. Search in Rotated Sorted Array</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個排序過的陣列，但是反轉一部份，給一個 <code>target</code> 求它在陣列中的 <code>index</code>，若不在陣列中則回傳 - 1。<br><strong>※</strong> 題目希望時間複雜度為 O(log n)</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>基本為二分搜尋法，但是因為陣列反轉過，所以會有一些其他的規則，舉例子並自己設 <code>target</code> 就能找出其中的規則。<br>以下是我觀察到的規則：</p>
<ul>
<li>如果 <strong><code>nums[mid] &gt; target</code></strong><ul>
<li>如果 <code>nums[0] &gt; nums[mid]</code> 則 <code>target</code> 會在左邊這一段。</li>
<li>如果 <code>nums[0] &lt; nums[mid]</code><ul>
<li>如果 <code>nums[0] &gt; target</code> 則 <code>target</code> 會在右邊這一段。</li>
<li>如果 <code>nums[0] &lt; target</code> 則 <code>target</code> 會在左邊這一段。</li>
</ul>
</li>
</ul>
</li>
<li>如果 <strong><code>nums[mid] &lt; target</code></strong><ul>
<li>如果 <code>nums[0] &gt; nums[mid]</code><ul>
<li>如果 <code>nums[0] &gt; target</code> 則 <code>target</code> 會在右邊這一段。</li>
<li>如果 <code>nums[0] &lt; target</code> 則 <code>target</code> 會在左邊這一段。</li>
</ul>
</li>
<li>如果 <code>nums[0] &lt; nums[mid]</code> 則 <code>target</code> 會在右邊這一段。</li>
</ul>
</li>
</ul>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left == right)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">                <span class="keyword">if</span>(nums[<span class="number">0</span>] &gt; nums[mid])</span><br><span class="line">                    right = mid;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[<span class="number">0</span>] &gt; target)</span><br><span class="line">                    </span><br><span class="line">                        left = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        right = mid;   </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                <span class="keyword">if</span>(nums[<span class="number">0</span>] &gt; nums[mid])</span><br><span class="line">                    <span class="keyword">if</span>(nums[<span class="number">0</span>] &gt; target)</span><br><span class="line">                        left = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        right = mid;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/33.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 338 解題紀錄</title>
    <url>/LeetCode-338/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/counting-bits/">LeetCode - 338. Counting Bits</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 num，回傳一個代表 0 ~ num 的二進制中 1 的數量的陣列。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>觀察答案的陣列可以知道，對於 i 來說，如果 i 是奇數則 <code>res[i] = res[i / 2] + 1</code>，如果 i 是偶數則 <code>res[i] = res[i / 2]</code>。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(num + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i)</span><br><span class="line">            res[i] = res[i / <span class="number">2</span>] + i % <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/338.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 399 解題紀錄 / September LeetCoding Challenge Day 27</title>
    <url>/LeetCode-399/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/evaluate-division/">LeetCode - 399. Evaluate Division</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>待編輯…</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>待編輯…</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">calcEquation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; equations, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; queries)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = equations.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; ret;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt;&gt; _m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i&#123;&#125;; i &lt; n; ++i)</span><br><span class="line">            _m[equations[i][<span class="number">0</span>]][equations[i][<span class="number">1</span>]] = values[i], _m[equations[i][<span class="number">1</span>]][equations[i][<span class="number">0</span>]] = <span class="number">1</span> / values[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; que : queries)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>&amp; x = que[<span class="number">0</span>], y = que[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(!_m.count(x) || !_m.count(y)) &#123; ret.emplace_back(<span class="number">-1.0</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line">            ret.emplace_back(divide(x, y, _m, visited));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">divide</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; A, <span class="keyword">const</span> <span class="built_in">string</span>&amp; B, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt;&gt;&amp; _m, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&amp; visited)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A == B) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        visited.insert(A);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [key, val] : _m[A])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.count(key)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">double</span> d = divide(key, B, _m, visited);</span><br><span class="line">            <span class="keyword">if</span>(d &gt; <span class="number">0</span>) <span class="keyword">return</span> d * _m[A][key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/399.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Unordered_map</tag>
        <tag>Recursive</tag>
        <tag>Graph</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 September</tag>
        <tag>Puzzled</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 402 解題紀錄</title>
    <url>/LeetCode-402/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/remove-k-digits/">LeetCode - 402. Remove K Digits</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個字串及一個整數 <code>k</code>，字串代表一個整數，求刪除 <code>k</code> 個數字後，結果是最小的數字。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><ul>
<li><p><strong>想法：</strong> 由於數字比大小是從高位往低位比，所以我們的目的是讓高位數盡可能的小。</p>
</li>
<li><p><strong>解法一：</strong> 定義一個字串 <code>res</code>，遍歷 num，若是 res 的最後一位數比現在遍歷到的元素大，就刪除最後一位數，直到已經刪除了 <code>k</code> 個數字，或是 <code>res</code> 已經刪除光了。最後再 <code>res.resize(digits)</code>，因為我們只需要 <code>digits</code> 位數，而後面的數字一定會比前面的大，所以直接刪除掉後面的數字。最後如果 <code>res</code> 前面是 0 的話就把 0 拿掉即可。</p>
</li>
<li><p><strong>解法二：</strong> 和解法一類似，只是在放入的時候就判斷是否有 leading zero 的情況。</p>
</li>
<li><p><strong>解法三：</strong> 和解法二相同，只是不再定義新的字串，而是將直接將結果存在 <code>num</code> 裡面。</p>
</li>
</ul>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><p>解法一：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.size();</span><br><span class="line">        <span class="keyword">if</span>(n == k)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> digits = n - k;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : num)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(k &amp;&amp; !res.empty() &amp;&amp; res.back() &gt; i)</span><br><span class="line">                res.pop_back(), --k;</span><br><span class="line">            res.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 避免結果太長</span></span><br><span class="line">        res.resize(digits);</span><br><span class="line">        <span class="keyword">while</span>(!res.empty() &amp;&amp; res.front() == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            res.erase(res.begin());</span><br><span class="line">        <span class="keyword">return</span> res.empty() ? <span class="string">&quot;0&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/402-1.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<p>解法二：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.size();</span><br><span class="line">        <span class="keyword">if</span>(n == k)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : num)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(k &amp;&amp; !res.empty() &amp;&amp; res.back() &gt; i)</span><br><span class="line">                res.pop_back(), --k;</span><br><span class="line">            <span class="keyword">if</span>(!res.empty() || i != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                res.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(k--)</span><br><span class="line">            res.pop_back();</span><br><span class="line">        <span class="keyword">return</span> res.empty() ? <span class="string">&quot;0&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/402-2.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<p>解法三：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.size();</span><br><span class="line">        <span class="keyword">if</span>(n == k)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : num)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(k &amp;&amp; size &amp;&amp; num[size - <span class="number">1</span>] &gt; i)</span><br><span class="line">                --size, --k;</span><br><span class="line">            <span class="keyword">if</span>(size || i != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                num[size++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        num.resize(size - k);</span><br><span class="line">        <span class="keyword">return</span> num.empty() ? <span class="string">&quot;0&quot;</span> : num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/402-3.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 421 解題紀錄 / September LeetCoding Challenge Day 16</title>
    <url>/LeetCode-421/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/">LeetCode - 421. Maximum XOR of Two Numbers in an Array</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列，找出陣列中最大的任意兩者互斥或的值。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>由於互斥或有 <code>a ^ b = c -&gt; a ^ c = b</code> 的特性，所以可以先找出一個最大值，接著遍歷陣列查看 <code>val ^ 最大值</code> 是否存在，若存在表示這個最大值是可以被陣列中兩數互斥或出來的。由於要找最大值，所以要讓二進制中最高位盡可能為 1，因為只需要判斷最高位，所以我們需要一個 mask，接著將陣列中過遮罩的值存入 unordered_set，最後遍歷 set 查看 <code>val ^ (ret | i)</code> 是否存在即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret&#123;&#125;, mask&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; i; i &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mask |= i;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; u_set;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums) u_set.insert(mask &amp; num);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> val : u_set) <span class="keyword">if</span>(u_set.count(val ^ (ret | i))) &#123; ret |= i; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/421.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Unordered_set</tag>
        <tag>Bitwise</tag>
        <tag>XOR</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 September</tag>
        <tag>Puzzled</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 435 解題紀錄 / August LeetCoding Challenge Day 15</title>
    <url>/LeetCode-435/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/non-overlapping-intervals/">LeetCode - 435. Non-overlapping Intervals</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個二維陣列代表區間，求需要刪除多少個區間使得區間中沒有交集。( 需要刪除最少的區間 )</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>為了方便計算，我們先將區間依照右端點以小到大排序。接著選定一個區間，然後計算右邊的區間和目前區間交集的個數，這些都是需要刪除的區間，接著將目前區間換成目前找到不交集的區間，重複做此步驟即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; l, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; r)</span> </span>&#123; <span class="keyword">return</span> l[<span class="number">1</span>] &lt; r[<span class="number">1</span>]; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, n = intervals.size(), l = <span class="number">0</span>, r;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        <span class="keyword">while</span>(l &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            r = l + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(r &lt; n &amp;&amp; intervals[l][<span class="number">1</span>] &gt; intervals[r][<span class="number">0</span>]) ++r;</span><br><span class="line">            count += r - l - <span class="number">1</span>;</span><br><span class="line">            l = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/435.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 August</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 436 解題紀錄 / August LeetCoding Challenge Day 27</title>
    <url>/LeetCode-436/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/find-right-interval/">LeetCode - 436. Find Right Interval</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一堆區間，求每個區間的最近右邊區間的索引號 ( 右邊區間的 start &gt;= 左邊區間的 end)，若不存在則為 -1。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 map 紀錄每個區間的起始點及索引號，接著遍歷所有區間，使用 <code>lower_bound()</code> 實現二分查找。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRightInterval</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">auto</span> iter = m.begin();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.size(); ++i) m[intervals[i][<span class="number">0</span>]] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; interval : intervals)</span><br><span class="line">            v.emplace_back((iter = m.lower_bound(interval[<span class="number">1</span>])) != m.end() ? iter-&gt;second : <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/436.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Map</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 August</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 437 解題紀錄 / August LeetCoding Challenge Day 8</title>
    <url>/LeetCode-437/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/path-sum-iii/">LeetCode - 437. Path Sum III</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 Tree、一個整數 <code>sum</code>，求樹中有幾段子樹的路徑和為 <code>sum</code>。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>遍歷整棵樹，<code>currSum</code> 紀錄從 <code>root</code> 到當前節點的路徑和，由於 <code>currSum - (currSum - target) = target</code>，所以只要看前面有幾種路徑和的值為 <code>currSum - target</code> 就可以得到以當前節點為終點的子樹路徑和為 <code>sum</code> 的個數，將次數加上 <code>count</code> 即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        ++_m[<span class="number">0</span>];</span><br><span class="line">        traverse(root, <span class="number">0</span>, sum, count);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; _m;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, <span class="keyword">int</span> currSum, <span class="keyword">int</span> target, <span class="keyword">int</span>&amp; count)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        currSum += root-&gt;val;</span><br><span class="line">        count += _m[currSum - target]; <span class="comment">// currSum - (currSum - target) = target</span></span><br><span class="line">        ++_m[currSum];</span><br><span class="line">        traverse(root-&gt;left, currSum, target, count);</span><br><span class="line">        traverse(root-&gt;right, currSum, target, count);</span><br><span class="line">        --_m[currSum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/437.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Recursive</tag>
        <tag>Tree</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 August</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 438 解題紀錄</title>
    <url>/LeetCode-438/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/">LeetCode - 438. Find All Anagrams in a String</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個 String <code>s</code>、<code>p</code>，求 <code>s</code> 中某段文字結構組成和 <code>p</code> 相同的 <code>index</code>。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>建兩個表，<code>vp</code> 放 <code>p</code> 中的英文字母個數，<code>vs</code> 放 <code>s</code> 某段的英文字母個數。使用一個迴圈遍歷 <code>s</code>，將遍歷到的元素加入 <code>vs</code>，當裡面存放的字母個數超過 <code>p</code> 的長度時，需要把最前面的刪除。最後判斷 <code>vs</code> 是否等於 <code>vp</code> 即可。 </p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = s.size(), lp = p.size();</span><br><span class="line">        vector&lt;int&gt; vs(26), vp(26), res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : p)</span><br><span class="line">            ++vp[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ls; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= lp)</span><br><span class="line">                --vs[s[i - lp] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            ++vs[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span>(vs == vp)</span><br><span class="line">                res.push_back(i - lp + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/438.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 442 解題紀錄 / August LeetCoding Challenge Day 6</title>
    <url>/LeetCode-442/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/find-all-duplicates-in-an-array/">LeetCode - 442. Find All Duplicates in an Array</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列 <code>nums</code>，<code>1 ≤ nums[i] ≤ n</code>。求此陣列中出現兩次的數字。<br><strong>※</strong> 題目希望時間複雜度為 O(n)，且不使用額外的空間。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>由於有 <code>1 ≤ nums[i] ≤ n</code> 這個條件，所以我們可以使用陣列元素的正負來判斷此數字是否出現過。具體作法為使用一個迴圈遍歷陣列，我們先判斷 <code>nums[abs(nums[i]) - 1]</code> 是否為負數，若為負數代表前面出現過，否則將 <code>nums[abs(nums[i]) - 1]</code> 設為負數。<br><strong>※</strong> 使用 <code>abs()</code> 是為了避免這個元素已經被設為負數，減一是因為 <code>nums[i]</code> 的範圍為 [1, n]。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="built_in">abs</span>(num) - <span class="number">1</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                v.push_back(<span class="built_in">abs</span>(num));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nums[<span class="built_in">abs</span>(num) - <span class="number">1</span>] *= <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/442.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 August</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 450 解題紀錄 / August LeetCoding Challenge Day 31</title>
    <url>/LeetCode-450/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/delete-node-in-a-bst/">LeetCode - 450. Delete Node in a BST</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 Binary Search Tree，和一個整數 <code>key</code>，如果找到 <code>key</code> 的節點就將其刪除。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>由於 BST 有左子樹的值皆比根的值小，右子樹的值皆比根的值大的特性，所以我們先判斷當前 <code>node</code> 的值及 <code>key</code> 的大小，若 <code>key</code> 較大則往左邊走，否則往右邊走。若兩者的值相等代表要刪除當前的 node，若是當前的 <code>node</code> 只有一邊的子樹，那就直接接上即可，否則要從右子樹中找出最小的值頂替目前的 <code>node</code> 才能符合 BST 的特性。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt; key) root-&gt;right = deleteNode(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &gt; key) root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// root-&gt;val == key</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;left || !root-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> newRoot = root-&gt;right ? root-&gt;right : root-&gt;left;</span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> newRoot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> min = root-&gt;right;</span><br><span class="line">                <span class="keyword">while</span>(min-&gt;left) min = min-&gt;left;</span><br><span class="line">                root-&gt;val = min-&gt;val;</span><br><span class="line">                root-&gt;right = deleteNode(root-&gt;right, min-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/450.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Recursive</tag>
        <tag>Tree</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 August</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 451 解題紀錄</title>
    <url>/LeetCode-451/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/sort-characters-by-frequency/">LeetCode - 451. Sort Characters By Frequency</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 String，將 String 裡面的字元按照個數排序，例如： <code>tree</code> -&gt; <code>eert</code> or <code>eetr</code>。需要注意的是大小寫為不同的字元。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先使用 hash_map 得到每個字出現的次數，再用 Vector 排序，最後串接到 String 即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; l,<span class="keyword">const</span> <span class="built_in">pair</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l.second &gt; r.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">frequencySort</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.size();</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        res.reserve(length);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)</span><br><span class="line">            ++hash[c];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&gt; v(hash.begin(), hash.end());</span><br><span class="line">        sort(v.begin(), v.end(), cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : v)</span><br><span class="line">            res.append(i.second, i.first);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/451.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>Unordered_map</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 470 解題紀錄 / August LeetCoding Challenge Day 28</title>
    <url>/LeetCode-470/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/implement-rand10-using-rand7/">LeetCode - 470. Implement Rand10() Using Rand7()</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 <code>rand7()</code> 會隨機回傳 1 ~ 7 整數的函式 ( 機率相等 )，要求完成 <code>rand10()</code>。題目要求不要使用函式庫的 <code>rand()</code> 函數。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>數學問題，取兩次 <code>rand7()</code> 會得到一個 7 * 7 的矩形，前面 40 個可以透過 <code>(7 * (rand7() - 1) + (rand7() - 1)) % 10 + 1</code> 的計算取得 1 ~ 10 的數字且機率相同，若是取得後面 9 個就要重新取。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rand10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">41</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx &gt;= <span class="number">40</span>) idx = <span class="number">7</span> * (rand7() - <span class="number">1</span>) + (rand7() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> idx % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/470.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 August</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 49 解題紀錄</title>
    <url>/LeetCode-49/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/group-anagrams/">LeetCode - 49. Group Anagrams</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個字串的陣列，將所有組成字串的字母相同的放在一起。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><ul>
<li><p><strong>想法：</strong>可使用 <code>sort()</code> 來排序 String，若是兩個組成字串的字母一樣，那排序過後會長的一樣。</p>
</li>
<li><p><strong>解法一：</strong>使用 <code>vector&lt;pair&lt;string, int&gt;&gt;</code> 存放資料 ( 後面稱作 temp )，first 放排序過的字串，second 放該字串在 strs 裡面的 <code>index</code>。之後對 temp 進行排序 ( 預設會排序 first )。最後將排序過後相同的字串存入 res 即可。</p>
</li>
<li><p><strong>解法二：</strong>使用 <code>unordered_map&lt;string, vector&lt;string&gt;&gt;</code> 存放資料，key 存放排序過後的字串，value 存放未排序的字串，最後將 value 存入 res 即可。</p>
</li>
</ul>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><p>解法一：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; temp;</span><br><span class="line">        <span class="built_in">string</span> stemp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            stemp = strs[i];</span><br><span class="line">            sort(stemp.begin(), stemp.end());</span><br><span class="line">            temp.push_back(<span class="built_in">make_pair</span>(stemp, i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(temp.begin(), temp.end());</span><br><span class="line"></span><br><span class="line">        stemp = temp[<span class="number">0</span>].first;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vtemp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (stemp == temp[i].first)</span><br><span class="line">                vtemp.push_back(strs[temp[i].second]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(vtemp);</span><br><span class="line">                vtemp.clear();</span><br><span class="line">                stemp = temp[i].first;</span><br><span class="line">                vtemp.push_back(strs[temp[i].second]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(vtemp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/49-1.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<p>解法二：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; v;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; _m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s : strs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp = s;</span><br><span class="line">            sort(tmp.begin(), tmp.end());</span><br><span class="line">            _m[tmp].push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> m : _m) v.push_back(m.second);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/49-2.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 495 解題紀錄 / September LeetCoding Challenge Day 26</title>
    <url>/LeetCode-495/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/teemo-attacking/">LeetCode - 495. Teemo Attacking</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列及一個整數，整數代表攻擊後能使敵人中毒的時間，陣列代表攻擊敵人的時間點，若攻擊時敵人處於中毒狀態則中毒狀態更新。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>由於中毒時被攻擊會使中毒狀態更新，所以每次中毒的時間可視為兩次攻擊的間隔及 <code>duration</code> 兩者取較小值，最後判斷攻擊次數是否為 0，若為 0 則回傳 0，否則回傳 <code>ret + duration</code>，因為最後一次攻擊時中毒時間必定為 <code>duration</code>，所以結果需要加上 <code>duration</code>。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPoisonedDuration</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; timeSeries, <span class="keyword">int</span> duration)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret&#123;&#125;, n = timeSeries.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i&#123;&#125;; i &lt; n - <span class="number">1</span>; ++i) ret += min(timeSeries[i + <span class="number">1</span>] - timeSeries[i], duration);</span><br><span class="line">        <span class="keyword">return</span> n ? ret + duration : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/495.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 September</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 497 解題紀錄 / August LeetCoding Challenge Day 22</title>
    <url>/LeetCode-497/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/random-point-in-non-overlapping-rectangles/">LeetCode - 497. Random Point in Non-overlapping Rectangles</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列代表矩形的左下角座標及右上角座標，所有矩形都不會重疊。要求完成一個函式能隨機取一個在矩形內的點。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><ul>
<li><code>Solution(vector&lt;vector&lt;int&gt;&gt;&amp; rects)</code>： 先使用一個陣列紀錄到目前的矩形總共有多少的點，方便做隨機取樣。</li>
<li><code>vector&lt;int&gt; pick()</code>： 隨機取一個小於點的數量的數，接著找出它位於第幾個矩形，接著在該矩形內隨機取一點即可。</li>
</ul>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rects) : _rects(rects) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, count = <span class="number">0</span>; i &lt; rects.size(); ++i)</span><br><span class="line">            count += (rects[i][<span class="number">2</span>] - rects[i][<span class="number">0</span>] + <span class="number">1</span>) * (rects[i][<span class="number">3</span>] - rects[i][<span class="number">1</span>] + <span class="number">1</span>), dots.emplace_back(count);</span><br><span class="line">        srand(time(<span class="literal">nullptr</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = lower_bound(dots.begin(), dots.end(), rand() % dots.back() + <span class="number">1</span>) - dots.begin();</span><br><span class="line">        <span class="keyword">int</span> length = _rects[pos][<span class="number">2</span>] - _rects[pos][<span class="number">0</span>] + <span class="number">1</span>, width = _rects[pos][<span class="number">3</span>] - _rects[pos][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;_rects[pos][<span class="number">0</span>] + rand() % length, _rects[pos][<span class="number">1</span>] + rand() % width&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; _rects;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dots;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/497.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 August</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 5 解題紀錄</title>
    <url>/LeetCode-5/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/longest-palindromic-substring/">LeetCode - 5. Longest Palindromic Substring</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個字串，求此字串最長的回文子字串。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>回文的形式有兩種，一種是奇數個數，一種是偶數個數，所以我們使用一個迴圈遍歷 <code>s</code>，嘗試將字串中的每個端點當作回文的中間並找出回文的長度，找出最長的長度並記錄起始點即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        _s = s, n = s.size();</span><br><span class="line">        <span class="keyword">int</span> len = INT_MIN, start, curLen;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            curLen = max(getLength(i, i), getLength(i, i + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(curLen &gt; len) len = curLen, start = i - (curLen - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, len);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> _s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &gt;= <span class="number">0</span> &amp;&amp; r &lt; n &amp;&amp; _s[l] == _s[r]) --l, ++r;</span><br><span class="line">        <span class="keyword">return</span> r - l - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/5.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 50 解題紀錄</title>
    <url>/LeetCode-50/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/powx-n/">LeetCode - 50. Pow(x, n)</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>設計一個 <code>pow()</code> 函數。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用遞迴的觀念，先假設函式能取得 <code>n / 2</code> 次方的正確答案，此時若 <code>n</code> 為 2 的倍數，代表答案為 <code>n / 2</code> 次方的答案相乘，否則若是 <code>n</code> 大於 0，代表還要再乘一次 <code>x</code>，若 <code>n</code> 為負數則要除以一次 <code>x</code>。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> tmp = myPow(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(!(n % <span class="number">2</span>)) <span class="keyword">return</span> tmp * tmp;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> ? x * tmp * tmp : tmp * tmp / x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/50.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Recursive</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 525 解題紀錄</title>
    <url>/LeetCode-525/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/contiguous-array/">LeetCode - 525. Contiguous Array</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列，找出一段裡面 0 和 1 個數相等的最長子陣列。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>定義一個 <code>target</code>，當每次訪問 nums 的元素時，若元素為 1 則 + 1，若為 0 則 - 1，並查詢這個 <code>target</code> 是否出現過，若有則代表這一段子陣列裡面的 0 和 1 的個數相等。使用 <code>unordered_map&lt;int, int&gt;</code> 存放資料，key 為 <code>target</code>，value 為該 <code>target</code> 的 <code>index</code>。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">0</span>, maxLength = <span class="number">0</span>, n = nums.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">map</span>.insert(&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            target += (nums[i] == <span class="number">0</span>) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>.count(target))</span><br><span class="line">                maxLength = max(maxLength, i - <span class="built_in">map</span>[target]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">map</span>[target] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/525.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Unordered_map</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 540 解題紀錄</title>
    <url>/LeetCode-540/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/single-element-in-a-sorted-array/">LeetCode - 540. Single Element in a Sorted Array</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個排序好的陣列，裡面只有一個值是單一存在的，其餘都兩兩成對，求單一存在的值為何？</p>
<p><strong>※</strong> 題目希望時間複雜度為 O(log n)</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>觀察規則，使用二元搜尋法即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;             </span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>, end = nums.size(), mid;</span><br><span class="line">        <span class="keyword">while</span>(end - begin != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (begin + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid - <span class="number">1</span>] != nums[mid] &amp;&amp; nums[mid] != nums[mid + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> nums[mid];</span><br><span class="line">            <span class="keyword">if</span>(nums[mid - <span class="number">1</span>] != nums[mid] &amp;&amp; nums[mid] == nums[mid + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span>(mid % <span class="number">2</span>)</span><br><span class="line">                    end = mid;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    begin = mid + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid - <span class="number">1</span>] == nums[mid] &amp;&amp; nums[mid] != nums[mid + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span>(mid % <span class="number">2</span>)</span><br><span class="line">                    begin = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[begin];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/540.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 55 解題紀錄</title>
    <url>/LeetCode-55/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/jump-game/">LeetCode - 55. Jump Game</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列，元素的值代表能走的步數，求是否能走到最後。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>定義一個 <code>maxPos</code> 代表能走到的最遠位置。用一個迴圈訪問 nums，若是目前元素的值小於等於 <code>maxPos</code>，代表這一格是可以走到的，計算 <code>i + nums[i]</code> 是否有大於 <code>maxPos</code>，若是有就替換掉。最後看 <code>maxPos</code> 是否大於等於 <code>nums.size() - 1</code> 即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxPos = <span class="number">0</span>, n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(i &lt;= maxPos)</span><br><span class="line">                maxPos = max(maxPos, i + nums[i]);</span><br><span class="line">        <span class="keyword">return</span> maxPos &gt;= n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/55.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 56 解題紀錄</title>
    <url>/LeetCode-56/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/merge-intervals/">LeetCode - 56. Merge Intervals</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個代表區間的陣列，要求將有重疊的區間合併。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先將區間依照起始點排序，接著遍歷區間，若是第一個區間或是區間的起始點大於上個區間的結尾點，表示兩者沒有重疊，直接存入 <code>res</code>，否則更新上個區間的結尾點即可將兩個區間合併。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span><br><span class="line">    &#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), [](<span class="keyword">auto</span>&amp; l, <span class="keyword">auto</span>&amp; r) &#123; <span class="keyword">return</span> l[<span class="number">0</span>] &lt; r[<span class="number">0</span>]; &#125;);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; interval : intervals)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res.empty() || interval[<span class="number">0</span>] &gt; res.back()[<span class="number">1</span>]) res.emplace_back(interval);</span><br><span class="line">            <span class="keyword">else</span> res.back()[<span class="number">1</span>] = max(res.back()[<span class="number">1</span>], interval[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/56.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 560 解題紀錄</title>
    <url>/LeetCode-560/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/subarray-sum-equals-k/">LeetCode - 560. Subarray Sum Equals K</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列及一個 <code>k</code>，求陣列中連續子陣列的和等於 <code>k</code> 的個數。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用一個迴圈，<code>sum</code> 為從 <code>nums[0]</code> 加到當前元素的值，使用 <code>unordered_map&lt;int, int&gt;</code> 紀錄子陣列和出現的次數。對於 <code>sum</code> 來說，每次得到新的 <code>sum</code> 時，若是前面的子陣列和有出現 <code>sum - k</code> 的話，代表新的子陣列和減掉舊的子陣列和就會得到 <code>k</code>，所以每次迴圈 <code>count</code> 都加上 <code>hash[sum - k]</code>，最後回傳 <code>count</code> 即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(!n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        hash.reserve(n);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            ++hash[sum];</span><br><span class="line">            sum += i;</span><br><span class="line">            count += hash[sum - k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/560.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<h3 id="補充"><a href="#補充" class="headerlink" title="補充"></a>補充</h3><p><code>++hash[sum]</code> 放在前面做是因為要在裡面放入 <code>&#123;0, 1&#125;</code>，代表子陣列和為 0 會出現一次。因為每次得到新的 <code>sum</code> 時，只會調用到 <code>hash[sum - k]</code>，所以直接把它放到前面做。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Unordered_map</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 567 解題紀錄</title>
    <url>/LeetCode-567/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/permutation-in-string/">LeetCode - 567. Permutation in String</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個 String <code>s1</code>、<code>s2</code>，求 <code>s2</code> 中是否有某段文字結構組成和 <code>s1</code> 相同。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>建兩個表，<code>v1</code> 放 <code>s1</code> 中的英文字母個數，<code>v2</code> 放 <code>s2</code> 某段的英文字母個數。使用一個迴圈遍歷 <code>s2</code>，將遍歷到的元素加入 <code>v2</code>，當裡面存放的字母個數超過 <code>s2</code> 的長度時，需要把最前面的刪除。最後判斷 <code>v2</code> 是否等於 <code>v1</code> 即可。 </p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = s1.size(), l2 = s2.size();</span><br><span class="line">        vector&lt;int&gt; v1(26), v2(26);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s1)</span><br><span class="line">            ++v1[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l2; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= l1)</span><br><span class="line">                --v2[s2[i - l1] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            ++v2[s2[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span>(v1 == v2)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/567.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 583 解題紀錄</title>
    <url>/LeetCode-583/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/delete-operation-for-two-strings/">LeetCode - 583. Delete Operation for Two Strings</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個 String，求刪除最少的字元數使兩者相等。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>可將問題想成，找出兩者的 LCS 在將兩者的長度個別減去 LCS 的值即為答案。<br>找 LCS 的作法可參考本篇文章：<a href="../LeetCode%20-%201143/" target="_blank">LeetCode - 1143 解題紀錄</a>。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = word1.size(), l2 = word2.size();</span><br><span class="line">        <span class="keyword">auto</span> dp = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(l1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(l2 + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l1; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= l2; ++j)</span><br><span class="line">                dp[i][j] = word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>] ? dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span> : max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> l1 + l2 - dp[l1][l2] * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/583.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 6 解題紀錄</title>
    <url>/LeetCode-6/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/zigzag-conversion/">LeetCode - 6. ZigZag Conversion</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個字串，依照要求 ( ZigZag ) 將字串轉換。題目其實就是每次都往下換行，到底再往上換行，到頂再往下不斷反覆直到 <code>s</code> 用盡。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用陣列儲存每一行的字符，遍歷陣列，依照位置放入陣列中的字串，最後再把所有字串串接起來即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), j = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">bool</span> reverse = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">v</span><span class="params">(numRows)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!reverse)</span><br><span class="line">            &#123;</span><br><span class="line">                v[++j] += c;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= numRows - <span class="number">1</span>) reverse = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                v[--j] += c;</span><br><span class="line">                <span class="keyword">if</span>(!j) reverse = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; str : v) res += str;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/6.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 64 解題紀錄</title>
    <url>/LeetCode-64/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/minimum-path-sum/">LeetCode - 64. Minimum Path Sum</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個二維陣列，求從左上走到右下的最小數字和。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>因為只能往右邊走或往下面走，所以 <code>走到每個點的最短距離</code> 為 <code>走到左邊的點的最短距離</code> 和 <code>走到上面的點的最短距離</code> 取最小值，根據此想法做動態規劃即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> height = grid.size(), width = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(height + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(width + <span class="number">1</span>, INT_MAX));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= height; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= width; ++j)</span><br><span class="line">                dp[i][j] = min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[height][width];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/64.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 677 解題紀錄</title>
    <url>/LeetCode-677/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/map-sum-pairs/">LeetCode - 677. Map Sum Pairs</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>設計一個 Class，並完成以下的函式。</p>
<span id="more"></span>

<ul>
<li><code>void insert(string key, int val)</code>：建立 <code>key</code> 及 <code>val</code> 的映射，若 <code>key</code> 已經存在就將新的 <code>val</code> 覆蓋舊的 <code>val</code>。</li>
<li><code>int sum(string prefix)</code>：回傳所有 <code>key</code> 的前綴為 <code>prefix</code> 的 <code>val</code> 總和。</li>
</ul>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 Unordered_map 存放資料。</p>
<ul>
<li><code>void insert(string key, int val)</code>：直接讓 <code>m[key] = val</code> 即可。</li>
<li><code>int sum(string prefix)</code>：遍歷 map，使用 String 的 <code>find()</code> 函式，若是結果為 0 代表 <code>prefix</code> 為當前 <code>key</code> 的前綴，計算總和即可。</li>
</ul>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapSum</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MapSum() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> key, <span class="keyword">int</span> val)</span> </span>&#123; m[key] = val; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="built_in">string</span> prefix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> _sum&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [key, val] : m) <span class="keyword">if</span>(!(key.find(prefix))) _sum += val;</span><br><span class="line">        <span class="keyword">return</span> _sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/677.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>Unordered_map</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 678 解題紀錄</title>
    <url>/LeetCode-678/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/valid-parenthesis-string/">LeetCode - 678. Valid Parenthesis String</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個字串，裡面只會有三種字元，<code>(</code>、<code>)</code>、<code>*</code>，要求檢驗字串是否有效。字串有效須滿足以下條件：</p>
<ul>
<li>任何的左括弧必須要有對應的右括弧</li>
<li>任何的右括弧必須要有對應的右括弧</li>
<li>左括弧必須在對應的右括弧前面</li>
</ul>
<p><strong>※</strong> <code>*</code> 號可代表左括弧、右括弧或空字元。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>可想像成左括弧會與最近的右括弧相消，所以使用一個 <code>count</code> 來記數，碰到左括弧就 + 1，碰到右括弧就 - 1。但是由於還有一個 <code>*</code> 號，而 <code>*</code> 可以是左括弧、右括弧或空字元，所以它可能會 + 1、- 1、或不變，以至於我們的 <code>count</code> 會是一個範圍，所以使用 max、 min 來做記數。在碰到括弧時一樣正常的 + 1、- 1，但碰到 <code>*</code> 號的話，<code>max + 1</code>、<code>min - 1</code>，而在做的期間 <code>max</code> 不可小於 0，因為 <code>max</code> 小於 0 的話代表會有右括弧前面沒有對應的左括弧，那這個字串就一定不是有效的，所以就直接回傳 <code>False</code>，而 <code>min</code> 也不能小於 0，因為 <code>min</code> 若是 0 的話代表 <code>*</code> 號只能當作左括弧或空字元，不能是右括弧。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkValidString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                ++min, ++max;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                --min, --max;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                --min, ++max;</span><br><span class="line">            <span class="keyword">if</span>(max &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(min &lt; <span class="number">0</span>)</span><br><span class="line">                min = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/678.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 713 解題紀錄 / September LeetCoding Challenge Day 28</title>
    <url>/LeetCode-713/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/subarray-product-less-than-k/">LeetCode - 713. Subarray Product Less Than K</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個只含正整數的陣列及整數 <code>k</code>，求陣列中有幾個子陣列相乘的乘積小於 <code>k</code>。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>由於題目有保證陣列大小會大於 0，所以需要先判斷若 <code>k &lt;= 1</code> 則直接回傳 0，接著使用 Sliding window，遍歷陣列當作確定的右端點 <code>r</code>，左端點 <code>l</code> 從 0 開始，若乘積已經大於等於 <code>k</code> 則將乘積除以 <code>nums[l]</code> 並將 <code>l</code> 加一，此時符合條件的子陣列個數為 <code>r - l + 1</code>。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, prod = <span class="number">1</span>, ret = <span class="number">0</span>, n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n; ++r)</span><br><span class="line">        &#123;</span><br><span class="line">            prod *= nums[r];</span><br><span class="line">            <span class="keyword">while</span>(prod &gt;= k) prod /= nums[l++];</span><br><span class="line">            ret += r - l + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/713.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
        <tag>Sliding Window</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 September</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 763 解題紀錄 / September LeetCoding Challenge Day 4</title>
    <url>/LeetCode-763/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/partition-labels/">LeetCode - 763. Partition Labels</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個只包含小寫英文字母的字串 <code>S</code>，求依照題目的要求分割的子串的長度。<span id="more"></span>題目要求子串中若出現某個字母，則此子串須包含字串中的所有此字母，並且需切割出最多的子串。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用一個陣列紀錄每個字母最後出現的 <code>index</code>，定義兩個整數 <code>l</code>, <code>r</code>，接著遍歷字串，<code>r</code> 每次更新為 <code>r</code> 及 <code>lastIdx[S[i] - &#39;a&#39;]</code> 兩者的最大值，這樣可以確保此子串能包含所有出現過的字母，若是 <code>i == r</code> 表示已經可以切割了，長度及為 <code>r - l + 1</code>，接著更新 <code>l</code> 即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = S.size(), l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v, lastIdx(<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) lastIdx[S[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            r = max(r, lastIdx[S[i] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span>(i == r) v.emplace_back(r - l + <span class="number">1</span>), l = ++r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/763.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 September</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 8 解題紀錄</title>
    <url>/LeetCode-8/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/string-to-integer-atoi/">LeetCode - 8. String to Integer (atoi)</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>定義一個自己的 <code>atoi()</code> 函數。<span id="more"></span></p>
<ul>
<li>字串前面的空白需忽視</li>
<li>正負號只看最前面的符號</li>
<li>若超過範圍則回傳最大值或最小值</li>
</ul>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用 String 的 <code>find_first_not_of()</code> 來去除前面的空白，接著先檢查是否有正負號，之後將數字存入即可。( 這邊使用 long 是為了避免越界 )</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> indicator = <span class="number">1</span>, mx = INT_MAX, idx = str.find_first_not_of(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(idx == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str[idx] == <span class="string">&#x27;+&#x27;</span> || str[idx] == <span class="string">&#x27;-&#x27;</span>) indicator = str[idx++] == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">isdigit</span>(str[idx]))</span><br><span class="line">        &#123;</span><br><span class="line">            res = res * <span class="number">10</span> + (str[idx++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(res &gt; mx) <span class="keyword">return</span> indicator == <span class="number">1</span> ? INT_MAX : INT_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * indicator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/8.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>String</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 835 解題紀錄 / September LeetCoding Challenge Day 6</title>
    <url>/LeetCode-835/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/image-overlap/">LeetCode - 835. Image Overlap</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個只包含 0 和 1 的正方形陣列代表圖片，求兩者經過左右、上下平移後能造成 1 重疊的最多數量。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先使用兩個陣列紀錄兩者圖片為 1 的所有座標，接著使用 HashMap 紀錄兩張圖片任意兩個 1 的偏移量相同的個數 ( 偏移量相同代表經過同樣的平移能使得兩者都重疊 )，最後找出最大值即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestOverlap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; B)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size(), cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; posA, posB; <span class="comment">// &#123;x, y&#125;</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; m; <span class="comment">// &#123;x, y&#125;, count</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i][j]) posA.emplace_back(i, j);</span><br><span class="line">            <span class="keyword">if</span>(B[i][j]) posB.emplace_back(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [xA, yA] : posA) <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [xB, yB] : posB) ++m[&#123;xB - xA, yB - yA&#125;];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [__, val] : m) cnt = max(cnt, val);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/835.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Map</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 September</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 901 解題紀錄</title>
    <url>/LeetCode-901/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/online-stock-span/">LeetCode - 901. Online Stock Span</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>設計一個 Class，負責收集每日股票的價格及跨度 ( 從今天開始往前數前面有幾天比今天的價格低 )。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p><strong>解法一：</strong> 動態規劃，<code>dp[i]</code> 代表第 <code>i</code> 天時前面有連續幾天比今天的價格低。當每次呼叫 <code>next()</code> 時，<code>j = i - 1</code> 表示前一天的價格，若是 <code>prices[i - 1] &lt;= price</code>，就將 <code>j</code> 減去 <code>dp[j]</code>，表示前面有多少天的價格小於今天的價格，重複執行直到 <code>j &lt; 0</code> 或是 <code>price &lt; prices[j]</code>，最後 <code>i - j + 1</code> 即是今天價格的跨度，最後將跨度推入 <code>dp</code> 及價格推入 <code>prices</code> 即可。</p>
<p><strong>解法二：</strong> 解法二其實是解法一的濃縮，我們可以發現，當 <code>dp[i]</code> 的數值確定後，前面幾天的資料其實就不需要了，所以我們可以使用 Stack，當每次呼叫 <code>next()</code> 時，若是 <code>top()</code> 的價格小於等於今天的價格，就將跨度加到今天，然後 <code>pop()</code> 掉，最後再將今天的價格及跨度推入即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><p>解法一：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StockSpanner() &#123;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> || price &lt; prices.back())</span><br><span class="line">            dp.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; price &gt;= prices[j])</span><br><span class="line">                j -= dp[j];</span><br><span class="line">            dp.push_back(i - j);</span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">        prices.push_back(price);</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prices;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/901-1.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<p>解法二：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StockSpanner() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> span = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top().first &lt;= price)</span><br><span class="line">            span += s.top().second, s.pop();</span><br><span class="line">        s.emplace(price, span);</span><br><span class="line">        <span class="keyword">return</span> span;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// &#123;price, span&#125;</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/901-2.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Stack</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 967 解題紀錄 / August LeetCoding Challenge Day 18</title>
    <url>/LeetCode-967/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/numbers-with-same-consecutive-differences/">LeetCode - 967. Numbers With Same Consecutive Differences</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個整數，<code>N</code> 代表位數，<code>K</code> 代表兩個數字的差，求為 <code>N</code> 位數且鄰近兩個數值的差為 <code>K</code> 的所有數。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>當我們要在一個數後面添加一位數字時，那個數字一定是原本數的最後一位數加 <code>K</code> 或減 <code>K</code>，依照此想法使用遞迴填完數字即可。需要注意的是當 <code>N</code> 為 1 時答案為 <code>&#123;0, 1, 2, ..., 9&#125;</code>，所以需要放入 0。而當 <code>K</code> 為 0 時，<code>l + k</code> 會等於 <code>l - k</code>，所以要排除避免出現兩個相同的數字。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">numsSameConsecDiff</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(N == <span class="number">1</span>) v.emplace_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i) dfs(N - <span class="number">1</span>, K, i, v);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!N) &#123; v.emplace_back(cur); <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">int</span> l = cur % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(l + K &lt;= <span class="number">9</span>) dfs(N - <span class="number">1</span>, K, cur * <span class="number">10</span> + l + K, v);</span><br><span class="line">        <span class="keyword">if</span>(l - K &gt;= <span class="number">0</span> &amp;&amp; K) dfs(N - <span class="number">1</span>, K, cur * <span class="number">10</span> + l - K, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/967.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Recursive</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 August</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 983 解題紀錄 / August LeetCoding Challenge Day 25</title>
    <url>/LeetCode-983/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/minimum-cost-for-tickets/">LeetCode - 983. Minimum Cost For Tickets</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個陣列，<code>days</code> 代表需要坐火車的日期，<code>costs</code> 代表火車的日票、周票、月票價格。求所有需要搭火車的日期都能搭火車的最小花費。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>動態規劃，若當天需要搭火車，最佳解為 <code>當天買一張日票</code>、<code>六天前買一張周票</code>、<code>29天前買一張月票</code>，三者的價格的最小值。若當天不需要搭火車，價格就為前一天的價格。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; days, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(days.back() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">set</span><span class="params">(days.begin(), days.end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= days.back(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">set</span>.count(i)) &#123; dp[i] = dp[i - <span class="number">1</span>]; <span class="keyword">continue</span>; &#125;</span><br><span class="line">            dp[i] = min(dp[max(<span class="number">0</span>, i - <span class="number">1</span>)] + costs[<span class="number">0</span>], min(dp[max(<span class="number">0</span>, i - <span class="number">7</span>)] + costs[<span class="number">1</span>], dp[max(<span class="number">0</span>, i - <span class="number">30</span>)] + costs[<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[days.back()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/983.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Dynamic Programming</tag>
        <tag>Vector</tag>
        <tag>Unordered_set</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 August</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 918 解題紀錄</title>
    <url>/LeetCode-918/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/maximum-sum-circular-subarray/">LeetCode - 918. Maximum Sum Circular Subarray</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個陣列，求此陣列的最大子陣列和。( 可以循環 )</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><ul>
<li><p><strong>想法：</strong> 最大子陣列和可能會有兩種情況，一種是沒有跨過頭尾，就是單純的最大子陣列和。另一種是有跨過頭尾，這時的和就是 <code>陣列和 - 最小子陣列和</code>。</p>
</li>
<li><p><strong>作法：</strong> 使用一個迴圈得到最大子陣列和及最小子陣列和，最後比對 <code>sum - mn</code> 及 <code>max</code> 何者較大即可。需要注意的是，若是最小值 <code>mn</code> 和 <code>sum</code> 相等，代表整個陣列都是負的，這時需要直接回傳 <code>max</code>。</p>
</li>
</ul>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mx = INT_MIN, mn = INT_MAX, currMax = <span class="number">0</span>, currMin = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : A)</span><br><span class="line">        &#123;</span><br><span class="line">            currMax = max(currMax + i, i);</span><br><span class="line">            currMin = min(currMin + i, i);</span><br><span class="line">            mx = max(currMax, mx);</span><br><span class="line">            mn = min(currMin, mn);</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum == mn ? mx : max(sum - mn, mx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/918.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 969 解題紀錄 / August LeetCoding Challenge Day 29</title>
    <url>/LeetCode-969/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/pancake-sorting/">LeetCode - 969. Pancake Sorting</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>利用煎餅排序將一個陣列排序好。並回傳每次翻轉的個數。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>由於前面翻轉並不會影響到後面的排序，所以主要想法為每次將最大的排序到後面，接著都只翻轉前面，最後即可完成排序。使用 <code>find()</code> 找到當前要找的值的位置，接著翻轉一次，此時最大的值會在陣列的最前面，接著翻轉一次將這個值翻轉到後面即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pancakeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = A.size(); i &gt; <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = find(A.begin(), A.end(), i) - A.begin();</span><br><span class="line">            reverse(A.begin(), A.begin() + pos + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(pos) v.emplace_back(pos + <span class="number">1</span>);</span><br><span class="line">            reverse(A.begin(), A.begin() + i);</span><br><span class="line">            v.emplace_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/969.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 August</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 986 解題紀錄</title>
    <url>/LeetCode-986/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/interval-list-intersections/">LeetCode - 986. Interval List Intersections</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給兩個代表區間的陣列，求兩陣列的交集。</p>
<span id="more"></span>

<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>使用雙指針，<code>s</code> 為兩者開頭較大的值，<code>e</code> 為兩者結束較小的值，若是 <code>s &lt;= e</code> 則代表這是一段交集，最後看哪個的結尾比較小，就往前移動那個指針。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast IO</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">auto</span> __ = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; intervalIntersection(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; B) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, s, e;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; A.size() &amp;&amp; j &lt; B.size())</span><br><span class="line">        &#123;</span><br><span class="line">            s = max(A[i][<span class="number">0</span>], B[j][<span class="number">0</span>]);</span><br><span class="line">            e = min(A[i][<span class="number">1</span>], B[j][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(s &lt;= e)</span><br><span class="line">                res.emplace_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;s, e&#125;);</span><br><span class="line">            A[i][<span class="number">1</span>] &gt; B[j][<span class="number">1</span>] ? ++j : ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/986.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Vector</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 987 解題紀錄 / August LeetCoding Challenge Day 7</title>
    <url>/LeetCode-987/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/">LeetCode - 987. Vertical Order Traversal of a Binary Tree</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個 Binary Tree，將 Tree 加上虛擬座標，root 為 (0, 0)，左邊節點為 (x - 1, y - 1)，右邊節點為 (x + 1, y - 1)。<span id="more"></span>求從 x 的最小值到 x 的最大值中的元素。( 相同 x 的放在一起，若 x 相同則 y 較小的在前面，若 x、y 都相同則按照數值大小排序 )</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>為了方便排序所以將 y 軸反轉，使用 <code>map&lt;pair&lt;int, int&gt;, priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;&gt;</code> 紀錄資料，由於 <code>map</code> 的特性，會依照 <code>pair</code> 的 first 排序，所以裡面存放 {y, x}，由於 <code>priority_queue</code> 會依照資料的大小排序，所以用來存放數值。接著透過遞迴取得資料最後再存入 Vector 即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; verticalTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">int</span> min_x = INT_MAX, max_x = INT_MIN;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;&gt; m_;</span><br><span class="line">        extract(root, <span class="number">0</span>, <span class="number">0</span>, m_, min_x, max_x);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v(max_x - min_x + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; m : m_)</span><br><span class="line">            <span class="keyword">while</span>(!m.second.empty())</span><br><span class="line">                v[m.first.second - min_x].emplace_back(m.second.top()), m.second.pop();</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">extract</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">map</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;&gt;&amp; m_, <span class="keyword">int</span>&amp; min_x, <span class="keyword">int</span>&amp; max_x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        min_x = min(min_x, x);</span><br><span class="line">        max_x = max(max_x, x);</span><br><span class="line">        m_[&#123;y, x&#125;].push(root-&gt;val);</span><br><span class="line">        extract(root-&gt;left, x - <span class="number">1</span>, y + <span class="number">1</span>, m_, min_x, max_x);</span><br><span class="line">        extract(root-&gt;right, x + <span class="number">1</span>, y + <span class="number">1</span>, m_, min_x, max_x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/987-1.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<hr>
<p>2020/10/26 Rewrite</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; verticalTraversal(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min_x = INT_MAX, max_x = INT_MIN;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt;&gt; _m;</span><br><span class="line">        </span><br><span class="line">        function&lt;<span class="keyword">void</span>(TreeNode*, <span class="keyword">int</span>, <span class="keyword">int</span>)&gt; traversal = [&amp;](TreeNode* r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!r) <span class="keyword">return</span>;</span><br><span class="line">            min_x = min(x, min_x);</span><br><span class="line">            max_x = max(x, max_x);</span><br><span class="line">            _m[&#123;y, x&#125;].push(r-&gt;val);</span><br><span class="line">            traversal(r-&gt;left, x - <span class="number">1</span>, y + <span class="number">1</span>);</span><br><span class="line">            traversal(r-&gt;right, x + <span class="number">1</span>, y + <span class="number">1</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        traversal(root, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v(max_x - min_x + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [pos, pq] : _m) <span class="keyword">while</span> (!pq.empty()) v[pos.second - min_x].emplace_back(pq.top()), pq.pop();</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/987-2.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Map</tag>
        <tag>Recursive</tag>
        <tag>Vector</tag>
        <tag>Priority_queue</tag>
        <tag>Tree</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 August</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 994 解題紀錄 / August LeetCoding Challenge Day 9</title>
    <url>/LeetCode-994/</url>
    <content><![CDATA[<p>題目： <a href="https://leetcode.com/problems/rotting-oranges/">LeetCode - 994. Rotting Oranges</a></p>
<h3 id="題目說明"><a href="#題目說明" class="headerlink" title="題目說明"></a>題目說明</h3><p>給一個二維陣列，裡面只含有 0、1、2。<span id="more"></span>0 代表該座標沒有東西，1 代表該座標有一顆正常的橘子，2 代表該座標有一顆腐敗的橘子，腐敗的橘子每經過一天會使得上下左右四顆橘子也腐敗，求讓所有橘子都腐敗需要的天數，若無法使所有橘子腐敗就回傳 -1。</p>
<h3 id="解題思路"><a href="#解題思路" class="headerlink" title="解題思路"></a>解題思路</h3><p>先遍歷一次整個陣列，紀錄新鮮橘子的個數，腐敗橘子的座標使用 Queue 存放。接著把所有座標拿出並感染上下左右正常的橘子，再把新腐敗的橘子座標存入 Queue，清空一次 Queue 代表經過了一天，最後判斷是否還有未腐敗的橘子即可。</p>
<h3 id="參考解法"><a href="#參考解法" class="headerlink" title="參考解法"></a>參考解法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> height = grid.size(), width = grid[<span class="number">0</span>].size(), fresh = <span class="number">0</span>, days = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> offset[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; _q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; ++i) <span class="comment">// y</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; ++j) <span class="comment">// x</span></span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>) ++fresh;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j] == <span class="number">2</span>) _q.emplace(j, i);</span><br><span class="line">        <span class="keyword">while</span>(!_q.empty() &amp;&amp; fresh)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = _q.size();</span><br><span class="line">            <span class="keyword">while</span>(size--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x = _q.front().first, y = _q.front().second;</span><br><span class="line">                _q.pop();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> dx = x + offset[i], dy = y + offset[i + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(dx &lt; <span class="number">0</span> || dx &gt;= width || dy &lt; <span class="number">0</span> || dy &gt;= height || grid[dy][dx] != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    --fresh;</span><br><span class="line">                    grid[dy][dx] = <span class="number">2</span>;</span><br><span class="line">                    _q.emplace(dx, dy);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++days;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fresh ? <span class="number">-1</span> : days;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/994-1.cpp"><i class="fa fa-download fa-2x"></i></a></p>
<p>2020-08-19 重寫</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> height = grid.size(), width = grid[<span class="number">0</span>].size(), fresh = <span class="number">0</span>, days = <span class="number">0</span>, size;</span><br><span class="line">        <span class="keyword">int</span> offset[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; ++i) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; ++j)</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>) ++fresh; <span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j] == <span class="number">2</span>) q.emplace(j, i);</span><br><span class="line">        <span class="keyword">while</span>((size = q.size()) &amp;&amp; fresh &amp;&amp; ++days) <span class="keyword">while</span>(size--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x, y] = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> dx = x + offset[i], dy = y + offset[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(dx &lt; <span class="number">0</span> || dx &gt;= width || dy &lt; <span class="number">0</span> || dy &gt;= height || grid[dy][dx] != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                grid[dy][dx] = <span class="number">2</span>;</span><br><span class="line">                --fresh;</span><br><span class="line">                q.emplace(dx, dy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fresh ? <span class="number">-1</span> : days;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/larrylai19/ExampleCode/blob/master/LeetCode/994-2.cpp"><i class="fa fa-download fa-2x"></i></a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Queue</tag>
        <tag>LeetCode</tag>
        <tag>LeetCode 30 August</tag>
        <tag>LeetCode - Medium</tag>
      </tags>
  </entry>
</search>
